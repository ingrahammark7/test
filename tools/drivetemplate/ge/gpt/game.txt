media_rw
#python cs.py split --input game.txt
#python cs.py rebuild --output game.txt

import re
import os
import ast
import textwrap

def split_game_txt(input_file="game.txt"):
    """Splits game.txt into individual Python files based on class names."""
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("media_rw")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """Rebuilds game.txt by concatenating all .py files in the current directory."""
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("media_rw\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def validate_snippet(snippet):
    """Validates the syntax of a code snippet using Python's AST module."""
    try:
        dedented_snippet = textwrap.dedent(snippet)  # Remove unnecessary indentation
        ast.parse(dedented_snippet)
        print("Snippet is syntactically valid.")
        return True
    except SyntaxError as e:
        print(f"Syntax error in snippet: {e}")
        print("Snippet content:")
        print(snippet)
        return False

def modify_file_from_temp(temp_file="temp.txt"):
    """Modifies a .py file based on instructions from temp.txt."""
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        # Validate the snippet syntax before applying
        if not validate_snippet(snippet):
            print("Modification aborted due to invalid syntax in snippet.")
            return

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        # Ensure the specified line range is valid
        with open(filename, "r") as file:
            file_contents = file.readlines()
        if start_line > len(file_contents) or end_line > len(file_contents) + 1:
            print(f"Invalid line range: {start_line}-{end_line}. File has {len(file_contents)} lines.")
            return

        # Create a backup of the file
        backup_filename = f"{filename}.bak"
        os.rename(filename, backup_filename)
        print(f"Backup created: {backup_filename}")

        # Apply modification
        modified_contents = (
            file_contents[:start_line - 1] + file_contents[end_line:]  # Remove specified lines
        )
        modified_contents.insert(start_line - 1, snippet)  # Insert new snippet

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """Dynamically generates temp.txt based on the parameters provided."""
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()
media_rw
#python cs.py split --input game.txt
#python cs.py rebuild --output game.txt

import re
import os
import ast
import textwrap

def split_game_txt(input_file="game.txt"):
    """Splits game.txt into individual Python files based on class names."""
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("

#python cs.py split --input game.txt
#python cs.py rebuild --output game.txt

import re
import os
import ast
import textwrap

def split_game_txt(input_file="game.txt"):
    """Splits game.txt into individual Python files based on class names."""
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("

#python cs.py rebuild --output game.txt

import re
import os
import ast
import textwrap

def split_game_txt(input_file="game.txt"):
    """Splits game.txt into individual Python files based on class names."""
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("

import re
import os

def split_game_txt(input_file="game.txt"):
    """
    Splits game.txt into individual Python files based on class names.
    """
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("

#python cs.py split --input game.txt
#python cs.py rebuild --output game.txt

import re
import os
import ast
import textwrap

def split_game_txt(input_file="game.txt"):
    """Splits game.txt into individual Python files based on class names."""
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("
media_rw
")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """Rebuilds game.txt by concatenating all .py files in the current directory."""
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("

\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def validate_snippet(snippet):
    """Validates the syntax of a code snippet using Python's AST module."""
    try:
        dedented_snippet = textwrap.dedent(snippet)  # Remove unnecessary indentation
        ast.parse(dedented_snippet)
        print("Snippet is syntactically valid.")
        return True
    except SyntaxError as e:
        print(f"Syntax error in snippet: {e}")
        print("Snippet content:")
        print(snippet)
        return False

def modify_file_from_temp(temp_file="temp.txt"):
    """Modifies a .py file based on instructions from temp.txt."""
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        # Validate the snippet syntax before applying
        if not validate_snippet(snippet):
            print("Modification aborted due to invalid syntax in snippet.")
            return

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        # Ensure the specified line range is valid
        with open(filename, "r") as file:
            file_contents = file.readlines()
        if start_line > len(file_contents) or end_line > len(file_contents) + 1:
            print(f"Invalid line range: {start_line}-{end_line}. File has {len(file_contents)} lines.")
            return

        # Create a backup of the file
        backup_filename = f"{filename}.bak"
        os.rename(filename, backup_filename)
        print(f"Backup created: {backup_filename}")

        # Apply modification
        modified_contents = (
            file_contents[:start_line - 1] + file_contents[end_line:]  # Remove specified lines
        )
        modified_contents.insert(start_line - 1, snippet)  # Insert new snippet

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """Dynamically generates temp.txt based on the parameters provided."""
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()

")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """Rebuilds game.txt by concatenating all .py files in the current directory."""
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("

\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def validate_snippet(snippet):
    """Validates the syntax of a code snippet using Python's AST module."""
    try:
        dedented_snippet = textwrap.dedent(snippet)  # Remove unnecessary indentation
        ast.parse(dedented_snippet)
        print("Snippet is syntactically valid.")
        return True
    except SyntaxError as e:
        print(f"Syntax error in snippet: {e}")
        print("Snippet content:")
        print(snippet)
        return False

def modify_file_from_temp(temp_file="temp.txt"):
    """Modifies a .py file based on instructions from temp.txt."""
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        # Validate the snippet syntax before applying
        if not validate_snippet(snippet):
            print("Modification aborted due to invalid syntax in snippet.")
            return

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        # Ensure the specified line range is valid
        with open(filename, "r") as file:
            file_contents = file.readlines()
        if start_line > len(file_contents) or end_line > len(file_contents) + 1:
            print(f"Invalid line range: {start_line}-{end_line}. File has {len(file_contents)} lines.")
            return

        # Create a backup of the file
        backup_filename = f"{filename}.bak"
        os.rename(filename, backup_filename)
        print(f"Backup created: {backup_filename}")

        # Apply modification
        modified_contents = (
            file_contents[:start_line - 1] + file_contents[end_line:]  # Remove specified lines
        )
        modified_contents.insert(start_line - 1, snippet)  # Insert new snippet

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """Dynamically generates temp.txt based on the parameters provided."""
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()

")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """Rebuilds game.txt by concatenating all .py files in the current directory."""
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("

\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def validate_snippet(snippet):
    """Validates the syntax of a code snippet using Python's AST module."""
    try:
        dedented_snippet = textwrap.dedent(snippet)  # Remove unnecessary indentation
        ast.parse(dedented_snippet)
        print("Snippet is syntactically valid.")
        return True
    except SyntaxError as e:
        print(f"Syntax error in snippet: {e}")
        print("Snippet content:")
        print(snippet)
        return False

def modify_file_from_temp(temp_file="temp.txt"):
    """Modifies a .py file based on instructions from temp.txt."""
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        # Validate the snippet syntax before applying
        if not validate_snippet(snippet):
            print("Modification aborted due to invalid syntax in snippet.")
            return

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        # Ensure the specified line range is valid
        with open(filename, "r") as file:
            file_contents = file.readlines()
        if start_line > len(file_contents) or end_line > len(file_contents) + 1:
            print(f"Invalid line range: {start_line}-{end_line}. File has {len(file_contents)} lines.")
            return

        # Create a backup of the file
        backup_filename = f"{filename}.bak"
        os.rename(filename, backup_filename)
        print(f"Backup created: {backup_filename}")

        # Apply modification
        modified_contents = (
            file_contents[:start_line - 1] + file_contents[end_line:]  # Remove specified lines
        )
        modified_contents.insert(start_line - 1, snippet)  # Insert new snippet

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """Dynamically generates temp.txt based on the parameters provided."""
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()

")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """Rebuilds game.txt by concatenating all .py files in the current directory."""
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("

\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def validate_snippet(snippet):
    """Validates the syntax of a code snippet using Python's AST module."""
    try:
        dedented_snippet = textwrap.dedent(snippet)  # Remove unnecessary indentation
        ast.parse(dedented_snippet)
        print("Snippet is syntactically valid.")
        return True
    except SyntaxError as e:
        print(f"Syntax error in snippet: {e}")
        print("Snippet content:")
        print(snippet)
        return False

def modify_file_from_temp(temp_file="temp.txt"):
    """Modifies a .py file based on instructions from temp.txt."""
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        # Validate the snippet syntax before applying
        if not validate_snippet(snippet):
            print("Modification aborted due to invalid syntax in snippet.")
            return

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        # Ensure the specified line range is valid
        with open(filename, "r") as file:
            file_contents = file.readlines()
        if start_line > len(file_contents) or end_line > len(file_contents) + 1:
            print(f"Invalid line range: {start_line}-{end_line}. File has {len(file_contents)} lines.")
            return

        # Create a backup of the file
        backup_filename = f"{filename}.bak"
        os.rename(filename, backup_filename)
        print(f"Backup created: {backup_filename}")

        # Apply modification
        modified_contents = (
            file_contents[:start_line - 1] + file_contents[end_line:]  # Remove specified lines
        )
        modified_contents.insert(start_line - 1, snippet)  # Insert new snippet

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """Dynamically generates temp.txt based on the parameters provided."""
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()

")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """
    Rebuilds game.txt by concatenating all .py files in the current directory.
    """
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("

\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def modify_file_from_temp(temp_file="temp.txt"):
    """
    Modifies a .py file based on instructions from temp.txt.
    """
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        with open(filename, "r") as file:
            file_contents = file.readlines()

        # Replace lines
        modified_contents = file_contents[:start_line - 1] + file_contents[end_line:]
        modified_contents.insert(start_line - 1, snippet)

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """
    Dynamically generates temp.txt based on the parameters provided.
    """
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()
media_rw
import tkinter as tk
from GameUI import GameUI
from TerrainManager import TerrainManager
from PlayerManager import PlayerManager
from EnemyManager import EnemyManager
from CombatManager import CombatManager


class TacticalMap:
    def __init__(self, root, on_replay=None):
        """
        Initializes the TacticalMap, setting up game managers and the UI.

        Args:
            root (tk.Tk): The root window for the game.
            on_replay (callable): A callback function to restart the game.
        """
        self.root = root
        self.ui = GameUI(root)
        self.terrain_manager = TerrainManager(self.ui.map_buttons)
        self.player_manager = PlayerManager(self.ui.map_buttons, self.terrain_manager, self.ui)
        self.enemy_manager = EnemyManager(self.ui.map_buttons, self.terrain_manager, enemy_count=5)
        self.combat_manager = CombatManager(
            self.ui.map_buttons,
            player_stats={"hp": 20, "ammo": 3},
            enemy_stats={"hp": 10}
        )
        self.on_replay = on_replay
        self.turn = "Player"
        self.grid_rows = 7
        self.grid_cols = 7
        self.determine_grid_dimensions()
        self.initialize_game()

    def determine_grid_dimensions(self):
        """
        Dynamically sets grid dimensions based on screen size.
        """
        screen_width = self.ui.root.winfo_screenwidth()
        screen_height = self.ui.root.winfo_screenheight()
        if screen_height >= 2 * screen_width:
            self.grid_rows, self.grid_cols = 14, 7
        else:
            self.grid_rows, self.grid_cols = 7, 7

    def initialize_game(self):
        """
        Sets up the game grid, generates terrain, and deploys units.
        Retries if necessary.
        """
        self.ui.create_map(rows=self.grid_rows, cols=self.grid_cols, on_cell_click=self.on_cell_click)
        self.ui.create_log_area()

        for _ in range(5):  # Attempt up to 5 times
            if self.terrain_manager.generate_terrain(enemy_count=5):
                try:
                    self.player_manager.deploy_player("T-64 Tank")
                    self.enemy_manager.deploy_enemies("Enemy Unit")
                    self.ui.update_log("Game initialized. Player's turn begins.")
                    return
                except ValueError:
                    self.ui.update_log("Deployment failed. Retrying...")
        self.ui.update_log("Failed to initialize game.")
        self.end_game(victory=False)

    def on_cell_click(self, coord):
        """
        Handles a player's action when a cell is clicked.

        Args:
            coord (str): The coordinate of the clicked cell.
        """
        if self.turn == "Player":
            self.handle_player_action(coord)

    def handle_player_action(self, coord):
        """
        Processes the player's action: move, attack, or use artillery.

        Args:
            coord (str): The target cell coordinate.
        """
        player_position = self.player_manager.player_position
        distance_row = abs(ord(coord[0]) - ord(player_position[0]))
        distance_col = abs(int(coord[1]) - int(player_position[1]))

        # Artillery attack for distant targets
        if max(distance_row, distance_col) > 1:
            if self.player_manager.use_ammo():
                results = self.combat_manager.artillery_attack(coord, self.enemy_manager.enemy_positions)
                for result in results:
                    self.ui.update_log(result)
                self.end_turn()
            else:
                self.ui.update_log("No ammo left!")
            return

        # Regular move or attack for adjacent cells
        if max(distance_row, distance_col) == 1:
            terrain = self.terrain_manager.get_terrain(coord)
            if coord in self.enemy_manager.enemy_positions:
                result = self.combat_manager.player_attack(coord, self.enemy_manager.enemy_positions)
                self.ui.update_log(result)
                if not self.enemy_manager.enemy_positions:
                    self.end_game(victory=True)
            elif terrain in ["Empty", "Forest"]:
                self.player_manager.move_player(coord, "T-64 Tank")
                self.end_turn()
            else:
                self.ui.update_log("Cannot move to that terrain!")
        else:
            self.ui.update_log("Invalid move. Choose an adjacent tile.")

    def enemy_action(self):
        """
        Executes the enemies' turn, including movement and attacks.
        """
        self.ui.update_log("Enemies are taking their turn...")
        for enemy_pos in list(self.enemy_manager.enemy_positions.keys()):
            if self.enemy_manager.is_adjacent(enemy_pos, self.player_manager.player_position):
                result = self.combat_manager.enemy_attack(self.player_manager.player_position)
                self.ui.update_log(result)
                if self.player_manager.player_stats["hp"] <= 0:
                    self.end_game(victory=False)
                    return
            else:
                new_pos = self.enemy_manager.move_toward_player(
                    enemy_pos, self.player_manager.player_position, "Enemy Unit"
                )
                self.enemy_manager.enemy_positions[new_pos] = self.enemy_manager.enemy_positions.pop(enemy_pos)
        if not self.enemy_manager.enemy_positions:
            self.end_game(victory=True)
        else:
            self.end_turn()

    def end_turn(self):
        """
        Alternates turns between the player and the enemies.
        """
        if self.turn == "Player":
            self.turn = "Enemy"
            self.enemy_action()
        else:
            self.turn = "Player"
            self.ui.update_log("Your turn!")

    def end_game(self, victory):
        """
        Concludes the game with a victory or defeat message.

        Args:
            victory (bool): True if the player wins, False otherwise.
        """
        message = "You Win!" if victory else "Game Over!"
        self.ui.update_log(message)
        self.ui.show_end_screen(message)

    def reset(self):
        """
        Resets the TacticalMap to its initial state for a new game.
        """
        self.ui.map_buttons.clear()
        self.ui.cell_states.clear()
        self.terrain_manager.reset()
        self.player_manager.reset()
        self.enemy_manager.reset()
        self.combat_manager = CombatManager(
            self.ui.map_buttons,
            player_stats={"hp": 20, "ammo": 3},
            enemy_stats={"hp": 10}
        )
        self.turn = "Player"
        self.initialize_game()


if __name__ == "__main__":
    """
    Entry point for running the TacticalMap as a standalone game.
    Creates the root window and starts the game.
    """
    root = tk.Tk()
    root.title("Turn-Based Tactical Simulation")
    game = TacticalMap(root)
    root.mainloop()
media_rw
class CombatManager:
    def __init__(self, map_buttons, player_stats, enemy_stats):
        """
        Initializes the CombatManager with references to map buttons,
        the player's statistics, and the enemy's statistics.

        Args:
            map_buttons (dict): Dictionary of map cell buttons.
            player_stats (dict): Dictionary containing player stats (e.g., {"hp": 20, "ammo": 5}).
            enemy_stats (dict): Dictionary containing enemy stats (e.g., {"hp": 10}).
        """
        self.map_buttons = map_buttons  # Reference to the map buttons
        self.player_stats = player_stats  # Player's statistics
        self.enemy_stats = enemy_stats  # Enemy's statistics

    def player_attack(self, target_coord, enemy_positions):
        """
        Handles the player's attack on an enemy unit.

        Args:
            target_coord (str): The coordinate of the enemy being attacked.
            enemy_positions (dict): A dictionary mapping enemy positions to their HP.

        Returns:
            str: A message describing the outcome of the attack.
        """
        if target_coord in enemy_positions:
            # Damage the enemy by 5 points
            enemy_positions[target_coord] -= 5
            if enemy_positions[target_coord] <= 0:
                # Enemy is defeated; update map visuals
                del enemy_positions[target_coord]
                self.map_buttons[target_coord].config(text="Empty", bg="lightgray")
                return f"Enemy at {target_coord} is defeated!"
            else:
                return f"Enemy at {target_coord} HP reduced to {enemy_positions[target_coord]}."
        return "No enemy to attack at the selected position."

    def artillery_attack(self, target_coord, enemy_positions):
        """
        Handles artillery attacks, damaging the target and adjacent tiles.

        Args:
            target_coord (str): The main target coordinate.
            enemy_positions (dict): A dictionary of enemy positions and their HP.

        Returns:
            list: Messages describing the results of the attack.
        """
        results = []
        row = ord(target_coord[0])
        col = int(target_coord[1:])

        # Calculate affected coordinates (target + adjacent tiles)
        affected_coords = [
            target_coord,
            f"{chr(row - 1)}{col}",
            f"{chr(row + 1)}{col}",
            f"{chr(row)}{col - 1}",
            f"{chr(row)}{col + 1}"
        ]

        for coord in affected_coords:
            if coord in enemy_positions:
                enemy_positions[coord] -= 10  # Artillery deals 10 damage
                if enemy_positions[coord] <= 0:
                    del enemy_positions[coord]
                    self.map_buttons[coord].config(text="Empty", bg="lightgray")
                    results.append(f"Enemy at {coord} destroyed by artillery.")
                else:
                    results.append(f"Enemy at {coord} hit by artillery. HP now {enemy_positions[coord]}.")
            elif coord in self.map_buttons:
                results.append(f"Artillery hit {coord}, but no enemies present.")

        return results

    def enemy_attack(self, player_position):
        """
        Handles the enemy's attack on the player.

        Args:
            player_position (str): The current position of the player.

        Returns:
            str: Message describing the result of the attack.
        """
        # Enemies deal a fixed 5 damage to the player
        self.player_stats["hp"] -= 5
        if self.player_stats["hp"] <= 0:
            return "Player is defeated!"
        else:
            return f"Player HP reduced to {self.player_stats['hp']}."

    def reset(self, player_stats=None, enemy_stats=None):
        """
        Resets the CombatManager to its initial state.

        Args:
            player_stats (dict, optional): Updated stats for the player.
            enemy_stats (dict, optional): Updated stats for the enemies.
        """
        self.player_stats = player_stats if player_stats else {"hp": 20, "ammo": 5}
        self.enemy_stats = enemy_stats if enemy_stats else {"hp": 10}
media_rw
import random

class EnemyManager:
    def __init__(self, map_buttons, terrain_manager, enemy_count):
        """
        Initializes the EnemyManager with references to the map buttons,
        terrain manager, and the number of enemy units.

        Args:
            map_buttons (dict): Dictionary of map cell buttons.
            terrain_manager (TerrainManager): Instance managing map terrain.
            enemy_count (int): Number of enemy units to deploy.
        """
        self.map_buttons = map_buttons  # Reference to the map buttons
        self.terrain_manager = terrain_manager  # Reference to the terrain manager
        self.enemy_positions = {}  # Dictionary to track enemy positions and their HP
        self.enemy_count = enemy_count  # Total number of enemy units to deploy

    def deploy_enemies(self, enemy_unit_name):
        """
        Deploys enemy units on random empty tiles with starting HP.

        Args:
            enemy_unit_name (str): The name of the enemy units (e.g., "Enemy Unit").

        Returns:
            list: A list of coordinates where the enemies are deployed.

        Raises:
            ValueError: If there are not enough empty spaces for deployment.
        """
        # Find all empty cells suitable for enemy deployment
        empty_cells = [
            coord for coord, terr in self.terrain_manager.terrain.items()
            if terr == "Empty" and self.map_buttons[coord].cget("text") == "Empty"
        ]
        if len(empty_cells) < self.enemy_count:
            raise ValueError("Not enough empty spaces to deploy enemies.")

        # Randomly deploy enemies in empty cells
        for coord in random.sample(empty_cells, self.enemy_count):
            self.enemy_positions[coord] = 10  # Each enemy starts with 10 HP
            self.map_buttons[coord].config(text=enemy_unit_name, bg="red")
        return list(self.enemy_positions.keys())

    def move_toward_player(self, enemy_position, player_position, enemy_name):
        """
        Moves an enemy unit toward the player's position.

        Args:
            enemy_position (str): The current position of the enemy unit.
            player_position (str): The current position of the player unit.
            enemy_name (str): The name of the enemy unit (e.g., "Enemy Unit").

        Returns:
            str: The new position of the enemy unit.
        """
        enemy_row, enemy_col = ord(enemy_position[0]), int(enemy_position[1:])
        player_row, player_col = ord(player_position[0]), int(player_position[1:])

        dr = player_row - enemy_row
        dc = player_col - enemy_col

        # Determine the best movement direction
        if abs(dr) > abs(dc):
            new_pos = f"{chr(enemy_row + (1 if dr > 0 else -1))}{enemy_col}"
        else:
            new_pos = f"{chr(enemy_row)}{enemy_col + (1 if dc > 0 else -1)}"

        # Validate the move
        if new_pos in self.map_buttons:
            terrain = self.terrain_manager.get_terrain(new_pos)
            if terrain == "Water":
                # Enemies have a 50% chance to cross water
                if random.random() < 0.5:
                    self._move_enemy(enemy_position, new_pos, enemy_name)
                    return new_pos
                return enemy_position
            elif terrain == "Mountain":
                # Enemies have a 30% chance to cross mountains
                if random.random() < 0.3:
                    self._move_enemy(enemy_position, new_pos, enemy_name)
                    return new_pos
                return enemy_position
            elif terrain in ["Empty", "Forest"]:
                self._move_enemy(enemy_position, new_pos, enemy_name)
                return new_pos

        # Stay in place if the move is invalid
        return enemy_position

    def _move_enemy(self, current_position, target_position, enemy_name):
        """
        Handles the actual movement of an enemy unit.

        Args:
            current_position (str): The current position of the enemy unit.
            target_position (str): The target position to move to.
            enemy_name (str): The name of the enemy unit.
        """
        # Update map visuals to reflect the enemy movement
        self.map_buttons[current_position].config(text="Empty", bg="lightgray")
        self.map_buttons[target_position].config(text=enemy_name, bg="red")

    def is_adjacent(self, pos1, pos2):
        """
        Checks if two positions are adjacent on the map.

        Args:
            pos1 (str): The first position (e.g., "A1").
            pos2 (str): The second position (e.g., "B2").

        Returns:
            bool: True if the positions are adjacent, False otherwise.
        """
        row_diff = abs(ord(pos1[0]) - ord(pos2[0]))
        col_diff = abs(int(pos1[1:]) - int(pos2[1:]))
        return max(row_diff, col_diff) == 1

    def reset(self):
        """
        Resets the EnemyManager to its initial state for a new game.
        """
        # Clear enemy positions and reset the enemy count if needed
        for coord in list(self.enemy_positions.keys()):
            self.map_buttons[coord].config(text="Empty", bg="lightgray")
        self.enemy_positions.clear()
media_rw
import tkinter as tk
import math

class MapButtonWrapper:
    def __init__(self, rect, text_id, canvas):
        """
        Wraps a canvas cell (rectangle and text) so that it mimics a widget
        with a config() and cget() method.
        """
        self.rect = rect
        self.text_id = text_id
        self.canvas = canvas
        self.config_dict = {"text": "Empty", "bg": "gray"}
        
    def config(self, **kwargs):
        """
        Simulates the config() method of a Tkinter widget.
        """
        if "text" in kwargs:
            self.canvas.itemconfigure(self.text_id, text=kwargs["text"])
            self.config_dict["text"] = kwargs["text"]
        if "bg" in kwargs:
            self.canvas.itemconfigure(self.rect, fill=kwargs["bg"])
            self.config_dict["bg"] = kwargs["bg"]
            
    def cget(self, key):
        """
        Simulates the cget() method of a Tkinter widget.
        """
        return self.config_dict.get(key, None)

class GameUI:
    def __init__(self, root):
        """
        Initializes the GameUI with a canvas-based grid and a persistent log area.
        """
        self.root = root
        self.canvas = tk.Canvas(self.root, bg="black")
        self.canvas.pack(fill="both", expand=True)

        # Grid parameters
        self.grid_rows = 7
        self.grid_cols = 7
        self.cell_size = 80  # Each cell is 80x80 pixels
        
        # Simulates the map_buttons that other managers expect.
        self.map_buttons = {}  
        self.angle = 0  # Rotation angle for the cube

        self.create_log_area()
        
    def create_map(self, rows=7, cols=7, on_cell_click=None):
        """
        Draws a grid of cells directly on the Canvas and stores each cell in
        self.map_buttons as a MapButtonWrapper for compatibility.
        
        Args:
            rows (int): Number of rows for the grid.
            cols (int): Number of columns for the grid.
            on_cell_click (callable): Optional callback when a cell is clicked.
        """
        # First, clear the canvas (if needed)
        self.canvas.delete("all")
        self.map_buttons.clear()

        for row in range(rows):
            for col in range(cols):
                x1 = col * self.cell_size
                y1 = row * self.cell_size
                x2 = x1 + self.cell_size
                y2 = y1 + self.cell_size
                coord = f"{chr(65 + row)}{col + 1}"  # e.g., "A1", "B2", etc.

                # Draw the cell rectangle and its text on the canvas
                rect_id = self.canvas.create_rectangle(
                    x1, y1, x2, y2, fill="gray", outline="white", tags="cell"
                )
                text_id = self.canvas.create_text(
                    (x1 + x2) / 2, (y1 + y2) / 2, text="Empty", fill="white", tags="cell_text"
                )

                # Bind the cell click if provided
                if on_cell_click:
                    self.canvas.tag_bind(rect_id, "<Button-1>", lambda event, c=coord: on_cell_click(c))

                # Store the virtual button using our wrapper
                self.map_buttons[coord] = MapButtonWrapper(rect_id, text_id, self.canvas)

    def create_log_area(self):
        """
        Creates a simple Text widget for logging which is separate from the Canvas.
        """
        self.log_area = tk.Text(self.root, height=5, width=50, state="normal", wrap="word", bg="#222222", fg="white")
        self.log_area.pack(side="bottom", fill="x")

    def update_log(self, message):
        """
        Appends a message to the log area.
        """
        if self.log_area:
            self.log_area.configure(state="normal")
            self.log_area.insert(tk.END, message + "\n")
            self.log_area.see(tk.END)
            self.log_area.configure(state="disabled")

    def config_map_button(self, coord, text=None, bg=None):
        """
        Updates a cell's appearance using the MapButtonWrapper.
        
        Args:
            coord (str): The cell coordinate, e.g., "A1".
            text (str): New text for the cell.
            bg (str): New background color for the cell.
        """
        if coord in self.map_buttons:
            mb = self.map_buttons[coord]
            if text is not None:
                mb.config(text=text)
            if bg is not None:
                mb.config(bg=bg)

    def draw_spinning_3d_cube(self, coord, size=50):
        """
        Draws a spinning cube over the specified grid cell.
        
        Args:
            coord (str): The grid coordinate (e.g., "A1") over which the cube is drawn.
            size (int): The size of the cube (default: 50 pixels).
        """
        if coord not in self.map_buttons:
            return

        # Get the coordinates of the cell from its rectangle
        mb = self.map_buttons[coord]
        rect = mb.rect
        x1, y1, x2, y2 = self.canvas.coords(rect)
        x_center = (x1 + x2) / 2
        y_center = (y1 + y2) / 2

        half_size = size // 2

        # Define the cube's 3D vertices (for a cube centered at origin)
        points = [
            (-half_size, -half_size, -half_size),  # Front-top-left
            ( half_size, -half_size, -half_size),  # Front-top-right
            ( half_size,  half_size, -half_size),  # Front-bottom-right
            (-half_size,  half_size, -half_size),  # Front-bottom-left
            (-half_size, -half_size,  half_size),  # Back-top-left
            ( half_size, -half_size,  half_size),  # Back-top-right
            ( half_size,  half_size,  half_size),  # Back-bottom-right
            (-half_size,  half_size,  half_size)   # Back-bottom-left
        ]

        # Rotate points around the Y-axis (simple rotation for 3D effect)
        rotated_points = []
        angle = self.angle
        for px, py, pz in points:
            cos_a, sin_a = math.cos(angle), math.sin(angle)
            # Rotate: x' = x*cos(angle) - z*sin(angle), z' = x*sin(angle) + z*cos(angle)
            x_rot = px * cos_a - pz * sin_a
            z_rot = px * sin_a + pz * cos_a
            rotated_points.append((x_center + x_rot, y_center + py))

        # Draw edges of the cube on the canvas
        self.canvas.delete("cube")
        edges = [
            (0, 1), (1, 2), (2, 3), (3, 0),  # Front face
            (4, 5), (5, 6), (6, 7), (7, 4),  # Back face
            (0, 4), (1, 5), (2, 6), (3, 7)   # Connecting edges
        ]
        for a, b in edges:
            x_a, y_a = rotated_points[a]
            x_b, y_b = rotated_points[b]
            self.canvas.create_line(x_a, y_a, x_b, y_b, fill="red", width=2, tags="cube")
        
        # Increment the cube's angle for animation and schedule the next frame
        self.angle += 0.1
        self.canvas.after(16, lambda: self.draw_spinning_3d_cube(coord, size))

    def on_canvas_click(self, event):
        """
        Handles canvas click events, determining which cell was clicked and triggering logic.
        """
        x, y = event.x, event.y
        for coord, mb in self.map_buttons.items():
            rect = mb.rect
            x1, y1, x2, y2 = self.canvas.coords(rect)
            if x1 <= x <= x2 and y1 <= y <= y2:
                self.update_log(f"Cell {coord} clicked.")
                break
media_rw
import random

class PlayerManager:
    def __init__(self, map_buttons, terrain_manager, game_ui):
        """
        Initializes the PlayerManager with references to the map buttons,
        terrain manager, and GameUI for rendering.

        Args:
            map_buttons (dict): Dictionary of map cell buttons.
            terrain_manager (TerrainManager): Instance managing map terrain.
            game_ui (GameUI): Instance managing UI interactions.
        """
        self.map_buttons = map_buttons  # Reference to the map buttons
        self.terrain_manager = terrain_manager  # Reference to the terrain manager
        self.game_ui = game_ui  # Reference to the GameUI instance
        self.player_position = None  # The player's current position
        self.player_stats = {"hp": 20, "ammo": 3}  # Player's stats, including health and ammo

    def deploy_player(self, player_unit_name):
        """
        Deploys the player unit on a random empty tile.

        Args:
            player_unit_name (str): The name of the player unit (e.g., "T-64 Tank").

        Returns:
            str: The coordinate of the deployed player unit.

        Raises:
            ValueError: If deployment fails after multiple attempts.
        """
        for _ in range(10):  # Retry up to 10 times for deployment
            self.player_position = random.choice(list(self.map_buttons.keys()))
            if self.terrain_manager.get_terrain(self.player_position) == "Empty":
                self.map_buttons[self.player_position].config(text=player_unit_name, bg="blue")
                # Render spinning 3D cube
                self.game_ui.draw_spinning_3d_cube(self.player_position)
                return self.player_position
        raise ValueError("Failed to deploy player unit after multiple attempts.")

    def move_player(self, target_position, unit_name):
        """
        Moves the player unit to a specified target position.

        Args:
            target_position (str): The coordinate to move the player unit to.
            unit_name (str): The name of the player unit (e.g., "T-64 Tank").

        Returns:
            str: The new position of the player unit.
        """
        if target_position not in self.map_buttons:
            raise ValueError("Invalid target position.")
        
        # Reset the current position to empty
        self.map_buttons[self.player_position].config(text="Empty", bg="lightgray")
        
        # Move the player to the new position
        self.map_buttons[target_position].config(text=unit_name, bg="blue")
        self.player_position = target_position
        
        # Update the spinning cube's position to follow the player
        self.game_ui.draw_spinning_3d_cube(self.player_position)
        return self.player_position

    def heal_player(self, amount):
        """
        Heals the player by a specified amount.

        Args:
            amount (int): The amount of health to restore.
        """
        self.player_stats["hp"] += amount
        if self.player_stats["hp"] > 20:  # Cap at max health
            self.player_stats["hp"] = 20
        self.game_ui.update_log(f"Player healed! Current HP: {self.player_stats['hp']}")

    def use_ammo(self):
        """
        Reduces the player's ammo by 1 when artillery is fired.

        Returns:
            bool: True if ammo was used successfully, False if no ammo is left.
        """
        if self.player_stats["ammo"] > 0:
            self.player_stats["ammo"] -= 1
            self.game_ui.update_log(f"Ammo used! Remaining ammo: {self.player_stats['ammo']}")
            return True
        self.game_ui.update_log("No ammo left!")
        return False

    def reset(self):
        """
        Resets the PlayerManager to its initial state for a new game.
        """
        # Reset player position and stats
        if self.player_position:
            self.map_buttons[self.player_position].config(text="Empty", bg="lightgray")
        self.player_position = None
        self.player_stats = {"hp": 20, "ammo": 3}  # Reset health and ammo
media_rw
import random

class UnitManager:
    def __init__(self, map_buttons, terrain_manager, enemy_count):
        """
        Initializes the UnitManager with references to map buttons, terrain, and enemy count.
        """
        self.map_buttons = map_buttons  # Reference to the map buttons
        self.terrain_manager = terrain_manager  # Reference to the terrain manager
        self.player_position = "A1"  # Initial player position
        self.enemy_positions = []  # List of enemy positions
        self.enemy_count = enemy_count  # Total number of enemies to deploy

    def deploy_player(self, player_unit_name):
        """
        Deploys the player unit on a random empty tile.
        """
        for _ in range(5):  # Retry up to 5 times for deployment
            self.player_position = random.choice(list(self.map_buttons.keys()))
            if self.terrain_manager.get_terrain(self.player_position) == "Empty":
                self.map_buttons[self.player_position].config(text=player_unit_name, bg="blue")
                return self.player_position
        # Raise an exception if deployment fails
        raise ValueError("Failed to deploy player unit. Restart required.")

    def deploy_enemies(self, enemy_unit_name):
        """
        Deploys enemy units on random empty tiles.
        """
        empty_cells = [
            coord for coord, terr in self.terrain_manager.terrain.items()
            if terr == "Empty" and self.map_buttons[coord].cget("text") == "Empty"
        ]
        if len(empty_cells) < self.enemy_count:
            raise ValueError("Not enough empty spaces to deploy enemies.")

        self.enemy_positions = random.sample(empty_cells, self.enemy_count)
        for enemy_position in self.enemy_positions:
            self.map_buttons[enemy_position].config(text=enemy_unit_name, bg="red")
        return self.enemy_positions

    def move_unit(self, current_position, target_position, unit_name):
        """
        Moves a unit from the current position to the target position.
        """
        self.map_buttons[current_position].config(text="Empty", bg="lightgray")
        self.map_buttons[target_position].config(text=unit_name, bg="blue")
        return target_position

    def move_enemy(self, enemy_position, target_position, enemy_name):
        """
        Moves an enemy unit from the current position to the target position.
        """
        self.map_buttons[enemy_position].config(text="Empty", bg="lightgray")
        self.map_buttons[target_position].config(text=enemy_name, bg="red")
        return target_position

    def is_adjacent(self, pos1, pos2):
        """
        Determines whether two positions on the map are adjacent.
        """
        row_diff = abs(ord(pos1[0]) - ord(pos2[0]))
        col_diff = abs(int(pos1[1]) - int(pos2[1]))
        return max(row_diff, col_diff) == 1
media_rw
import random

class TerrainManager:
    def __init__(self, map_buttons):
        """
        Initializes the TerrainManager with a reference to the map buttons.
        """
        self.map_buttons = map_buttons  # Reference to the map buttons
        self.terrain = {}  # Dictionary to store terrain types for each cell

    def generate_terrain(self, enemy_count, extra_empty=5):
        """
        Generates terrain for the map and ensures a minimum number of empty tiles.

        Args:
            enemy_count (int): Number of enemies to deploy (affects empty tiles needed).
            extra_empty (int): Extra empty tiles to ensure playability.

        Returns:
            bool: True if terrain generation is successful, False otherwise.
        """
        retries = 5  # Maximum number of attempts to generate a valid map
        for _ in range(retries):
            self.terrain.clear()
            empty_count = 0

            # Randomly assign terrain types to each cell
            for coord in self.map_buttons.keys():
                terrain_type = random.choice(["Forest", "Mountain", "Water", "Empty"])
                self.terrain[coord] = terrain_type
                if terrain_type == "Empty":
                    empty_count += 1

            # Check if enough empty tiles are available
            if empty_count >= enemy_count + extra_empty:
                self._apply_terrain_to_map()
                return True  # Successful generation

        return False  # Failed to generate a valid map after retries

    def _apply_terrain_to_map(self):
        """
        Applies the generated terrain to the map buttons, updating their appearance.
        """
        for coord, terrain_type in self.terrain.items():
            if coord in self.map_buttons:  # Ensure the cell exists in map_buttons
                if terrain_type == "Forest":
                    self.map_buttons[coord].config(bg="green", text="Forest")
                elif terrain_type == "Mountain":
                    self.map_buttons[coord].config(bg="brown", text="Mountain")
                elif terrain_type == "Water":
                    self.map_buttons[coord].config(bg="blue", text="Water")
                elif terrain_type == "Empty":
                    self.map_buttons[coord].config(bg="lightgray", text="Empty")

    def get_terrain(self, coord):
        """
        Gets the terrain type for a specific coordinate.

        Args:
            coord (str): The map coordinate (e.g., "A1").

        Returns:
            str: The terrain type (e.g., "Forest", "Mountain", "Water", or "Empty").
        """
        return self.terrain.get(coord, "Unknown")

    def reset(self):
        """
        Resets the TerrainManager to its initial state for a new game.
        """
        # Clear current terrain and reset the map buttons to default "Empty" state
        self.terrain.clear()
        for coord, button in self.map_buttons.items():
            button.config(bg="lightgray", text="Empty")
media_rw
import tkinter as tk

class GameApp:
    def __init__(self):
        """
        Wraps the entire game within a single object.
        Initializes the Tkinter root and game session.
        """
        self.root = tk.Tk()
        self.root.title("Turn-Based Tactical Simulation")
        self.tactical_map = None
        self.start_game()

    def start_game(self):
        """
        Starts a new game session by initializing TacticalMap and passing the replay callback.
        """
        from TacticalMap import TacticalMap  # Import here to avoid circular dependency
        if self.tactical_map:
            # Ensure TacticalMap is cleared before starting a new game
            self.tactical_map.reset()
        else:
            self.tactical_map = TacticalMap(self.root, on_replay=self.restart_game)

    def restart_game(self):
        """
        Resets the game session without destroying the entire root window.
        """
        if self.tactical_map:
            self.tactical_map.reset()
        else:
            self.start_game()

    def run(self):
        """
        Runs the Tkinter main loop.
        """
        self.root.mainloop()
