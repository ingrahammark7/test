media_rw
#!/usr/bin/env python3
import sys
import os
import re
import textwrap
import ast
import astunparse  # Install with: pip install astunparse
import subprocess  # To execute the bash command

def split_game_txt(input_file="game.txt"):
    """Splits game.txt into individual Python files based on class definitions."""
    try:
        with open(input_file, "r") as f:
            content = f.read()
        sections = content.split("media_rw")
        class_content_map = {}
        for section in sections:
            section = section.strip()
            if not section:
                continue
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                class_content_map[class_name] = section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as pyfile:
                pyfile.write(content)
            print(f"Created: {class_name}.py")
        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """Rebuilds game.txt by concatenating all .py files in the current directory."""
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as outfile:
            for py_file in py_files:
                with open(py_file, "r") as f:
                    content = f.read()
                    outfile.write("media_rw\n")
                    outfile.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def combine_files(input1, input2, output):
    """
    Combines two Python files into one output file.

    A fake class wrapper ("class Foo:") is added to temp2.txt if necessary
    to ensure proper AST parsing. After merging, the fake class is removed
    entirely from the final result using a bash command.

    Args:
        input1 (str): Path to the first input file (e.g., temp1.txt).
        input2 (str): Path to the second input file (e.g., temp2.txt).
        output (str): Path for the output file (e.g., result.txt).
    """
    if not os.path.exists(input1) or not os.path.exists(input2):
        print(f"Error: One or both input files do not exist.")
        return

    try:
        # Normalize both input files for consistent indentation
        norm1 = normalize_indentation(input1)
        norm2 = normalize_indentation(input2)

        # Add a fake wrapper to temp2.txt if needed
        tree2 = parse_with_fake_wrapper(norm2, input2)
        tree1 = ast.parse(norm1, filename=input1)

        # Merge the trees
        merged_tree = merge_ast(tree1, tree2)

        # Convert the merged AST back to Python code
        merged_code = astunparse.unparse(merged_tree)

        # Write the merged code to the output file
        with open(output, "w") as out:
            out.write(merged_code)

        # Run a bash command to remove any line containing "foo" or "Foo"
        remove_lines_with_foo(output)

        print(f"Successfully combined '{input1}' and '{input2}' into '{output}'.")
    except Exception as e:
        print(f"An error occurred during combination: {e}")

def normalize_indentation(file_path):
    """
    Reads a file and ensures consistent 4-space indentation.

    Args:
        file_path (str): Path to the file to normalize.

    Returns:
        str: The normalized file content as a string.
    """
    try:
        with open(file_path, "r") as f:
            lines = f.readlines()
        # Replace tabs with 4 spaces and remove trailing whitespace.
        norm_lines = [line.replace("\t", "    ").rstrip() for line in lines]
        return "\n".join(norm_lines)
    except Exception as e:
        raise RuntimeError(f"Failed to normalize indentation for {file_path}: {e}")

def parse_with_fake_wrapper(content, filename):
    """
    Ensures the content of the second file is parsable by wrapping it in a fake class
    if necessary.

    Args:
        content (str): The file content as a string.
        filename (str): The file name for reference.

    Returns:
        ast.Module: The parsed AST, with a fake wrapper if applied.
    """
    stripped_content = content.lstrip()
    if stripped_content and not stripped_content.startswith(" "):
        # Add a fake wrapper to ensure proper indentation for parsing
        wrapped_content = "class Foo:\n" + "\n".join("    " + line for line in content.splitlines())
        tree_with_wrapper = ast.parse(wrapped_content, filename=filename)
        print("Applied fake class wrapper to ensure parsing of input2.")
        return tree_with_wrapper
    return ast.parse(content, filename=filename)

def remove_lines_with_foo(file_path):
    """
    Removes any line containing "foo" or "Foo" (case-insensitive) using a bash command.

    Args:
        file_path (str): Path to the file to modify.
    """
    try:
        command = f"sed -i '/[Ff][Oo][Oo]/d' {file_path}"
        subprocess.run(command, shell=True, check=True)
        print("Removed all lines containing 'foo' or 'Foo' from the result file.")
    except Exception as e:
        raise RuntimeError(f"Failed to remove lines containing 'foo' or 'Foo' from {file_path}: {e}")

def merge_ast(tree1, tree2):
    """
    Merges two ASTs by appending elements from tree2 into tree1.

    If tree2 contains function definitions (methods) and tree1 ends with a class,
    those functions are appended to the body of the last class in tree1.

    Args:
        tree1 (ast.Module): The AST of the first file.
        tree2 (ast.Module): The AST of the second file.

    Returns:
        ast.Module: The merged AST.
    """
    if not isinstance(tree1, ast.Module) or not isinstance(tree2, ast.Module):
        raise ValueError("Both ASTs must be ast.Module instances.")

    body1 = tree1.body
    body2 = tree2.body

    # If the last element of tree1 is a class definition, append functions from tree2 to it.
    if body1 and isinstance(body1[-1], ast.ClassDef):
        class_node = body1[-1]
        for node in body2:
            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                class_node.body.append(node)
            else:
                body1.append(node)
    else:
        body1.extend(body2)

    return tree1

def main():
    import argparse
    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from the individual .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Output path for game.txt")

    # Combine command
    combine_parser = subparsers.add_parser("combine", help="Combine two files into one result file.")
    combine_parser.add_argument("--input1", type=str, required=True, help="Path to the first input file (e.g., temp1.txt)")
    combine_parser.add_argument("--input2", type=str, required=True, help="Path to the second input file (e.g., temp2.txt)")
    combine_parser.add_argument("--output", type=str, default="result.txt", help="Output file path (e.g., result.txt)")

    args = parser.parse_args()
    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "combine":
        combine_files(args.input1, args.input2, args.output)
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
media_rw
import math

class BomberHelper:
    def __init__(self, canvas, ui):
        """
        Helper class for Bomber that handles drawing, animation, and component management.

        Args:
            canvas (tk.Canvas): The canvas to draw on.
            ui (GameUI): The UI instance for logging and debugging.
        """
        self.canvas = canvas
        self.ui = ui

    def draw_engine(self, x, y, pivot_x, pivot_y, heading_angle, width=4, length=16):
        """
        Draws an engine as a beveled rectangle at a specified position,
        applying rotation around a pivot point.

        Args:
            x (float): X-coordinate of the engine's center relative to the body.
            y (float): Y-coordinate of the engine's center relative to the body.
            pivot_x (float): X-coordinate of the bomber's center.
            pivot_y (float): Y-coordinate of the bomber's center.
            heading_angle (float): The rotation angle of the bomber in degrees.
            width (float): The width (diameter) of the engine.
            length (float): The length of the engine.

        Returns:
            int: Canvas object ID of the engine.
        """
        half_width = width / 2
        half_length = length / 2
        points = [
            (x - half_length, y - half_width),  # Top-left
            (x + half_length, y - half_width),  # Top-right
            (x + half_length, y + half_width),  # Bottom-right
            (x - half_length, y + half_width)   # Bottom-left
        ]

        # Rotate each point around the pivot point
        rotated_points = [
            self._rotate_point_relative(px, py, pivot_x, pivot_y, heading_angle)
            for px, py in points
        ]

        # Flatten the list of rotated points for the canvas create_polygon method
        flat_points = [coord for point in rotated_points for coord in point]

        # Draw the beveled rectangle as a polygon
        return self.canvas.create_polygon(flat_points, fill="darkgray", outline="black")

    def draw_wing(self, x_root, y_root, wing_span, pivot_x, pivot_y, heading_angle):
        """
        Draws a wing attached to a specified root position, extending symmetrically.

        Args:
            x_root (float): X-coordinate of the wing's root relative to the body.
            y_root (float): Y-coordinate of the wing's root relative to the body.
            wing_span (float): Horizontal span of the wing (extends on both sides).
            pivot_x (float): Bomber's center x-coordinate.
            pivot_y (float): Bomber's center y-coordinate.
            heading_angle (float): The rotation angle of the bomber in degrees.

        Returns:
            int: Canvas object ID of the wing.
        """
        points = [
            (x_root - wing_span / 2, y_root),  # Left tip
            (x_root + wing_span / 2, y_root),  # Right tip
            (x_root, y_root + 5)               # Trailing edge (swept back)
        ]

        # Rotate each point around the pivot point
        rotated_points = [
            self._rotate_point_relative(px, py, pivot_x, pivot_y, heading_angle)
            for px, py in points
        ]

        # Flatten the list of rotated points for the canvas create_polygon method
        flat_points = [coord for point in rotated_points for coord in point]

        # Draw the wing as a polygon
        return self.canvas.create_polygon(flat_points, fill="darkgray", outline="black")

    def _rotate_point_relative(self, x, y, pivot_x, pivot_y, angle):
        """
        Rotates a point (x, y) around a pivot point (pivot_x, pivot_y) by the specified angle.

        Args:
            x (float): X-coordinate of the point.
            y (float): Y-coordinate of the point.
            pivot_x (float): X-coordinate of the pivot.
            pivot_y (float): Y-coordinate of the pivot.
            angle (float): Rotation angle in degrees.

        Returns:
            tuple: The new (x, y) coordinates after rotation.
        """
        radians = math.radians(angle)
        # Translate the point to the origin using the pivot.
        translated_x = x - pivot_x
        translated_y = y - pivot_y
        # Rotate the translated point.
        rotated_x = translated_x * math.cos(radians) - translated_y * math.sin(radians)
        rotated_y = translated_x * math.sin(radians) + translated_y * math.cos(radians)
        # Translate the point back.
        new_x = rotated_x + pivot_x
        new_y = rotated_y + pivot_y
        return new_x, new_y

    def _animate_debris(self, debris, dx, dy, steps=20):
        """
        Animates debris to scatter along given vectors.

        Args:
            debris (int): The canvas object ID of the debris.
            dx (float): The x-velocity.
            dy (float): The y-velocity.
            steps (int): Number of animation steps.
        """
        def step_animation(step=0):
            if step < steps:
                self.canvas.move(debris, dx / steps, dy / steps)
                self.canvas.after(50, step_animation, step + 1)
            else:
                self.canvas.delete(debris)
        step_animation()
media_rw
import math
import random

class Tank:
    def __init__(self, canvas, x, y, color="green", ui=None):
        """
        Initializes the Tank object and draws it on the canvas.

        Args:
            canvas (tk.Canvas): The canvas to draw the tank on.
            x (float): The x-coordinate of the tank's center.
            y (float): The y-coordinate of the tank's center.
            color (str): The primary color of the tank (default: green).
            ui (GameUI, optional): An instance of GameUI for logging.
        """
        self.canvas = canvas
        self.x = x
        self.y = y
        self.color = color
        self.ui = ui  # Optional: Reference to GameUI for logging

        # Default angles for hull and turret in degrees
        self.hull_angle = 0
        self.turret_angle = 0

        # Components of the tank
        self.hull = None
        self.turret = None
        self.gun = None

        # Health for destruction logic
        self.health = 10  # Default health for tank

        # Draw the initial tank
        self.draw()

    def draw(self):
        """
        Draws the tank components (hull, turret, gun) on the canvas.
        This method updates their positions and directions.
        """
        self._clear_previous_drawings()

        # Hull dimensions
        hull_width, hull_height = 30, 20
        turret_radius = 8
        gun_length = 20

        # Calculate hull rotation (trigonometric rotation)
        hull_dx = hull_width / 2 * math.cos(math.radians(self.hull_angle))
        hull_dy = hull_width / 2 * math.sin(math.radians(self.hull_angle))
        offset_x = hull_height / 2 * math.sin(math.radians(self.hull_angle))
        offset_y = hull_height / 2 * math.cos(math.radians(self.hull_angle))

        # Define corners of the rotated hull rectangle
        corners = [
            (self.x - hull_dx - offset_x, self.y - hull_dy + offset_y),
            (self.x + hull_dx - offset_x, self.y + hull_dy + offset_y),
            (self.x + hull_dx + offset_x, self.y + hull_dy - offset_y),
            (self.x - hull_dx + offset_x, self.y - hull_dy - offset_y),
        ]

        self.hull = self.canvas.create_polygon(corners, fill=self.color)

        # Turret center remains at the hull's center
        self.turret = self.canvas.create_oval(
            self.x - turret_radius, self.y - turret_radius,
            self.x + turret_radius, self.y + turret_radius,
            fill="darkgreen"
        )

        # Gun end point based on turret_angle
        gun_dx = gun_length * math.cos(math.radians(self.turret_angle))
        gun_dy = gun_length * math.sin(math.radians(self.turret_angle))
        self.gun = self.canvas.create_line(
            self.x, self.y,
            self.x + gun_dx, self.y + gun_dy,
            fill="black", width=3
        )

    def _clear_previous_drawings(self):
        """
        Clears the previous drawings of the tank components before redrawing.
        """
        if self.hull:
            self.canvas.delete(self.hull)
        if self.turret:
            self.canvas.delete(self.turret)
        if self.gun:
            self.canvas.delete(self.gun)

    def take_damage(self, damage):
        """
        Reduces the tank's health by a specified amount and triggers destruction if health drops to zero.

        Args:
            damage (int): The amount of damage to inflict.
        """
        self.health -= damage
        if self.health <= 0:
            self.health = 0
            self.ui.update_log("[LOG] Tank destroyed!")
            self.turret_toss()

    def turret_toss(self, debris_count=6, range_min=15, range_max=30):
        """
        Simulates the turret toss with randomized debris scattering.

        Args:
            debris_count (int): Number of debris pieces.
            range_min (int): Minimum range for debris to scatter.
            range_max (int): Maximum range for debris to scatter.
        """
        self.ui.update_log(f"[LOG] Turret toss initiated at ({self.x}, {self.y})")

        # Toss the turret itself
        turret_dx = random.uniform(-range_max, range_max)
        turret_dy = random.uniform(-range_max, range_max)
        turret_piece = self.canvas.create_oval(
            self.x - 5, self.y - 5,
            self.x + 5, self.y + 5,
            fill="darkgreen"
        )
        self._animate_debris(turret_piece, turret_dx, turret_dy)

        # Scatter debris pieces
        for _ in range(debris_count):
            debris_dx = random.uniform(-range_max, range_max)
            debris_dy = random.uniform(-range_max, range_max)
            debris_piece = self.canvas.create_oval(
                self.x - 3, self.y - 3,
                self.x + 3, self.y + 3,
                fill="gray"
            )
            self._animate_debris(debris_piece, debris_dx, debris_dy)

    def _animate_debris(self, debris, dx, dy, steps=20):
        """
        Animates a piece of debris along a given trajectory.

        Args:
            debris (int): The canvas object ID for the debris.
            dx (float): The x-velocity of the debris.
            dy (float): The y-velocity of the debris.
            steps (int): Number of animation steps.
        """
        def step_animation(step=0):
            if step < steps:
                self.canvas.move(debris, dx / steps, dy / steps)
                self.canvas.after(50, step_animation, step + 1)
            else:
                self.canvas.delete(debris)  # Remove debris when animation completes

        step_animation()
media_rw
import tkinter as tk
import random
from GameUI import GameUI
from TerrainManager import TerrainManager
from PlayerManager import PlayerManager
from EnemyManager import EnemyManager
from CombatManager import CombatManager
from bomber import Bomber  # Import the Bomber class
import math

class TacticalMap:
    def __init__(self, root, on_replay=None):
        """
        Initializes the TacticalMap, setting up game managers and the UI.

        Args:
            root (tk.Tk): The root window for the game.
            on_replay (callable): Optional callback function to restart the game.
        """
        self.root = root
        self.ui = GameUI(root)
        self.terrain_manager = TerrainManager(self.ui.grid_elements, self.ui.canvas)
        self.player_manager = PlayerManager(self.ui.grid_elements, self.terrain_manager, self.ui)
        self.enemy_manager = EnemyManager(
            self.ui.grid_elements, self.terrain_manager, enemy_count=5, ui=self.ui
        )
        self.combat_manager = CombatManager(
            self.ui.grid_elements,
            player_stats={"name": "T-64 Tank", "hp": 20, "ammo": 5},
            enemy_stats={"name": "Enemy Unit", "hp": 10},
            ui=self.ui,
            player_manager=self.player_manager,
        )
        self.bomber = None  # Bomber instance for debugging purposes
        self.on_replay = on_replay
        self.turn = "Player"
        self.grid_rows = 7
        self.grid_cols = 7
        self.determine_grid_dimensions()
        self.initialize_game()

    def determine_grid_dimensions(self):
        """
        Dynamically sets grid dimensions based on screen size.
        """
        screen_width = self.ui.root.winfo_screenwidth()
        screen_height = self.ui.root.winfo_screenheight()

        usable_width = int(screen_width * 0.95)
        usable_height = int(screen_height * 0.90)

        tile_size = 50
        self.grid_cols = max(1, usable_width // tile_size)
        self.grid_rows = max(1, usable_height // tile_size)

        self.ui.canvas.config(width=usable_width, height=usable_height)

    def initialize_game(self):
        """
        Sets up the game grid, generates terrain, deploys units, and renders the bomber. Retries if necessary.
        """
        self.ui.create_map(rows=self.grid_rows, cols=self.grid_cols, cell_click_callback=self.on_cell_click)

        for _ in range(5):
            if self.terrain_manager.generate_terrain(enemy_count=5):
                try:
                    player_pos = self.player_manager.deploy_player()
                    self.enemy_manager.deploy_enemies()
                    self.ui.update_log(f"Game initialized. Player spawned at: {player_pos}")

                    # Render the bomber for debugging purposes
                    self.deploy_bomber_debug(x=200, y=150)  # Example coordinates on the canvas
                    return
                except ValueError:
                    self.ui.update_log("Deployment failed. Retrying...")
        self.ui.update_log("Failed to initialize game.")
        self.end_game(victory=False)

    def deploy_bomber_debug(self, x, y):
        """
        Renders the Myasischev M4 Bison bomber on the map for debugging purposes.

        Args:
            x (float): The x-coordinate on the canvas.
            y (float): The y-coordinate on the canvas.
        """
        self.bomber = Bomber(self.ui.canvas, x=x, y=y, ui=self.ui)
        self.ui.update_log("[DEBUG] Bomber rendered on the map for testing.")

        # Start the spin test for the bomber
        self.bomber.spin_test()

        # Schedule the bomber to self-destruct after 10 seconds
        self.ui.canvas.after(10000, self.trigger_bomber_explosion)

    def trigger_bomber_explosion(self):
        """
        Handles the bomber's self-destruction by triggering an explosion.
        """
        if self.bomber:
            self.ui.update_log("[DEBUG] Bomber self-destruction triggered!")
            self.combat_manager.trigger_explosion((self.bomber.x, self.bomber.y))
            self.bomber.trigger_explosion()  # Call the bomber's explosion method
            self.bomber = None  # Remove bomber reference after explosion

    def on_cell_click(self, coord):
        """
        Handles a player's action when a cell is clicked.

        Args:
            coord (str): The coordinate of the clicked cell.
        """
        if self.turn == "Player":
            # Update hull orientation immediately
            player_position = self.player_manager.player_position
            dx = int(coord[1:]) - int(player_position[1:])
            dy = ord(coord[0]) - ord(player_position[0])

            if dx != 0 or dy != 0:
                self.player_manager.hull_angle = math.degrees(math.atan2(dy, dx))
                self.ui.draw_tank(player_position, self.player_manager.hull_angle, self.player_manager.turret_angle)
                self.ui.update_log(
                    f"[DEBUG] Hull angle updated to {self.player_manager.hull_angle:.2f}° on click."
                )

            self.handle_player_action(coord)

    def handle_player_action(self, coord):
        """
        Processes the player's action: move, attack, or use artillery.

        Args:
            coord (str): The target cell coordinate.
        """
        player_position = self.player_manager.player_position
        distance_row = abs(ord(coord[0]) - ord(player_position[0]))
        distance_col = abs(int(coord[1:]) - int(player_position[1:]))

        # Handle artillery attack
        if max(distance_row, distance_col) > 1:
            if self.player_manager.player_stats["ammo"] > 0:
                results = self.combat_manager.artillery_attack(
                    coord, self.enemy_manager.enemy_positions
                )
                self.player_manager.player_stats["ammo"] -= 1
                for result in results:
                    self.ui.update_log(result)
                self.ui.update_log(
                    f"Artillery fired. Ammo left: {self.player_manager.player_stats['ammo']}"
                )
                self.end_turn()
            else:
                self.ui.update_log("No ammo left!")
            return

        # Handle adjacent move or attack
        if max(distance_row, distance_col) == 1:
            terrain = self.terrain_manager.get_terrain(coord)
            if coord in self.enemy_manager.enemy_positions:
                result = self.combat_manager.player_attack(coord, self.enemy_manager.enemy_positions)
                self.ui.update_log(result)
                if not self.enemy_manager.enemy_positions:
                    self.end_game(victory=True)
            elif terrain in ["Empty", "Forest"]:
                self.player_manager.move_player_smoothly(coord)
                self.end_turn()
            else:
                self.ui.update_log("Cannot move to that terrain!")
        else:
            self.ui.update_log("Invalid move. Choose an adjacent tile.")

    def enemy_action(self):
        """
        Executes the enemies' turn, including movement and attacks.
        """
        self.ui.update_log("Enemies are taking their turn...")

        for enemy_pos in list(self.enemy_manager.enemy_positions.keys()):
            if self.enemy_manager.is_adjacent(enemy_pos, self.player_manager.player_position):
                result = self.combat_manager.enemy_attack(self.player_manager.player_position)
                self.ui.update_log(result)
                if "Player is defeated!" in result:
                    self.player_manager.handle_destruction()  # Trigger turret toss before ending the game
                    self.end_game(victory=False)
                    return
            else:
                new_pos = self.enemy_manager.move_toward_player(
                    enemy_pos, self.player_manager.player_position
                )
                if new_pos != enemy_pos:
                    self.enemy_manager.update_enemy_position(enemy_pos, new_pos)

        if not self.enemy_manager.enemy_positions:
            self.end_game(victory=True)
        else:
            self.end_turn()

    def end_turn(self):
        """
        Alternates turns between the player and the enemies.
        """
        if self.turn == "Player":
            self.turn = "Enemy"
            self.enemy_action()
        else:
            self.turn = "Player"
            self.ui.update_log("Your turn!")

    def end_game(self, victory):
        """
        Concludes the game with a victory or defeat message.
        """
        message = "You Win!" if victory else "Game Over!"
        self.ui.update_log(message)
        restart_command = self.on_replay if self.on_replay is not None else self.reset
        self.ui.display_game_over_overlay(message, restart_command=restart_command)

    def reset(self):
        """
        Resets the TacticalMap to its initial state for a new game.
        """
        self.ui.reset()
        self.terrain_manager.reset()
        self.player_manager.reset()
        self.enemy_manager.reset()
        self.combat_manager = CombatManager(
            self.ui.grid_elements,
            player_stats={"name": "T-64 Tank", "hp": 20, "ammo": 5},
            enemy_stats={"name": "Enemy Unit", "hp": 10},
            ui=self.ui,
            player_manager=self.player_manager,
        )
        self.turn = "Player"
        self.initialize_game()

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Turn-Based Tactical Simulation")
    game = TacticalMap(root)
    root.mainloop()
media_rw
import random

class CombatManager:
    def __init__(self, grid_elements, player_stats, enemy_stats, ui, player_manager):
        """
        Initializes the CombatManager with references to the grid elements,
        the player's statistics, the enemy's statistics, the GameUI, and the PlayerManager.

        Args:
            grid_elements (dict): Dictionary of canvas rectangles for the grid.
            player_stats (dict): Dictionary containing player stats (e.g., {"hp": 20, "ammo": 5}).
            enemy_stats (dict): Dictionary containing enemy stats (e.g., {"hp": 10}).
            ui (GameUI): Instance of GameUI for rendering on the canvas.
            player_manager (PlayerManager): Instance of PlayerManager for managing the player.
        """
        self.grid_elements = grid_elements
        self.player_stats = player_stats
        self.enemy_stats = enemy_stats
        self.ui = ui  # Reference to the GameUI
        self.player_manager = player_manager  # Reference to the PlayerManager for turret updates

    def player_attack(self, target_coord, enemy_positions):
        """
        Handles the player's attack on an enemy unit and aims the turret at the target.

        Args:
            target_coord (str): The coordinate of the enemy being attacked.
            enemy_positions (dict): A dictionary mapping enemy positions to their HP.

        Returns:
            str: A message describing the outcome of the attack.
        """
        # Aim the turret at the target coordinate
        self.player_manager.aim_turret(target_coord)

        if target_coord in enemy_positions:
            enemy_positions[target_coord] -= 5  # Damage the enemy by 5 points
            if enemy_positions[target_coord] <= 0:
                del enemy_positions[target_coord]  # Remove defeated enemy
                self.ui.update_cell(target_coord, "Empty", "lightgray")  # Clear cell
                return f"Enemy at {target_coord} is defeated!"
            else:
                return f"Enemy at {target_coord} HP reduced to {enemy_positions[target_coord]}."
        return "No enemy to attack at the selected position."

    def artillery_attack(self, target_coord, enemy_positions):
        """
        Handles artillery attack, which damages the target coordinate and adjacent tiles.
        Aims the turret at the primary target coordinate.

        Args:
            target_coord (str): The main target coordinate for the artillery attack.
            enemy_positions (dict): A dictionary mapping enemy positions to their HP.

        Returns:
            list: A list of messages describing the outcomes at each affected coordinate.
        """
        # Aim the turret at the primary target coordinate
        self.player_manager.aim_turret(target_coord)

        results = []
        row = ord(target_coord[0])
        col = int(target_coord[1:])

        # Generate a list of affected coordinates (target + adjacent)
        affected_coords = [
            target_coord,
            f"{chr(row - 1)}{col}",
            f"{chr(row + 1)}{col}",
            f"{chr(row)}{col - 1}",
            f"{chr(row)}{col + 1}"
        ]

        self.ui.update_log(f"[DEBUG] Artillery targeted at {target_coord}. Affected coordinates: {affected_coords}")

        for coord in affected_coords:
            if coord in enemy_positions:
                enemy_positions[coord] -= 10  # Artillery deals 10 damage
                if enemy_positions[coord] <= 0:
                    del enemy_positions[coord]
                    self.ui.update_cell(coord, "Empty", "lightgray")
                    results.append(f"Enemy at {coord} destroyed by artillery.")
                else:
                    results.append(f"Enemy at {coord} hit by artillery. HP now {enemy_positions[coord]}.")
            elif coord in self.grid_elements:
                results.append(f"Artillery hit {coord}, but no enemies present.")

        return results

    def enemy_attack(self, player_position):
        """
        Handles the enemy's attack on the player.

        Args:
            player_position (str): The current position of the player.

        Returns:
            str: A message describing the result of the enemy's attack.
        """
        self.player_stats["hp"] -= 5  # Enemy deals a fixed 5 damage
        self.ui.update_log(f"[LOG] Enemy attacked! Player HP reduced to {self.player_stats['hp']}.")
        
        if self.player_stats["hp"] <= 0:
            self.ui.update_log("[DEBUG] Player HP has dropped to 0 or below. Triggering destruction.")
            # Trigger the player's destruction sequence
            self.player_manager.handle_destruction()
            return "Player is defeated!"
        else:
            return f"Player HP reduced to {self.player_stats['hp']}."

    def trigger_explosion(self, position, debris_count=8):
        """
        Creates an explosion effect with debris at the specified position.

        Args:
            position (tuple): (x, y) coordinates for the explosion center.
            debris_count (int): Number of debris pieces to scatter.
        """
        x, y = position
        self.ui.update_log(f"[DEBUG] Explosion triggered at ({x}, {y}).")

        for _ in range(debris_count):
            dx = random.uniform(-20, 20)
            dy = random.uniform(-20, 20)
            debris_piece = self.ui.canvas.create_oval(
                x - 5, y - 5, x + 5, y + 5,
                fill="orange"
            )
            self._animate_debris(debris_piece, dx, dy)

    def _animate_debris(self, debris, dx, dy, steps=20):
        """
        Animates a piece of debris along a trajectory.

        Args:
            debris (int): The canvas object ID of the debris.
            dx (float): x-velocity.
            dy (float): y-velocity.
            steps (int): Number of animation steps.
        """
        def step_animation(step=0):
            if step < steps:
                self.ui.canvas.move(debris, dx / steps, dy / steps)
                self.ui.canvas.after(50, step_animation, step + 1)
            else:
                self.ui.canvas.delete(debris)
        step_animation()

    def is_adjacent(self, pos1, pos2):
        """
        Determines if two grid positions are adjacent (including diagonally).

        Args:
            pos1 (str): The first grid position (e.g., "A1").
            pos2 (str): The second grid position (e.g., "B2").

        Returns:
            bool: True if the two positions share a side or corner, False otherwise.
        """
        row_diff = abs(ord(pos1[0]) - ord(pos2[0]))
        col_diff = abs(int(pos1[1:]) - int(pos2[1:]))
        return max(row_diff, col_diff) == 1

    def reset(self, player_stats=None, enemy_stats=None):
        """
        Resets the CombatManager to its initial state for a new game.

        Args:
            player_stats (dict, optional): Updated stats for the player.
            enemy_stats (dict, optional): Updated stats for the enemies.
        """
        self.player_stats = player_stats if player_stats else {"hp": 20, "ammo": 5}
        self.enemy_stats = enemy_stats if enemy_stats else {"hp": 10}
media_rw
import math
import random
from tank import Tank
from bomberhelper2 import BomberHelper2  # Handles drawing of engines, wings, turrets, and guns.
from bomberhelper3 import BomberHelper3  # Handles fuselage calculations and general actions.

class Bomber(Tank):
    def __init__(self, canvas, x=None, y=None, color="gray", ui=None):
        """
        Initializes the Bomber object with components and configuration.

        Args:
            canvas (tk.Canvas): The canvas to draw on.
            x (float): X-coordinate of the bomber's center. Defaults to canvas center.
            y (float): Y-coordinate of the bomber's center. Defaults to canvas center.
            color (str): Bomber color.
            ui (GameUI, optional): Instance for logging/debugging.
        """
        canvas_width = int(canvas.cget("width"))
        canvas_height = int(canvas.cget("height"))
        x = x if x is not None else canvas_width / 2
        y = y if y is not None else canvas_height / 2

        # Initialize turrets with firing ranges.
        self.turrets = [
            {"angle_range": (0, 120), "angle": 0, "id": None, "gun_id": None},
            {"angle_range": (150, 330), "angle": 180, "id": None, "gun_id": None}
        ]

        # Instantiate helper classes.
        self.helper = BomberHelper2(canvas, ui)
        self.actions = BomberHelper3(canvas, ui)

        self.body = None
        self.wings = []
        self.engines = []
        self.heading_angle = 0

        super().__init__(canvas, x, y, color, ui)
        self.x = x
        self.y = y

        if ui:
            ui.update_log(f"[DEBUG] Bomber initialized at ({self.x}, {self.y}).")
            for i, turret in enumerate(self.turrets):
                ui.update_log(f"[DEBUG] Turret {i} init: Range={turret['angle_range']}, Angle={turret['angle']}, ID={turret['id']}")

    def draw(self):
        """
        Draws the bomber's components.
        """
        self.actions.clear_previous_drawings(self)
        if self.ui:
            self.ui.update_log(f"[DEBUG] Drawing bomber at ({self.x}, {self.y}) with heading {self.heading_angle}°.")

        # Draw fuselage.
        fuselage_points = self._calculate_fuselage_points(120, 10)
        self.body = self.canvas.create_polygon(fuselage_points, fill=self.color, outline="black")
        if self.ui:
            self.ui.update_log(f"[DEBUG] Fuselage drawn with points: {fuselage_points}")

        # Draw wings.
        self.wings = [
            self.helper.draw_wing(0, 13, 50, self.x, self.y, self.heading_angle),
            self.helper.draw_wing(0, -13, 50, self.x, self.y, self.heading_angle)
        ]

        # Draw engines (16x4).
        self.engines = [
            self.helper.draw_engine(self.x, self.y + 7, self.x, self.y, self.heading_angle, length=16, width=4),
            self.helper.draw_engine(self.x, self.y + 11, self.x, self.y, self.heading_angle, length=16, width=4),
            self.helper.draw_engine(self.x, self.y - 7, self.x, self.y, self.heading_angle, length=16, width=4),
            self.helper.draw_engine(self.x, self.y - 11, self.x, self.y, self.heading_angle, length=16, width=4)
        ]

        # Draw turrets and their guns.
        turret_positions = [(self.x + 30, self.y), (self.x - 30, self.y)]
        for i, turret in enumerate(self.turrets):
            rotated_pos = self.helper.rotate_point(
                turret_positions[i][0], turret_positions[i][1],
                self.x, self.y, self.heading_angle
            )
            turret["id"] = self.helper.draw_turret(rotated_pos[0], rotated_pos[1])
            turret["gun_id"] = self.helper.draw_gun(
                rotated_pos[0], rotated_pos[1],
                self.heading_angle + turret["angle"]
            )
            if self.ui:
                self.ui.update_log(f"[DEBUG] Turret {i} drawn at {rotated_pos} with range {turret['angle_range']}")

        if self.ui:
            self.ui.update_log(f"[DEBUG] Bomber drawn at ({self.x}, {self.y}) with heading {self.heading_angle}°.")

    def _calculate_fuselage_points(self, length, height):
        """
        Calculates the points of the fuselage polygon, tapering at the front and back.

        Args:
            length (float): Length of the fuselage.
            height (float): Height of the fuselage.

        Returns:
            list: A list of rotated (x, y) tuples for the fuselage.
        """
        taper = length * 0.25
        points = [
            (self.x - length / 2 + taper, self.y - height / 2),  # Front-left
            (self.x + length / 2 - taper, self.y - height / 2),  # Front-right
            (self.x + length / 2, self.y),                      # Nose
            (self.x + length / 2 - taper, self.y + height / 2),  # Back-right
            (self.x - length / 2 + taper, self.y + height / 2),  # Back-left
            (self.x - length / 2, self.y)                       # Tail
        ]
        rotated_points = [self.helper._rotate_point_relative(
            x, y, self.x, self.y, self.heading_angle) for x, y in points]
        if self.ui:
            self.ui.update_log(f"[DEBUG] Fuselage points: {rotated_points}")
        return rotated_points

    def rotate_to_heading(self, heading_angle):
        """
        Rotates the bomber to the specified heading and redraws it.

        Args:
            heading_angle (float): The new heading angle in degrees.
        """
        self.heading_angle = heading_angle % 360
        if self.ui:
            self.ui.update_log(f"[DEBUG] Bomber rotated to {self.heading_angle:.2f}° at ({self.x}, {self.y}).")
        self.draw()

    def spin_test(self):
        """
        Performs a spin test of the bomber, rotating it by increments and firing turrets.
        """
        self.actions.spin_test(self)

    def fire_turret(self, turret):
        """
        Fires the specified turret.
        """
        self.actions.fire_turret(self, turret)

    def trigger_explosion(self):
        """
        Triggers the bomber's explosion and clears its components.
        """
        self.actions.trigger_explosion(self)
media_rw
import random

class EnemyManager:
    def __init__(self, grid_elements, terrain_manager, enemy_count, ui):
        """
        Initializes the EnemyManager with references to the grid elements, terrain manager,
        the number of enemy units, and the GameUI instance.

        Args:
            grid_elements (dict): Dictionary of canvas rectangles for the grid.
            terrain_manager (TerrainManager): Instance of TerrainManager for managing terrains.
            enemy_count (int): Number of enemy units to deploy.
            ui (GameUI): Instance of GameUI for rendering on the canvas.
        """
        self.grid_elements = grid_elements  # Reference to canvas elements for the grid
        self.terrain_manager = terrain_manager  # Reference to terrain manager
        self.enemy_positions = {}  # Dictionary to track enemy positions and their HP
        self.enemy_count = enemy_count  # Number of enemy units
        self.ui = ui  # Reference to the GameUI

    def deploy_enemies(self):
        """
        Deploys enemy units on random empty tiles and renders them on the canvas.

        Returns:
            list: A list of coordinates where the enemies are deployed.

        Raises:
            ValueError: If there are not enough empty spaces for deployment.
        """
        empty_cells = [
            coord for coord, terr in self.terrain_manager.terrain.items()
            if terr == "Empty" and coord not in self.enemy_positions
        ]
        if len(empty_cells) < self.enemy_count:
            raise ValueError("Not enough empty spaces to deploy enemies.")

        for coord in random.sample(empty_cells, self.enemy_count):
            self.enemy_positions[coord] = 10  # Assign 10 HP to each enemy
            self.ui.update_cell(coord, "Enemy", "red")  # Render the enemy in red
        return list(self.enemy_positions.keys())

    def move_toward_player(self, enemy_position, player_position):
        """
        Moves an enemy unit toward the player. Handles terrain crossing probabilities.

        Args:
            enemy_position (str): The current position of the enemy unit.
            player_position (str): The current position of the player unit.

        Returns:
            str: The new position of the enemy unit.
        """
        enemy_row, enemy_col = ord(enemy_position[0]), int(enemy_position[1:])
        player_row, player_col = ord(player_position[0]), int(player_position[1:])

        dr = player_row - enemy_row
        dc = player_col - enemy_col

        # Determine direction of movement
        if abs(dr) > abs(dc):
            new_pos = f"{chr(enemy_row + (1 if dr > 0 else -1))}{enemy_col}"
        else:
            new_pos = f"{chr(enemy_row)}{enemy_col + (1 if dc > 0 else -1)}"

        # Validate and attempt the move
        if new_pos in self.grid_elements and enemy_position in self.enemy_positions:
            terrain = self.terrain_manager.get_terrain(new_pos)
            if terrain == "Water":
                if random.random() < 0.5:  # 50% chance to cross
                    self.update_enemy_position(enemy_position, new_pos)
                    return new_pos
                else:
                    return enemy_position
            elif terrain == "Mountain":
                if random.random() < 0.3:  # 30% chance to cross
                    self.update_enemy_position(enemy_position, new_pos)
                    return new_pos
                else:
                    return enemy_position
            elif terrain in ["Empty", "Forest"]:
                self.update_enemy_position(enemy_position, new_pos)
                return new_pos

        # Stay in place if move is invalid
        return enemy_position

    def update_enemy_position(self, old_position, new_position):
        """
        Updates the enemy's position on the canvas.

        Args:
            old_position (str): The previous position of the enemy.
            new_position (str): The new position of the enemy.
        """
        if old_position not in self.enemy_positions:
            print(f"[DEBUG] Invalid old_position: {old_position}. Cannot move enemy.")
            return
        if new_position in self.enemy_positions:
            print(f"[DEBUG] Collision detected! {new_position} is already occupied.")
            return

        self.ui.update_cell(old_position, "Empty", "lightgray")
        self.ui.update_cell(new_position, "Enemy", "red")
        self.enemy_positions[new_position] = self.enemy_positions.pop(old_position)

    def take_damage(self, coord, damage=5):
        """
        Reduces an enemy unit's HP at the specified coordinate and handles its destruction.

        Args:
            coord (str): The coordinate of the enemy unit.
            damage (int): The amount of damage to inflict.
        """
        if coord in self.enemy_positions:
            self.enemy_positions[coord] -= damage
            if self.enemy_positions[coord] <= 0:
                self.handle_destruction(coord)
            else:
                self.ui.update_log(f"[LOG] Enemy at {coord} took {damage} damage. HP: {self.enemy_positions[coord]}")
        else:
            self.ui.update_log(f"[DEBUG] No enemy at {coord} to take damage.")

    def handle_destruction(self, coord):
        """
        Handles the destruction of an enemy unit, including triggering a turret toss animation and removal.

        Args:
            coord (str): The coordinate of the enemy unit being destroyed.
        """
        if coord in self.enemy_positions:
            self.ui.update_log(f"[LOG] Enemy at {coord} destroyed!")
            
            # Trigger turret toss animation at the enemy's position
            rect_id = self.grid_elements.get(coord)
            if rect_id:
                x1, y1, x2, y2 = self.ui.canvas.coords(rect_id)
                center_x, center_y = (x1 + x2) / 2, (y1 + y2) / 2
                self.ui.update_log(f"[DEBUG] Enemy turret toss animation started at ({center_x}, {center_y}).")
                self.ui.turret_toss(center_x, center_y, debris_count=6, range_min=15, range_max=30)
                
            # Remove the enemy and clear the cell
            del self.enemy_positions[coord]
            self.ui.update_cell(coord, "Empty", "lightgray")

    def trigger_explosion(self, coord, debris_count=4):
        """
        Creates an explosion effect with debris at the specified coordinate.

        Args:
            coord (str): The coordinate of the explosion.
            debris_count (int): Number of debris pieces to scatter.
        """
        rect_id = self.grid_elements.get(coord)
        if rect_id:
            x1, y1, x2, y2 = self.ui.canvas.coords(rect_id)
            center_x, center_y = (x1 + x2) / 2, (y1 + y2) / 2
            for _ in range(debris_count):
                dx = random.uniform(-15, 15)
                dy = random.uniform(-15, 15)
                debris_piece = self.ui.canvas.create_oval(
                    center_x - 3, center_y - 3,
                    center_x + 3, center_y + 3,
                    fill="orange"
                )
                self.ui.canvas.after(50, self._animate_debris, debris_piece, dx, dy)

    def _animate_debris(self, debris, dx, dy, steps=20):
        """
        Animates a debris piece along a given trajectory.

        Args:
            debris (int): The canvas object ID for the debris.
            dx (float): The x-velocity of the debris.
            dy (float): The y-velocity of the debris.
            steps (int): Number of animation steps.
        """
        def step_animation(step=0):
            if step < steps:
                self.ui.canvas.move(debris, dx / steps, dy / steps)
                self.ui.canvas.after(50, step_animation, step + 1)
            else:
                self.ui.canvas.delete(debris)
        step_animation()

    def is_adjacent(self, pos1, pos2):
        """
        Checks if two positions are adjacent on the grid.

        Args:
            pos1 (str): The first position (e.g., "A1").
            pos2 (str): The second position (e.g., "B2").

        Returns:
            bool: True if the positions are adjacent, False otherwise.
        """
        row_diff = abs(ord(pos1[0]) - ord(pos2[0]))
        col_diff = abs(int(pos1[1:]) - int(pos2[1:]))
        return max(row_diff, col_diff) == 1

    def reset(self):
        """
        Resets the EnemyManager to its initial state for a new game.
        """
        for coord in list(self.enemy_positions.keys()):
            self.ui.update_cell(coord, "Empty", "lightgray")
        self.enemy_positions.clear()
media_rw
import tkinter as tk
from tkinter import ttk
import math
import random

class GameUI:
    def __init__(self, root):
        """
        Initializes the GameUI with a scrollable map (canvas-based),
        log area, and tank rendering.
        """
        self.root = root

        # Main container for layout organization
        self.main_frame = tk.Frame(self.root)
        self.main_frame.pack(fill="both", expand=True)

        # Create a canvas for the map with vertical and horizontal scrollbars
        self.canvas = tk.Canvas(self.main_frame, bg="white", width=800, height=300)
        self.scrollbar_y = ttk.Scrollbar(self.main_frame, orient="vertical", command=self.canvas.yview)
        self.scrollbar_x = ttk.Scrollbar(self.main_frame, orient="horizontal", command=self.canvas.xview)
        self.canvas.configure(yscrollcommand=self.scrollbar_y.set, xscrollcommand=self.scrollbar_x.set)
        self.scrollbar_y.pack(side="right", fill="y")
        self.scrollbar_x.pack(side="bottom", fill="x")
        self.canvas.pack(side="left", fill="both", expand=True)

        # Internal data structures for managing canvas elements
        self.grid_elements = {}    # Holds grid rectangle IDs and their coordinates
        self.cell_states = {}      # Stores each cell's current state (terrain, units, etc.)
        self.tank_graphics = {}    # Tracks the tank's graphical components

        # Log area for messages
        self.log_area = None
        self.create_log_area()

    def create_log_area(self):
        """
        Creates a text area to display the game log.
        """
        self.log_area = tk.Text(self.root, height=5, wrap="word", bg="lightyellow")
        self.log_area.pack(side="bottom", fill="x")
        self.log_area.configure(state="disabled")

    def create_map(self, rows, cols, cell_click_callback):
        """
        Creates a dynamically sized map grid without debug coordinate labels.

        Args:
            rows (int): Number of rows in the grid.
            cols (int): Number of columns in the grid.
            cell_click_callback (callable): Function to call when a cell is clicked.
        """
        self.grid_elements.clear()
        self.cell_states.clear()

        cell_width = 50
        cell_height = 50

        for row in range(rows):
            for col in range(cols):
                # Generate cell coordinates (e.g., A1, A2, ...)
                coord = f"{chr(65 + row)}{col + 1}"  # 'A1', 'B1', etc.
                x1, y1 = col * cell_width, row * cell_height
                x2, y2 = x1 + cell_width, y1 + cell_height

                # Draw the grid cell without text labels
                rect_id = self.canvas.create_rectangle(x1, y1, x2, y2, fill="lightgray", outline="black")
                self.grid_elements[coord] = rect_id
                self.cell_states[coord] = "Empty"

                # Bind the cell click event
                self.canvas.tag_bind(rect_id, "<Button-1>", lambda event, c=coord: cell_click_callback(c))

    def update_log(self, message):
        """
        Appends a message to the log area.

        Args:
            message (str): The message to display.
        """
        if self.log_area:
            self.log_area.configure(state="normal")
            self.log_area.insert(tk.END, message + "\n")
            self.log_area.see(tk.END)
            self.log_area.configure(state="disabled")
        try:
            with open("t64log.txt", "a") as log_file:
                log_file.write(message + "\n")
        except Exception as e:
            print(f"[ERROR] Failed to write to log file: {e}")

    def draw_tank(self, coord, hull_angle=0, turret_angle=0):
        """
        Draws a tank at the specified coordinate, adjusting its hull and turret direction.

        Args:
            coord (str): The grid coordinate (e.g., "A1").
            hull_angle (float): The angle of the hull (in degrees).
            turret_angle (float): The angle of the turret (in degrees).
        """
        if coord not in self.grid_elements:
            print(f"[LOG] {coord} is not a valid coordinate.")
            return

        self.clear_tank()

        rect_id = self.grid_elements[coord]
        x1, y1, x2, y2 = self.canvas.coords(rect_id)
        center_x = (x1 + x2) / 2
        center_y = (y1 + y2) / 2

        # Dimensions
        hull_width, hull_height = 30, 20
        turret_radius = 8
        gun_length = 20

        # Calculate hull corners based on the hull angle
        hull_dx = hull_width / 2 * math.cos(math.radians(hull_angle))
        hull_dy = hull_width / 2 * math.sin(math.radians(hull_angle))
        offset_x = hull_height / 2 * math.sin(math.radians(hull_angle))
        offset_y = hull_height / 2 * math.cos(math.radians(hull_angle))

        hull_corners = [
            (center_x - hull_dx - offset_x, center_y - hull_dy + offset_y),
            (center_x + hull_dx - offset_x, center_y + hull_dy + offset_y),
            (center_x + hull_dx + offset_x, center_y + hull_dy - offset_y),
            (center_x - hull_dx + offset_x, center_y - hull_dy - offset_y),
        ]

        # Draw the hull
        self.tank_graphics["hull"] = self.canvas.create_polygon(hull_corners, fill="green")

        # Draw the turret
        self.tank_graphics["turret"] = self.canvas.create_oval(
            center_x - turret_radius, center_y - turret_radius,
            center_x + turret_radius, center_y + turret_radius,
            fill="darkgreen"
        )

        # Draw the gun
        gun_dx = gun_length * math.cos(math.radians(turret_angle))
        gun_dy = gun_length * math.sin(math.radians(turret_angle))
        self.tank_graphics["gun"] = self.canvas.create_line(
            center_x, center_y,
            center_x + gun_dx, center_y + gun_dy,
            fill="black", width=3
        )

        print(f"[LOG] Tank drawn at {coord} with hull_angle={hull_angle}° and turret_angle={turret_angle}°")

    def clear_tank(self):
        """
        Clears all tank graphics from the canvas.
        """
        for part in self.tank_graphics.values():
            self.canvas.delete(part)
        self.tank_graphics.clear()

    def update_cell(self, coord, terrain_type, color):
        """
        Updates the visual appearance of a cell on the grid.

        Args:
            coord (str): The coordinate of the cell (e.g., "A1").
            terrain_type (str): The terrain type designation (e.g., "Forest").
            color (str): The fill color for the cell.
        """
        if coord in self.grid_elements:
            rect_id = self.grid_elements[coord]
            self.canvas.itemconfig(rect_id, fill=color)
            self.cell_states[coord] = terrain_type

    def display_game_over_overlay(self, message, restart_command=None):
        """
        Displays a game over overlay on the canvas along with a 'Play Again' button if provided.

        Args:
            message (str): A message to display (e.g., "You Win!" or "Game Over!").
            restart_command (callable, optional): Function to call when the play-again button is clicked.
        """
        width = self.canvas.winfo_width()
        height = self.canvas.winfo_height()

        # Create a semi-transparent overlay
        self.canvas.create_rectangle(0, 0, width, height, fill="black", stipple="gray50", tags="game_over_overlay")

        # Display the game over message
        self.canvas.create_text(
            width // 2, height // 2,
            text=message,
            fill="white",
            font=("Helvetica", 32, "bold"),
            tags="game_over_text"
        )

        if restart_command:
            restart_button = tk.Button(self.root, text="Play Again", command=restart_command, bg="green", fg="white")
            self.canvas.create_window(width // 2, height // 2 + 50, window=restart_button, tags="restart_button")

        print(f"[LOG] Game Over overlay displayed with message: {message}")

    def reset(self):
        """
        Resets the GameUI: clears canvas elements, grid, and log.
        """
        self.canvas.delete("all")
        self.grid_elements.clear()
        self.cell_states.clear()
        self.tank_graphics.clear()
        if self.log_area:
            self.log_area.configure(state="normal")
            self.log_area.delete(1.0, tk.END)
            self.log_area.configure(state="disabled")

    def turret_toss(self, x, y, debris_count=6, range_min=15, range_max=30):
        """
        Creates a turret toss animation with randomized debris.
    
        Args:
            x (float): The x-coordinate for the toss center.
            y (float): The y-coordinate for the toss center.
            debris_count (int): Number of debris pieces to create.
            range_min (int): Minimum scatter range.
            range_max (int): Maximum scatter range.
        """
        for _ in range(debris_count):
            dx = random.uniform(-range_max, range_max)
            dy = random.uniform(-range_max, range_max)
            debris_piece = self.canvas.create_oval(
                x - 3, y - 3, x + 3, y + 3, fill="orange"
            )
            self._animate_debris(debris_piece, dx, dy)
    
    def _animate_debris(self, debris, dx, dy, steps=20):
        """
        Animates a piece of debris along a trajectory.
    
        Args:
            debris (int): The canvas object ID of the debris.
            dx (float): x-velocity.
            dy (float): y-velocity.
            steps (int): Number of animation steps.
        """
        def step_animation(step=0):
            if step < steps:
                self.canvas.move(debris, dx / steps, dy / steps)
                self.canvas.after(50, step_animation, step + 1)
            else:
                self.canvas.delete(debris)
        step_animation()
media_rw
import random
import math

class PlayerManager:
    def __init__(self, grid_elements, terrain_manager, ui):
        """
        Initializes the PlayerManager with references to the grid elements, terrain manager, and GameUI.

        Args:
            grid_elements (dict): Dictionary of canvas rectangles for the grid.
            terrain_manager (TerrainManager): Instance of TerrainManager for managing terrains.
            ui (GameUI): Instance of GameUI for drawing and managing the UI.
        """
        self.grid_elements = grid_elements
        self.terrain_manager = terrain_manager
        self.ui = ui  # Reference to the GameUI
        self.player_position = None
        self.player_stats = {"hp": 20, "ammo": 1}  # Default player stats
        self.hull_angle = 0  # Hull starts facing default direction
        self.turret_angle = 0  # Turret aligns with hull initially

    def deploy_player(self):
        """
        Deploys the player unit on a random empty tile and displays the tank graphic.

        Returns:
            str: The coordinate of the deployed player unit.

        Raises:
            ValueError: If deployment fails after multiple attempts.
        """
        for _ in range(10):  # Retry up to 10 times for deployment
            self.player_position = random.choice(list(self.grid_elements.keys()))
            if self.terrain_manager.get_terrain(self.player_position) == "Empty":
                # Draw the player's tank on the selected coordinate
                self.ui.draw_tank(self.player_position, self.hull_angle, self.turret_angle)
                self.ui.update_log(f"[DEBUG] Player deployed at: {self.player_position}")
                return self.player_position

        raise ValueError("Failed to deploy player unit after multiple attempts.")

    def move_player_smoothly(self, target_position):
        """
        Smoothly moves the player unit to a specified target position and adjusts the hull angle.

        Args:
            target_position (str): The coordinate to move the player unit to.

        Returns:
            str: The new position of the player unit.
        """
        if target_position not in self.grid_elements:
            self.ui.update_log(f"[LOG] Invalid target position: {target_position}")
            return self.player_position

        # Calculate direction of movement
        start_coord = self.player_position
        dx = int(target_position[1:]) - int(start_coord[1:])  # Horizontal difference
        dy = ord(target_position[0]) - ord(start_coord[0])  # Vertical difference

        # Update the hull angle immediately
        if dx != 0 or dy != 0:
            self.hull_angle = math.degrees(math.atan2(dy, dx))  # Proper angle calculation
            self.ui.update_log(f"[DEBUG] Hull angle updated to {self.hull_angle:.2f}° on movement.")

        # Animate the movement
        self._animate_tank_smoothly(target_position)

        # Update player's position
        self.player_position = target_position
        self.ui.update_log(f"[DEBUG] Player moved to {self.player_position}, Hull angle: {self.hull_angle:.2f}°")
        return self.player_position

    def _animate_tank_smoothly(self, target_position, steps=10):
        """
        Animates the tank's movement from its current position to the target position.

        Args:
            target_position (str): The coordinate to move the tank to.
            steps (int): Number of animation steps to transition smoothly.
        """
        rect_id_start = self.grid_elements[self.player_position]
        rect_id_end = self.grid_elements[target_position]

        # Get coordinates for animation
        x1, y1, x2, y2 = self.ui.canvas.coords(rect_id_start)
        start_x, start_y = (x1 + x2) / 2, (y1 + y2) / 2
        tx1, ty1, tx2, ty2 = self.ui.canvas.coords(rect_id_end)
        end_x, end_y = (tx1 + tx2) / 2, (ty1 + ty2) / 2

        dx = (end_x - start_x) / steps
        dy = (end_y - start_y) / steps

        def move_step(step=0):
            if step > steps:
                # Redraw tank at final position with updated hull angle
                self.ui.draw_tank(target_position, self.hull_angle, self.turret_angle)
                return
            self.ui.canvas.move(self.ui.tank_graphics["hull"], dx, dy)
            self.ui.canvas.move(self.ui.tank_graphics["turret"], dx, dy)
            self.ui.canvas.move(self.ui.tank_graphics["gun"], dx, dy)
            self.ui.canvas.after(50, move_step, step + 1)

        move_step()

    def aim_turret(self, target_position):
        """
        Adjusts the turret to point at the specified target position and logs the calculations.

        Args:
            target_position (str): The coordinate to aim the turret at.
        """
        if target_position not in self.grid_elements:
            self.ui.update_log(f"[LOG] Invalid target position: {target_position}")
            return

        # Calculate direction to target
        current_coord = self.player_position
        dx = int(target_position[1:]) - int(current_coord[1:])
        dy = ord(target_position[0]) - ord(current_coord[0])

        if dx != 0 or dy != 0:
            self.turret_angle = math.degrees(math.atan2(dy, dx))
            self.ui.update_log(f"[DEBUG] Turret aimed at {target_position}, Turret angle: {self.turret_angle:.2f}°")

        # Redraw tank to update turret orientation
        self.ui.draw_tank(self.player_position, self.hull_angle, self.turret_angle)

    def take_damage(self, damage):
        """
        Handles the player's tank taking damage. Triggers destruction if HP falls to zero.

        Args:
            damage (int): The amount of damage to inflict on the player's tank.
        """
        self.player_stats["hp"] -= damage
        self.ui.update_log(f"[LOG] Player took {damage} damage. HP: {self.player_stats['hp']}")
        if self.player_stats["hp"] <= 0:
            self.handle_destruction()

    def handle_destruction(self):
        """
        Triggers the destruction sequence for the player's tank, including a turret toss animation,
        and then displays the game over overlay.
        """
        self.ui.update_log("[DEBUG] Starting player tank destruction sequence.")
        self.ui.update_log(f"[LOG] Player tank destroyed at {self.player_position}. Initiating turret toss.")
        
        # Calculate center of the cell where the tank is located
        rect_id = self.grid_elements[self.player_position]
        x1, y1, x2, y2 = self.ui.canvas.coords(rect_id)
        center_x = (x1 + x2) / 2
        center_y = (y1 + y2) / 2
        self.ui.update_log(f"[DEBUG] Calculated center for turret toss: ({center_x}, {center_y}).")

        # Trigger turret toss animation
        self.ui.turret_toss(center_x, center_y, debris_count=6, range_min=15, range_max=30)
        self.ui.update_log("[DEBUG] Turret toss executed. Waiting for animation to complete...")

        # Delay displaying the game over overlay so the turret toss animation can play
        self.ui.canvas.after(
            1000,
            lambda: self.ui.display_game_over_overlay("Game Over! Your tank has been destroyed!")
        )
        self.ui.update_log("[DEBUG] Game over overlay scheduled to display after delay.")

    def heal_player(self, amount):
        """
        Heals the player by a specified amount.

        Args:
            amount (int): The amount of health to restore.
        """
        self.player_stats["hp"] += amount
        if self.player_stats["hp"] > 20:
            self.player_stats["hp"] = 20
        self.ui.update_log(f"Player healed. Current HP: {self.player_stats['hp']}")

    def reset(self):
        """
        Resets the PlayerManager to its initial state for a new game.
        """
        self.player_position = None
        self.player_stats = {"hp": 20, "ammo": 1}
        self.hull_angle = 0
        self.turret_angle = 0
        self.ui.update_log(f"[LOG] PlayerManager reset. Stats: {self.player_stats}")
media_rw
import random

class UnitManager:
    def __init__(self, map_buttons, terrain_manager, enemy_count):
        """
        Initializes the UnitManager with references to map buttons, terrain, and enemy count.
        """
        self.map_buttons = map_buttons  # Reference to the map buttons
        self.terrain_manager = terrain_manager  # Reference to the terrain manager
        self.player_position = "A1"  # Initial player position
        self.enemy_positions = []  # List of enemy positions
        self.enemy_count = enemy_count  # Total number of enemies to deploy

    def deploy_player(self, player_unit_name):
        """
        Deploys the player unit on a random empty tile.
        """
        for _ in range(5):  # Retry up to 5 times for deployment
            self.player_position = random.choice(list(self.map_buttons.keys()))
            if self.terrain_manager.get_terrain(self.player_position) == "Empty":
                self.map_buttons[self.player_position].config(text=player_unit_name, bg="blue")
                return self.player_position
        # Raise an exception if deployment fails
        raise ValueError("Failed to deploy player unit. Restart required.")

    def deploy_enemies(self, enemy_unit_name):
        """
        Deploys enemy units on random empty tiles.
        """
        empty_cells = [
            coord for coord, terr in self.terrain_manager.terrain.items()
            if terr == "Empty" and self.map_buttons[coord].cget("text") == "Empty"
        ]
        if len(empty_cells) < self.enemy_count:
            raise ValueError("Not enough empty spaces to deploy enemies.")

        self.enemy_positions = random.sample(empty_cells, self.enemy_count)
        for enemy_position in self.enemy_positions:
            self.map_buttons[enemy_position].config(text=enemy_unit_name, bg="red")
        return self.enemy_positions

    def move_unit(self, current_position, target_position, unit_name):
        """
        Moves a unit from the current position to the target position.
        """
        self.map_buttons[current_position].config(text="Empty", bg="lightgray")
        self.map_buttons[target_position].config(text=unit_name, bg="blue")
        return target_position

    def move_enemy(self, enemy_position, target_position, enemy_name):
        """
        Moves an enemy unit from the current position to the target position.
        """
        self.map_buttons[enemy_position].config(text="Empty", bg="lightgray")
        self.map_buttons[target_position].config(text=enemy_name, bg="red")
        return target_position

    def is_adjacent(self, pos1, pos2):
        """
        Determines whether two positions on the map are adjacent.
        """
        row_diff = abs(ord(pos1[0]) - ord(pos2[0]))
        col_diff = abs(int(pos1[1]) - int(pos2[1]))
        return max(row_diff, col_diff) == 1
media_rw
import math
import random

class BomberHelper2:
    def __init__(self, canvas, ui):
        """
        Helper class for Bomber that handles drawing engines, wings, turrets, and guns.
        
        Args:
            canvas (tk.Canvas): The canvas to draw on.
            ui (GameUI): Instance for logging and debugging.
        """
        self.canvas = canvas
        self.ui = ui

    def draw_engine(self, x, y, pivot_x, pivot_y, heading_angle, width=4, length=16):
        """
        Draws an engine as an elongated rectangle with specified dimensions,
        rotated relative to the bomber. The long dimension (length) extends 
        front-to-back, and width is vertical.
        
        Args:
            x (float): Engine center x-coordinate.
            y (float): Engine center y-coordinate.
            pivot_x (float): Bomber's center x-coordinate.
            pivot_y (float): Bomber's center y-coordinate.
            heading_angle (float): Rotation angle in degrees.
            width (float): Engine width (default 4 pixels).
            length (float): Engine length (default 16 pixels).
        
        Returns:
            int: Canvas object ID of the engine.
        """
        half_width = width / 2
        half_length = length / 2
        # Define rectangle so length extends along the bomber's axis.
        points = [
            (x - half_length, y - half_width),  # Front-left
            (x + half_length, y - half_width),  # Front-right
            (x + half_length, y + half_width),  # Back-right
            (x - half_length, y + half_width)   # Back-left
        ]
        rotated_points = [self._rotate_point_relative(px, py, pivot_x, pivot_y, heading_angle)
                          for px, py in points]
        flat_points = [coord for point in rotated_points for coord in point]
        if self.ui:
            self.ui.update_log(f"[DEBUG] draw_engine: Rotated points: {rotated_points}")
        return self.canvas.create_polygon(flat_points, fill="darkgray", outline="black")

    def draw_wing(self, rel_x, rel_y, wing_span, pivot_x, pivot_y, heading_angle):
        """
        Draws a wing attached to the bomber at a position relative to its center.
        
        Args:
            rel_x (float): The wing's x offset relative to the bomber's center.
            rel_y (float): The wing's y offset relative to the bomber's center.
            wing_span (float): Total horizontal wing span.
            pivot_x (float): Bomber's center x-coordinate.
            pivot_y (float): Bomber's center y-coordinate.
            heading_angle (float): Bomber's rotation angle in degrees.
        
        Returns:
            int: Canvas object ID of the wing.
        """
        # Calculate absolute wing root position.
        root_x = pivot_x + rel_x
        root_y = pivot_y + rel_y
        p1 = (root_x - wing_span / 2, root_y)
        p2 = (root_x + wing_span / 2, root_y)
        rotated_p1 = self._rotate_point_relative(p1[0], p1[1], pivot_x, pivot_y, heading_angle)
        rotated_p2 = self._rotate_point_relative(p2[0], p2[1], pivot_x, pivot_y, heading_angle)
        if self.ui:
            self.ui.update_log(f"[DEBUG] draw_wing: Rotated points: {rotated_p1} to {rotated_p2}")
        return self.canvas.create_line(rotated_p1[0], rotated_p1[1],
                                       rotated_p2[0], rotated_p2[1],
                                       fill="black", width=2)

    def draw_turret(self, x, y):
        """
        Draws a turret at the specified position.
        
        Args:
            x (float): X-coordinate of the turret center.
            y (float): Y-coordinate of the turret center.
        
        Returns:
            int: Canvas object ID of the turret.
        """
        turret_id = self.canvas.create_oval(x - 5, y - 5, x + 5, y + 5,
                                             fill="darkred", outline="black")
        if self.ui:
            self.ui.update_log(f"[DEBUG] draw_turret: Created turret at ({x}, {y}) with ID {turret_id}")
        return turret_id

    def draw_gun(self, x, y, angle, length=20):
        """
        Draws a gun line extending from the turret.
        
        Args:
            x (float): Turret center x-coordinate.
            y (float): Turret center y-coordinate.
            angle (float): Firing angle in degrees.
            length (float): Length of the gun line.
        
        Returns:
            int: Canvas object ID of the gun line.
        """
        radians = math.radians(angle)
        end_x = x + length * math.cos(radians)
        end_y = y + length * math.sin(radians)
        gun_id = self.canvas.create_line(x, y, end_x, end_y, fill="black", width=2)
        if self.ui:
            self.ui.update_log(f"[DEBUG] draw_gun: Gun drawn from ({x}, {y}) to ({end_x}, {end_y}), angle={angle}°")
        return gun_id

    def _rotate_point_relative(self, x, y, pivot_x, pivot_y, angle):
        """
        Rotates a point around a pivot by the given angle in degrees.
        
        Args:
            x (float): X-coordinate of the point.
            y (float): Y-coordinate of the point.
            pivot_x (float): Pivot x-coordinate.
            pivot_y (float): Pivot y-coordinate.
            angle (float): Rotation angle in degrees.
        
        Returns:
            tuple: The rotated (x, y) coordinates.
        """
        radians = math.radians(angle)
        translated_x = x - pivot_x
        translated_y = y - pivot_y
        rotated_x = translated_x * math.cos(radians) - translated_y * math.sin(radians)
        rotated_y = translated_x * math.sin(radians) + translated_y * math.cos(radians)
        new_x = rotated_x + pivot_x
        new_y = rotated_y + pivot_y
        if self.ui:
            self.ui.update_log(f"[DEBUG] _rotate_point_relative: Rotated ({x}, {y}) to ({new_x}, {new_y}) around pivot ({pivot_x}, {pivot_y}), angle={angle}°")
        return new_x, new_y

    def rotate_point(self, x, y, pivot_x, pivot_y, angle):
        """
        Public method to rotate a point. Wrapper for _rotate_point_relative.
        
        Args:
            x (float): X-coordinate of the point.
            y (float): Y-coordinate of the point.
            pivot_x (float): Pivot x-coordinate.
            pivot_y (float): Pivot y-coordinate.
            angle (float): Rotation angle in degrees.
        
        Returns:
            tuple: The rotated (x, y) coordinates.
        """
        return self._rotate_point_relative(x, y, pivot_x, pivot_y, angle)

    def _animate_debris(self, debris, dx, dy, steps=20):
        """
        Animates debris to scatter along given vectors, then deletes it.
        
        Args:
            debris (int): Canvas object ID of the debris.
            dx (float): Total x displacement.
            dy (float): Total y displacement.
            steps (int): Number of animation steps.
        """
        def step_animation(step=0):
            if step < steps:
                self.canvas.move(debris, dx / steps, dy / steps)
                if self.ui:
                    self.ui.update_log(f"[DEBUG] _animate_debris: Step {step}, moving debris by ({dx/steps}, {dy/steps})")
                self.canvas.after(50, step_animation, step + 1)
            else:
                if self.ui:
                    self.ui.update_log(f"[DEBUG] _animate_debris: Animation complete for debris id {debris}")
                self.canvas.delete(debris)
        step_animation()
media_rw
import random

class TerrainManager:
    def __init__(self, grid_elements, canvas):
        """
        Initializes the TerrainManager with references to the grid elements and canvas.

        Args:
            grid_elements (dict): Dictionary of canvas rectangles for the grid.
            canvas (tk.Canvas): The canvas object to update terrain appearance.
        """
        self.grid_elements = grid_elements  # Reference to the grid elements
        self.canvas = canvas  # Reference to the canvas
        self.terrain = {}  # Dictionary to store terrain types for each cell

    def generate_terrain(self, enemy_count, extra_empty=5):
        """
        Generates terrain for the map and ensures a minimum number of empty tiles.

        Args:
            enemy_count (int): Number of enemies to deploy (affects empty tiles needed).
            extra_empty (int): Extra empty tiles to ensure playability.

        Returns:
            bool: True if terrain generation is successful, False otherwise.
        """
        retries = 5  # Maximum number of attempts to generate a valid map
        for _ in range(retries):
            self.terrain.clear()
            empty_count = 0

            # Randomly assign terrain types to each cell
            for coord in self.grid_elements.keys():
                terrain_type = random.choice(["Forest", "Mountain", "Water", "Empty"])
                self.terrain[coord] = terrain_type
                if terrain_type == "Empty":
                    empty_count += 1

            # Check if enough empty tiles are available
            if empty_count >= enemy_count + extra_empty:
                self._apply_terrain_to_canvas()
                return True  # Successful generation

        return False  # Failed to generate a valid map after retries

    def _apply_terrain_to_canvas(self):
        """
        Applies the generated terrain to the canvas, updating its appearance.
        """
        for coord, terrain_type in self.terrain.items():
            rect_id = self.grid_elements.get(coord)
            if rect_id:  # Ensure the coordinate exists in the grid
                if terrain_type == "Forest":
                    self._update_canvas_cell(rect_id, "green")
                elif terrain_type == "Mountain":
                    self._update_canvas_cell(rect_id, "brown")
                elif terrain_type == "Water":
                    self._update_canvas_cell(rect_id, "blue")
                elif terrain_type == "Empty":
                    self._update_canvas_cell(rect_id, "lightgray")

    def _update_canvas_cell(self, rect_id, color):
        """
        Updates the appearance of a canvas cell based on the given color.

        Args:
            rect_id (int): The ID of the rectangle on the canvas.
            color (str): The fill color for the rectangle.
        """
        self.canvas.itemconfig(rect_id, fill=color)

    def get_terrain(self, coord):
        """
        Gets the terrain type for a specific coordinate.

        Args:
            coord (str): The map coordinate (e.g., "A1").

        Returns:
            str: The terrain type (e.g., "Forest", "Mountain", "Water", or "Empty").
        """
        return self.terrain.get(coord, "Unknown")

    def reset(self):
        """
        Resets the TerrainManager to its initial state for a new game.
        """
        # Clear current terrain and reset the canvas cells to default "Empty" state
        self.terrain.clear()
        for coord, rect_id in self.grid_elements.items():
            self._update_canvas_cell(rect_id, "lightgray")
media_rw
import math
import random

class BomberHelper4:
    def __init__(self, canvas, ui):
        """
        Helper class for Bomber that handles turret firing, projectile animation,
        explosion effects, and debris animation.

        Args:
            canvas (tk.Canvas): The canvas on which to draw.
            ui (GameUI): Instance for logging (if desired).
        """
        self.canvas = canvas
        self.ui = ui

    def fire_turret(self, bomber, turret):
        """
        Fires a turret by generating a projectile from the tip of the gun,
        updating the gun so it points in the correct firing direction.
        
        Args:
            bomber (Bomber): The bomber instance.
            turret (dict): A turret dictionary with "angle", "id", and "gun_id".
        """
        angle = turret["angle"]
        radians = math.radians(angle)
        # Use a higher shell speed for fast shells.
        shell_speed = 30
        projectile_dx = shell_speed * math.cos(radians)
        projectile_dy = shell_speed * math.sin(radians)
        coords = self.canvas.coords(turret.get("id"))
        if coords:
            x1, y1, x2, y2 = coords
            center_x = (x1 + x2) / 2
            center_y = (y1 + y2) / 2
            # Compute the tip of the gun (fixed gun length = 20)
            gun_length = 20
            tip_x = center_x + gun_length * math.cos(radians)
            tip_y = center_y + gun_length * math.sin(radians)
            # Update or create the turret's gun line so that it emanates from the turret center to the gun tip.
            if turret.get("gun_id"):
                self.canvas.coords(turret["gun_id"], center_x, center_y, tip_x, tip_y)
            else:
                turret["gun_id"] = self.canvas.create_line(center_x, center_y, tip_x, tip_y, fill="black", width=2)
            # Create the projectile at the tip of the gun.
            projectile = self.canvas.create_oval(
                tip_x - 2, tip_y - 2,
                tip_x + 2, tip_y + 2,
                fill="yellow"
            )
            if self.ui:
                self.ui.update_log(f"Firing turret: Projectile created at ({tip_x}, {tip_y}) with dx={projectile_dx}, dy={projectile_dy}")
            # Animate the projectile quickly using few steps.
            self._animate_projectile(bomber, projectile, projectile_dx, projectile_dy, steps=5)
        else:
            if self.ui:
                self.ui.update_log(f"Error firing turret: No coordinates for turret with id {turret.get('id')}")

    def _animate_projectile(self, bomber, projectile, dx, dy, steps=5):
        """
        Animates a projectile along its trajectory very quickly, then deletes it.
        
        Args:
            bomber (Bomber): The bomber instance.
            projectile (int): Canvas object ID for the projectile.
            dx (float): X velocity.
            dy (float): Y velocity.
            steps (int): Number of animation steps.
        """
        def step_animation(step=0):
            if step < steps:
                bomber.canvas.move(projectile, dx/steps, dy/steps)
                bomber.canvas.after(20, step_animation, step+1)
            else:
                bomber.canvas.delete(projectile)
        step_animation()

    def trigger_explosion(self, bomber):
        """
        Triggers an explosion that scatters bomber components outward, including turret gun barrels.
        
        Args:
            bomber (Bomber): The bomber instance.
        """
        components = ([bomber.body] + bomber.wings + bomber.engines +
                      [turret.get("id") for turret in bomber.turrets if turret.get("id")] +
                      [turret.get("gun_id") for turret in bomber.turrets if turret.get("gun_id")])
        animated_parts = []
        for comp in components:
            if comp:
                dx = random.uniform(-150, 150)
                dy = random.uniform(-150, 150)
                self._animate_debris(bomber, comp, dx, dy, steps=30)
                animated_parts.append(comp)
        for _ in range(10):
            dx = random.uniform(-200, 200)
            dy = random.uniform(-200, 200)
            debris = self.canvas.create_oval(bomber.x - 5, bomber.y - 5,
                                             bomber.x + 5, bomber.y + 5, fill="orange")
            self._animate_debris(bomber, debris, dx, dy, steps=30)
            animated_parts.append(debris)
        bomber.canvas.after(2000, lambda: [bomber.canvas.delete(comp) for comp in animated_parts])
        bomber.body = None
        bomber.wings = []
        bomber.engines = []
        bomber.turrets = [{"angle": 0, "id": None, "gun_id": None},
                          {"angle": 180, "id": None, "gun_id": None}]

    def _animate_debris(self, bomber, debris, dx, dy, steps=20):
        """
        Animates debris along a vector, then deletes it.
        
        Args:
            bomber (Bomber): The bomber instance.
            debris (int): Canvas object ID for the debris.
            dx (float): Total x displacement.
            dy (float): Total y displacement.
            steps (int): Number of animation steps.
        """
        def step_animation(step=0):
            if step < steps:
                bomber.canvas.move(debris, dx/steps, dy/steps)
                bomber.canvas.after(50, step_animation, step+1)
            else:
                bomber.canvas.delete(debris)
        step_animation()
media_rw
import tkinter as tk

class GameApp:
    def __init__(self):
        """
        Wraps the entire game within a single object.
        Initializes the Tkinter root and game session.
        """
        self.root = tk.Tk()
        self.root.title("Turn-Based Tactical Simulation")
        self.tactical_map = None
        self.start_game()

    def start_game(self):
        """
        Starts a new game session by initializing TacticalMap and passing the replay callback.
        """
        from TacticalMap import TacticalMap  # Import here to avoid circular dependency
        if self.tactical_map:
            # Ensure TacticalMap is cleared before starting a new game
            self.tactical_map.reset()
        else:
            self.tactical_map = TacticalMap(self.root, on_replay=self.restart_game)

    def restart_game(self):
        """
        Resets the game session without destroying the entire root window.
        """
        if self.tactical_map:
            self.tactical_map.reset()
        else:
            self.start_game()

    def run(self):
        """
        Runs the Tkinter main loop.
        """
        self.root.mainloop()
media_rw
import math
import random
from bomberhelper4 import BomberHelper4

class BomberHelper3:
    def __init__(self, canvas, ui):
        """
        Helper class for Bomber that handles fuselage calculations, clearing drawings,
        rotation, and spin tests.
        Turret firing and explosion effects are delegated to BomberHelper4.
        
        Args:
            canvas (tk.Canvas): The canvas to draw on.
            ui (GameUI): Instance for logging/debugging.
        """
        self.canvas = canvas
        self.ui = ui
        self.helper4 = BomberHelper4(canvas, ui)

    def calculate_fuselage_points(self, bomber):
        """
        Calculates the fuselage polygon points for the bomber and rotates them
        by the bomber's heading.
        
        Args:
            bomber (Bomber): The bomber instance with x, y, and heading_angle.
        
        Returns:
            list: A list of rotated (x, y) tuples representing the fuselage polygon.
        """
        length = 120
        height = 10
        taper = length * 0.25
        points = [
            (bomber.x - length/2 + taper, bomber.y - height/2),  # Front-left.
            (bomber.x + length/2 - taper, bomber.y - height/2),  # Front-right.
            (bomber.x + length/2, bomber.y),                       # Nose.
            (bomber.x + length/2 - taper, bomber.y + height/2),  # Back-right.
            (bomber.x - length/2 + taper, bomber.y + height/2),  # Back-left.
            (bomber.x - length/2, bomber.y)                        # Tail.
        ]
        rotated = [self._rotate_point_relative(x, y, bomber.x, bomber.y, bomber.heading_angle)
                   for x, y in points]
        if self.ui:
            self.ui.update_log(f"[DEBUG] calculate_fuselage_points: {rotated}")
        return rotated

    def clear_previous_drawings(self, bomber):
        """
        Clears all bomber components from the canvas, preserving turret structure.
        
        Args:
            bomber (Bomber): The bomber instance.
        """
        components = [bomber.body] + bomber.wings + bomber.engines
        for turret in bomber.turrets:
            if turret.get("id"):
                components.append(turret["id"])
            if turret.get("gun_id"):
                components.append(turret["gun_id"])
        for comp in components:
            self.canvas.delete(comp)
        bomber.body = None
        bomber.wings = []
        bomber.engines = []
        for turret in bomber.turrets:
            turret["id"] = None
            turret["gun_id"] = None

    def rotate_to_heading(self, bomber, heading_angle):
        """
        Rotates the bomber to a new heading and redraws it.
        
        Args:
            bomber (Bomber): The bomber instance.
            heading_angle (float): The new heading in degrees.
        """
        bomber.heading_angle = heading_angle % 360
        if self.ui:
            self.ui.update_log(f"[DEBUG] rotate_to_heading: Bomber rotated to {bomber.heading_angle}° at ({bomber.x}, {bomber.y}).")
        bomber.draw()

    def spin_test(self, bomber):
        """
        Spins the bomber by 45° increments every second and fires each turret once per cycle.
        Turret firing is delegated to BomberHelper4.
        
        Args:
            bomber (Bomber): The bomber instance.
        """
        def rotate_step(angle=0):
            if angle >= 360:
                return
            bomber.rotate_to_heading(angle)
            if self.ui:
                self.ui.update_log(f"[DEBUG] spin_test: Bomber rotated to {angle}° at ({bomber.x}, {bomber.y}).")
                for i, turret in enumerate(bomber.turrets):
                    if "angle_range" not in turret:
                        turret["angle_range"] = (0, 360)
                        self.ui.update_log(f"[WARNING] spin_test: Turret {i} missing 'angle_range', defaulting to (0,360).")
                    self.ui.update_log(f"[DEBUG] turret {i}: {turret}")
            for turret in bomber.turrets:
                min_angle, max_angle = turret["angle_range"]
                turret["angle"] = random.uniform(min_angle, max_angle)
                if self.ui:
                    self.ui.update_log(f"[DEBUG] spin_test: Turret firing at angle {turret['angle']:.2f} (range {min_angle}-{max_angle}).")
                self.helper4.fire_turret(bomber, turret)
            self.canvas.after(1000, rotate_step, angle + 45)
        rotate_step(0)

    def trigger_explosion(self, bomber):
        """
        Delegates the explosion trigger to BomberHelper4.

        Args:
            bomber (Bomber): The bomber instance.
        """
        self.helper4.trigger_explosion(bomber)

    def _rotate_point_relative(self, x, y, pivot_x, pivot_y, angle):
        """
        Rotates a point around a pivot by the given angle in degrees.
        
        Args:
            x (float): X-coordinate of the point.
            y (float): Y-coordinate.
            pivot_x (float): Pivot x-coordinate.
            pivot_y (float): Pivot y-coordinate.
            angle (float): Rotation angle in degrees.
        
        Returns:
            tuple: Rotated (x, y) coordinates.
        """
        radians = math.radians(angle)
        translated_x = x - pivot_x
        translated_y = y - pivot_y
        rotated_x = translated_x * math.cos(radians) - translated_y * math.sin(radians)
        rotated_y = translated_x * math.sin(radians) + translated_y * math.cos(radians)
        return rotated_x + pivot_x, rotated_y + pivot_y
media_rw
import tkinter as tk

class GameApp:
    def __init__(self):
        """
        Wraps the entire game within a single object.
        Initializes the Tkinter root and game session.
        """
        self.root = tk.Tk()
        self.root.title("Turn-Based Tactical Simulation")
        self.tactical_map = None
        self.start_game()

    def start_game(self):
        """
        Starts a new game session by initializing TacticalMap and passing the replay callback.
        """
        from TacticalMap import TacticalMap  # Import here to avoid circular dependency
        if self.tactical_map:
            # Ensure TacticalMap is cleared before starting a new game
            self.tactical_map.reset()
        else:
            self.tactical_map = TacticalMap(self.root, on_replay=self.restart_game)

    def restart_game(self):
        """
        Resets the game session without destroying the entire root window.
        """
        if self.tactical_map:
            self.tactical_map.reset()
        else:
            self.start_game()

    def run(self):
        """
        Runs the Tkinter main loop.
        """
        self.root.mainloop()
