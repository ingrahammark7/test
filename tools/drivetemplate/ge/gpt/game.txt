media_rw
import json
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression

country_code_map = {
    'Japan': 'JP',
    'South Korea': 'KR',
    'Republic of Korea': 'KR',
    'Malaysia': 'MY',
    'Thailand': 'TH'
}

def residuals(y, X):
    model = LinearRegression().fit(X, y)
    return y - model.predict(X)

def analyze_partial_correlation():
    with open("fe1.json", 'r', encoding='utf-8') as f:
        data = json.load(f)

    df = pd.DataFrame(data)
    
    # Drop Thailand
    df = df[df['country'] != 'Thailand']
    
    # Identify variables to modify (all except target, education, name, and region)
    exclude_vars = ['fertility_rate', 'female_education_years', 'country', 'un_geoscheme']
    stat_vars = [col for col in df.columns if col not in exclude_vars]

    # Apply adverse transformation for selected countries
    for country in ['Japan', 'South Korea', 'Malaysia']:
        mask = df['country'] == country
        for var in stat_vars:
            df.loc[mask, var] = df.loc[mask, var] * 2  # Adverse direction: double values

    # Print full country list by region
    print("\nCountries by Region:")
    for region, group in df.groupby('un_geoscheme'):
        countries = ", ".join(sorted(group['country'].unique()))
        print(f"{region:<20}: {countries}")
    
    # Correlation analysis
    print(f"\n{'Region':<20} {'N':>3} {'Raw Corr':>10} {'Partial Corr':>15}")
    print("-" * 55)

    for region, group in df.groupby('un_geoscheme'):
        if len(group) < 3:
            print(f"{region:<20} {len(group):>3} {'N/A':>10} {'N/A':>15}  (too few samples)")
            continue

        y = group['fertility_rate'].values
        x_edu = group['female_education_years'].values

        control_vars = [col for col in group.columns if col not in exclude_vars]
        X_controls = group[control_vars].values

        corr_raw = np.corrcoef(y, x_edu)[0, 1]
        y_resid = residuals(y, X_controls)
        x_resid = residuals(x_edu, X_controls)
        corr_partial = np.corrcoef(y_resid, x_resid)[0, 1]

        print(f"{region:<20} {len(group):>3} {corr_raw:10.4f} {corr_partial:15.4f}")

if __name__ == "__main__":
    analyze_partial_correlation()
media_rw
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from reportlab.lib.units import inch
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.platypus import Paragraph, Frame

def create_pdf(output_filename):
    # Create a PDF document
    c = canvas.Canvas(output_filename, pagesize=letter)
    width, height = letter

    # Set margins
    left_margin = 1 * inch
    right_margin = width - 1 * inch
    top_margin = height - 1 * inch
    bottom_margin = 0 * inch

    # Set font and size (Times New Roman, 12-point)
    c.setFont("Times-Roman", 12)

    # Add page numbers (starting from page 2)
    def add_page_number(page_num):
        if page_num > 1:  # Suppress page number on the first page
            c.setFont("Times-Roman", 10)
            c.drawCentredString(width / 2, 0.5 * inch, f"{page_num}")

    # Add footer
    def add_footer(page_num):
        footer_y = 0.4 * inch  # Position for footer
        footer_text = "Petition for Writ of Mandate"  # Title of the paper
        c.setFont("Times-Roman", 10)  # Font size for footer
        c.drawCentredString(width / 2, footer_y, footer_text)
        # Draw a line above the footer
        c.line(left_margin, footer_y + 0.1 * inch, right_margin, footer_y + 0.1 * inch)

    # Add line numbers
    def add_line_numbers(start_y, end_y, line_height):
        line_number_x = left_margin - 0.5 * inch  # Position for line numbers
        line_number = 1
        current_y = start_y
        while current_y >= end_y:
            c.drawString(line_number_x, current_y, str(line_number))
            line_number += 1
            current_y -= line_height

    # First Page Format (Rule 2.111)
    # (1) Attorney Information
    c.setFont("Times-Roman", 12)
    attorney_info = [
        "Mark Ingraham",
        "3553 Atlantic Avenue",
        "Long Beach, CA 90807",
        "Telephone: (408) 660-5425",
        "Email: ingrahammark7@gmail.com"
    ]
    y_position = top_margin - 0.5 * inch
    for line in attorney_info:
        c.drawString(left_margin, y_position, line)
        y_position -= 0.25 * inch

    # (2) Clerk's Space (blank space to the right of center)
    c.rect(width / 2 + 0.5 * inch, top_margin - 2 * inch, 2 * inch, 1.5 * inch, stroke=1, fill=0)

    # (3) Court Title
    c.setFont("Times-Bold", 14)
    c.drawCentredString(width / 2, top_margin - 3.33 * inch, "UNITED STATES DISTRICT COURT")
    c.drawCentredString(width / 2, top_margin - 3.66 * inch, "CENTRAL DISTRICT OF CALIFORNIA")

    # (4) Case Title
    c.setFont("Times-Bold", 12)
    case_title = [
        "Mark Ingraham,",
        "             Petitioner and Plaintiff,",
        "         v.",
        "Office of the Comptroller of the Currency",
        "of the United States Department of the Treasury",
        "             Respondent and Defendant."
    ]
    y_position = top_margin - 4.75* inch
    counter=0
    for line in case_title:
        c.setFont("Times-Bold",12)
        if counter==1 or counter==5:
        	c.setFont("Times-Roman",12)
        c.drawString(left_margin, y_position, line)
        y_position -= 0.25 * inch
        counter+=1

    # (5) Case Number
    c.setFont("Times-Roman", 12)
    space=width / 2 + 1 * inch
    c.drawString(space, top_margin - 4 * inch, "Case Number:")
    # (6) Nature of the Paper (moved slightly lower)
    c.setFont("Times-Bold", 12)
    c.drawString(space, top_margin - 5.5 * inch, "Petition for Writ of Mandate")
    c.setFont("Times-Bold", 12)
    c.drawString(space, top_margin - 6.00 * inch, "Administrative Mandamus")

    # (7) Judge and Department
    c.setFont("Times-Roman", 12)
    c.drawString(space, top_margin - 6.5 * inch, "Judge: ")
    c.drawString(space, top_margin - 6.75 * inch, "Department: ")

    # Add line numbers to the first page
    line_height = 0.25 * inch  # Adjusted to match text spacing
    add_line_numbers(top_margin - 0.5 * inch, bottom_margin + 0.5 * inch, line_height)

    # Add footer (suppressed on the first page)
    add_footer(1)

    # Save the first page
    c.showPage()

    # Second Page: Petition Text
    c.setFont("Times-Bold", 14)
    c.drawString(left_margin, top_margin - 0.5 * inch, "PETITION FOR WRIT OF MANDATE")

    # Add line numbers to the second page
    add_line_numbers(top_margin - 0.5 * inch, bottom_margin + 0.5 * inch, line_height)

    # I. INTRODUCTION
    c.setFont("Times-Bold", 12)
    c.drawString(left_margin, top_margin - 1 * inch, "I. INTRODUCTION")
    c.setFont("Times-Roman", 12)
    intro_text = [
        "1. Petitioner, Mark Ingraham, petitions this Court for a copy of the police report attached to a case opened",
        "by the Office of the Comptroller of the Currency (OCC) Customer Assistance Group OCC Ombudsman.",
        "2. The case number is CS0366753.",
    ]
    y_position = top_margin - 1.5 * inch
    for line in intro_text:
        c.drawString(left_margin, y_position, line)
        y_position -= 0.25 * inch

    # II. FACTUAL BACKGROUND
    c.setFont("Times-Bold", 12)
    c.drawString(left_margin, y_position - 0.5 * inch, "II. FACTUAL BACKGROUND")
    c.setFont("Times-Roman", 12)
    factual_background = [
        "1. Petitioner was informed by OCC that a police report regarding ''cartel activity'' was attached to the case.",
        "2. Petitioner called the OCC for further information and did not recieve adequate details.",
    ]
    y_position -= 1 * inch
    for line in factual_background:
        c.drawString(left_margin, y_position, line)
        y_position -= 0.25 * inch

    # III. REQUEST FOR RELIEF
    c.setFont("Times-Bold", 12)
    c.drawString(left_margin, y_position - 0.5 * inch, "III. REQUEST FOR RELIEF")
    c.setFont("Times-Roman", 12)
    relief_text = [
        "WHEREFORE, Petitioner requests that this Court:",
        "a. Issue a writ of mandate ordering the OCC to provide the police reports attached to case CS0366753",
        " and any related cases.",
    ]
    y_position -= 1 * inch
    for line in relief_text:
        c.drawString(left_margin, y_position, line)
        y_position -= 0.25 * inch
        
        # III. REQUEST FOR RELIEF
    c.setFont("Times-Bold", 12)
    c.drawString(left_margin, y_position - 0.5 * inch, "IV. PROCEDURAL NOTE")
    c.setFont("Times-Roman", 12)
    relief_text = [
        "1. The defendant has an aggressive security guard who has interfered with service of a previous case. ",
        "2. Court should issue an order to the process server company and the guard to compel service.",
    ]
    y_position -= 1 * inch
    for line in relief_text:
        c.drawString(left_margin, y_position, line)
        y_position -= 0.25 * inch

    # Signature Block
    c.setFont("Times-Roman", 12)
    c.drawString(left_margin, y_position - 0.5 * inch, "Submitted,")
    c.drawString(left_margin, y_position - 1 * inch, "Mark Ingraham")
    
    # Add footer and page number
    add_footer(2)
    add_page_number(2)

    # Save the PDF
    c.save()

if __name__ == "__main__":
    output_filename = "writ_of_mandate_petition.pdf"
    create_pdf(output_filename)
    print(f"PDF created: {output_filename}")
media_rw
import json
from collections import defaultdict
from scipy.stats import pearsonr

# Load your JSON files (replace with actual file paths or variables)
with open('f1.json') as f1_file:
    data_f1 = json.load(f1_file)
with open('f2.json') as f2_file:
    data_f2 = json.load(f2_file)
with open('f3.json') as f3_file:
    data_f3 = json.load(f3_file)

fighter_stats = data_f1['fighter_stats']
conflicts = data_f3

# Map conflict name to start year for quick lookup
conflict_year_map = {}
for cname, cdata in conflicts.items():
    start = cdata.get('start')
    if start is not None:
        conflict_year_map[cname] = start

# Helper: get nation of fighter
def get_nation(fighter):
    info = data_f2.get(fighter, {})
    return info.get('nation')

# Collect data: {nation: {age_bucket: [ratios]}} and store conflict samples per bucket
nation_age_ratios = defaultdict(lambda: defaultdict(list))
nation_age_conflicts = defaultdict(lambda: defaultdict(set))

# Debug counters
total_pairs = 0
skipped_no_in_service = 0
skipped_no_conflict_year = 0
skipped_zero_kills_losses = 0
skipped_negative_age = 0
matched_pairs = 0

for fighter, conflicts_data in fighter_stats.items():
    in_service = data_f2.get(fighter, {}).get('in_service')
    nation = get_nation(fighter)
    if in_service is None or nation is None:
        skipped_no_in_service += 1
        continue
    for conflict_name, stats in conflicts_data.items():
        if conflict_name == "Total":
            continue  # Skip totals
        start_year = conflict_year_map.get(conflict_name)
        if start_year is None:
            skipped_no_conflict_year += 1
            continue
        kills = stats.get('Kills', 0)
        losses = stats.get('Loss', 0)
        total_pairs += 1
        if kills == 0 and losses == 0:
            skipped_zero_kills_losses += 1
            continue
        age = start_year - in_service
        if age < 0:
            skipped_negative_age += 1
            continue
        kill_ratio = kills / losses if losses > 0 else kills
        if kill_ratio == 0:
            continue
        matched_pairs += 1
        nation_age_ratios[nation][age].append(kill_ratio)
        if len(nation_age_conflicts[nation][age]) < 3:
            nation_age_conflicts[nation][age].add(conflict_name)

def print_summary():
    print(f"Total (fighter, conflict) pairs: {total_pairs}")
    print(f"Skipped no in_service or nation: {skipped_no_in_service}")
    print(f"Skipped no conflict year: {skipped_no_conflict_year}")
    print(f"Skipped zero kills or losses: {skipped_zero_kills_losses}")
    print(f"Skipped negative age: {skipped_negative_age}")
    print(f"Matched pairs: {matched_pairs}")
    print()

def print_table(filter_ages=None):
    for nation, age_data in nation_age_ratios.items():
        print(f"Nation: {nation} Age-to-Average Kill Ratio Buckets:")
        ages = sorted(age_data.keys())
        avg_ratios = []
        age_vals = []
        for age in ages:
            if filter_ages is not None and age not in filter_ages:
                continue
            ratios = age_data[age]
            avg_ratio = sum(ratios) / len(ratios)
            age_vals.append(age)
            avg_ratios.append(avg_ratio)
            conflicts_sample = ', '.join(sorted(nation_age_conflicts[nation][age]))
            print(f"  Age {age}: Avg Ratio {avg_ratio:.2f} (Conflicts: {conflicts_sample})")
        # Compute correlation if enough data
        if len(age_vals) > 1:
            r, p = pearsonr(age_vals, avg_ratios)
            print(f"Pearson r: {r:.4f}")
            print(f"P-value: {p:.4f}")
        else:
            print("Not enough data for correlation.")
        print()

print_summary()
print_table()

all_ages = set(age for nation in nation_age_ratios for age in nation_age_ratios[nation])
current_ages = all_ages.copy()

while True:
    removed_ages = all_ages - current_ages
    print(f"Currently shown age buckets: {', '.join(map(str, sorted(current_ages))) if current_ages else '(none)'}")
    print(f"Removed age buckets: {', '.join(map(str, sorted(removed_ages))) if removed_ages else '(none)'}")

    user_input = input(
        "Enter command to 'add' or 'remove' age buckets (e.g. 'add 4,7' or 'remove 13'),\n"
        "or press Enter to quit: ").strip().lower()

    if not user_input:
        print("Exiting.")
        break

    parts = user_input.split(maxsplit=1)
    if len(parts) != 2 or parts[0] not in ('add', 'remove'):
        print("Invalid command. Use 'add <ages>' or 'remove <ages>'.")
        continue

    cmd, ages_part = parts
    try:
        ages_to_change = set(int(x.strip()) for x in ages_part.split(','))
    except ValueError:
        print("Invalid age values; please enter comma-separated integers.")
        continue

    if cmd == 'add':
        current_ages.update(ages_to_change)
    elif cmd == 'remove':
        current_ages.difference_update(ages_to_change)

    print_summary()
    print_table(filter_ages=current_ages)
media_rw
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from reportlab.lib.units import inch
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.platypus import Paragraph, Frame

def create_pdf(output_filename):
    # Create a PDF document
    c = canvas.Canvas(output_filename, pagesize=letter)
    width, height = letter

    # Set margins
    left_margin = 1 * inch
    right_margin = width - 1 * inch
    top_margin = height - 1 * inch
    bottom_margin = 0 * inch

    # Set font and size (Times New Roman, 12-point)
    c.setFont("Times-Roman", 12)

    # Add page numbers (starting from page 2)
    def add_page_number(page_num):
        if page_num > 1:  # Suppress page number on the first page
            c.setFont("Times-Roman", 10)
            c.drawCentredString(width / 2, 0.5 * inch, f"{page_num}")

    # Add footer
    def add_footer(page_num):
        footer_y = 0.4 * inch  # Position for footer
        footer_text = "Notice to Court"  # Title of the paper
        c.setFont("Times-Roman", 10)  # Font size for footer
        c.drawCentredString(width / 2, footer_y, footer_text)
        # Draw a line above the footer
        c.line(left_margin, footer_y + 0.1 * inch, right_margin, footer_y + 0.1 * inch)

    # Add line numbers
    def add_line_numbers(start_y, end_y, line_height):
        line_number_x = left_margin - 0.5 * inch  # Position for line numbers
        line_number = 1
        current_y = start_y
        while current_y >= end_y:
            c.drawString(line_number_x, current_y, str(line_number))
            line_number += 1
            current_y -= line_height

    # First Page Format (Rule 2.111)
    # (1) Attorney Information
    c.setFont("Times-Roman", 12)
    attorney_info = [
        "Mark Ingraham",
        "3553 Atlantic Avenue",
        "Long Beach, CA 90807",
        "Telephone: (408) 660-5425",
        "Email: ingrahammark7@gmail.com"
    ]
    y_position = top_margin - 0.5 * inch
    for line in attorney_info:
        c.drawString(left_margin, y_position, line)
        y_position -= 0.25 * inch

    # (2) Clerk's Space (blank space to the right of center)
    c.rect(width / 2 + 0.5 * inch, top_margin - 2 * inch, 2 * inch, 1.5 * inch, stroke=1, fill=0)

    # (3) Court Title
    c.setFont("Times-Bold", 14)
    c.drawCentredString(width / 2, top_margin - 3.33 * inch, "SUPERIOR COURT OF CALIFORNIA")
    c.drawCentredString(width / 2, top_margin - 3.66 * inch, "COUNTY OF SAN FRANCISCO")

    # (4) Case Title
    c.setFont("Times-Bold", 12)
    case_title = [
        "Mark Ingraham,",
        "             Petitioner and Plaintiff,",
        "         v.",
        "Chase Bank",
        "             Respondent and Defendant."
    ]
    y_position = top_margin - 4.75* inch
    counter=0
    for line in case_title:
        c.setFont("Times-Bold",12)
        if counter==1 or counter==4:
        	c.setFont("Times-Roman",12)
        c.drawString(left_margin, y_position, line)
        y_position -= 0.25 * inch
        counter+=1

    # (5) Case Number
    c.setFont("Times-Roman", 12)
    space=width / 2 + 1 * inch
    c.drawString(space, top_margin - 4* inch, "Case Number: CGC-25-625577")
    # (6) Nature of the Paper (moved slightly lower)
    c.setFont("Times-Bold", 12)
    c.drawString(space, top_margin - 4.25* inch, "")
    c.setFont("Times-Bold", 12)
    c.drawString(space, top_margin - 4.5* inch, "Notice to Court")

    # (7) Judge and Department
    c.setFont("Times-Roman", 12)
    c.drawString(space, top_margin - 4.75 * inch, "Judge: ")
    c.drawString(space, top_margin - 5* inch, "Department: ")

   


    # I. INTRODUCTION
    c.setFont("Times-Bold", 12)
    c.drawString(left_margin, y_position - 0.5 * inch, "I. NOTICE")
    c.setFont("Times-Roman", 12)
    c.setFont("Times-Roman", 12)
    intro_text = [
        "1. Court is taking a long time to approve proof of service by mail.",
"2. Court ignores emails.",
"3. Court should explain if they require personal service or otherwise explain delay.",
"4. If Court ignores all communication and doesn't care then case should be dismissed." ,   ]
    y_position -= 1*inch
    for line in intro_text:
        c.drawString(left_margin, y_position, line)
        y_position -= 0.25 * inch



    # Signature Block
    c.setFont("Times-Roman", 12)
    c.drawString(left_margin, y_position - 0.5 * inch, "Submitted,")
    c.drawString(left_margin, y_position - 1 * inch, "Mark Ingraham, 6/11/2025")

 # Add line numbers to the first page
    line_height = 0.25 * inch  # Adjusted to match text spacing
    add_line_numbers(top_margin - 0.5 * inch, bottom_margin + 0.5 * inch, line_height)

    # Add footer (suppressed on the first page)
    add_footer(1)

    # Save the first page
    c.showPage()
    # Save the PDF
    c.save()

if __name__ == "__main__":
    output_filename = "not.pdf"
    create_pdf(output_filename)
    print(f"PDF created: {output_filename}")
media_rw
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from reportlab.lib.units import inch
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.platypus import Paragraph, Frame

def create_pdf(output_filename):
    # Create a PDF document
    c = canvas.Canvas(output_filename, pagesize=letter)
    width, height = letter

    # Set margins
    left_margin = 1 * inch
    right_margin = width - 1 * inch
    top_margin = height - 1 * inch
    bottom_margin = 0 * inch

    # Set font and size (Times New Roman, 12-point)
    c.setFont("Times-Roman", 12)

    # Add page numbers (starting from page 2)
    def add_page_number(page_num):
        if page_num > 1:  # Suppress page number on the first page
            c.setFont("Times-Roman", 10)
            c.drawCentredString(width / 2, 0.5 * inch, f"{page_num}")

    # Add footer
    def add_footer(page_num):
        footer_y = 0.4 * inch  # Position for footer
        footer_text = "Motion for CM/ECF user name and password"  # Title of the paper
        c.setFont("Times-Roman", 10)  # Font size for footer
        c.drawCentredString(width / 2, footer_y, footer_text)
        # Draw a line above the footer
        c.line(left_margin, footer_y + 0.1 * inch, right_margin, footer_y + 0.1 * inch)

    # Add line numbers
    def add_line_numbers(start_y, end_y, line_height):
        line_number_x = left_margin - 0.5 * inch  # Position for line numbers
        line_number = 1
        current_y = start_y
        while current_y >= end_y:
            c.drawString(line_number_x, current_y, str(line_number))
            line_number += 1
            current_y -= line_height

    # First Page Format (Rule 2.111)
    # (1) Attorney Information
    c.setFont("Times-Roman", 12)
    attorney_info = [
        "Mark Ingraham",
        "3553 Atlantic Avenue",
        "Long Beach, CA 90807",
        "Telephone: (408) 660-5425",
        "Email: ingrahammark7@gmail.com"
    ]
    y_position = top_margin - 0.5 * inch
    for line in attorney_info:
        c.drawString(left_margin, y_position, line)
        y_position -= 0.25 * inch

    # (2) Clerk's Space (blank space to the right of center)
    c.rect(width / 2 + 0.5 * inch, top_margin - 2 * inch, 2 * inch, 1.5 * inch, stroke=1, fill=0)

    # (3) Court Title
    c.setFont("Times-Bold", 14)
    c.drawCentredString(width / 2, top_margin - 3.33 * inch, "UNITED STATES DISTRICT COURT")
    c.drawCentredString(width / 2, top_margin - 3.66 * inch, "CENTRAL DISTRICT OF CALIFORNIA")

    # (4) Case Title
    c.setFont("Times-Bold", 12)
    case_title = [
        "Mark Ingraham,",
        "             Petitioner and Plaintiff,",
        "         v.",
        "Office of the Comptroller of the Currency",
        "of the United States Department of the Treasury",
        "             Respondent and Defendant."
    ]
    y_position = top_margin - 4.75* inch
    counter=0
    for line in case_title:
        c.setFont("Times-Bold",12)
        if counter==1 or counter==5:
        	c.setFont("Times-Roman",12)
        c.drawString(left_margin, y_position, line)
        y_position -= 0.25 * inch
        counter+=1

    # (5) Case Number
    c.setFont("Times-Roman", 12)
    space=width / 2 + 1 * inch
    c.drawString(space, top_margin - 4* inch, "Case Number:")
    # (6) Nature of the Paper (moved slightly lower)
    c.setFont("Times-Bold", 12)
    c.drawString(space, top_margin - 4.25* inch, "")
    c.setFont("Times-Bold", 12)
    c.drawString(space, top_margin - 4.5* inch, "Motion for CM/ECF username and password")

    # (7) Judge and Department
    c.setFont("Times-Roman", 12)
    c.drawString(space, top_margin - 4.75 * inch, "Judge: ")
    c.drawString(space, top_margin - 5* inch, "Department: ")

   


    # I. INTRODUCTION
    c.setFont("Times-Bold", 12)
    c.drawString(left_margin, y_position - 0.5 * inch, "I. Motion for CM/ECF user name and password")
    c.setFont("Times-Roman", 12)
    c.setFont("Times-Roman", 12)
    intro_text = [
        "1. Petitioner, Mark Ingraham, petitions this Court for a CM/ECF user name and password.",
        "2. Account will be used to file documents on PACER.",
              "3. Petitioner has regular access to the internet, has the capacity to regularly file and view documents", "electronically, and has completed the Clerk's Office tutorial.",
        ]
    y_position -= 1*inch
    for line in intro_text:
        c.drawString(left_margin, y_position, line)
        y_position -= 0.25 * inch



    # Signature Block
    c.setFont("Times-Roman", 12)
    c.drawString(left_margin, y_position - 0.5 * inch, "Submitted,")
    c.drawString(left_margin, y_position - 1 * inch, "Mark Ingraham, 2/15/2025")

 # Add line numbers to the first page
    line_height = 0.25 * inch  # Adjusted to match text spacing
    add_line_numbers(top_margin - 0.5 * inch, bottom_margin + 0.5 * inch, line_height)

    # Add footer (suppressed on the first page)
    add_footer(1)

    # Save the first page
    c.showPage()
    # Save the PDF
    c.save()

if __name__ == "__main__":
    output_filename = "ecfd.pdf"
    create_pdf(output_filename)
    print(f"PDF created: {output_filename}")
media_rw
#!/usr/bin/env python3
import sys
import os
import re
import textwrap
import ast
import astunparse  # Install with: pip install astunparse
import subprocess  # To execute the bash command

def split_game_txt(input_file="game.txt"):
    """Splits game.txt into individual Python files based on class definitions."""
    try:
        with open(input_file, "r") as f:
            content = f.read()
        sections = content.split("media_rw")
        class_content_map = {}
        for section in sections:
            section = section.strip()
            if not section:
                continue
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                class_content_map[class_name] = section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as pyfile:
                pyfile.write(content)
            print(f"Created: {class_name}.py")
        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """Rebuilds game.txt by concatenating all .py files in the current directory."""
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as outfile:
            for py_file in py_files:
                with open(py_file, "r") as f:
                    content = f.read()
                    outfile.write("media_rw\n")
                    outfile.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def combine_files(input1, input2, output):
    """
    Combines two Python files into one output file.

    A fake class wrapper ("class Foo:") is added to temp2.txt if necessary
    to ensure proper AST parsing. After merging, the fake class is removed
    entirely from the final result using a bash command.

    Args:
        input1 (str): Path to the first input file (e.g., temp1.txt).
        input2 (str): Path to the second input file (e.g., temp2.txt).
        output (str): Path for the output file (e.g., result.txt).
    """
    if not os.path.exists(input1) or not os.path.exists(input2):
        print(f"Error: One or both input files do not exist.")
        return

    try:
        # Normalize both input files for consistent indentation
        norm1 = normalize_indentation(input1)
        norm2 = normalize_indentation(input2)

        # Add a fake wrapper to temp2.txt if needed
        tree2 = parse_with_fake_wrapper(norm2, input2)
        tree1 = ast.parse(norm1, filename=input1)

        # Merge the trees
        merged_tree = merge_ast(tree1, tree2)

        # Convert the merged AST back to Python code
        merged_code = astunparse.unparse(merged_tree)

        # Write the merged code to the output file
        with open(output, "w") as out:
            out.write(merged_code)

        # Run a bash command to remove any line containing "foo" or "Foo"
        remove_lines_with_foo(output)

        print(f"Successfully combined '{input1}' and '{input2}' into '{output}'.")
    except Exception as e:
        print(f"An error occurred during combination: {e}")

def normalize_indentation(file_path):
    """
    Reads a file and ensures consistent 4-space indentation.

    Args:
        file_path (str): Path to the file to normalize.

    Returns:
        str: The normalized file content as a string.
    """
    try:
        with open(file_path, "r") as f:
            lines = f.readlines()
        # Replace tabs with 4 spaces and remove trailing whitespace.
        norm_lines = [line.replace("\t", "    ").rstrip() for line in lines]
        return "\n".join(norm_lines)
    except Exception as e:
        raise RuntimeError(f"Failed to normalize indentation for {file_path}: {e}")

def parse_with_fake_wrapper(content, filename):
    """
    Ensures the content of the second file is parsable by wrapping it in a fake class
    if necessary.

    Args:
        content (str): The file content as a string.
        filename (str): The file name for reference.

    Returns:
        ast.Module: The parsed AST, with a fake wrapper if applied.
    """
    stripped_content = content.lstrip()
    if stripped_content and not stripped_content.startswith(" "):
        # Add a fake wrapper to ensure proper indentation for parsing
        wrapped_content = "class Foo:\n" + "\n".join("    " + line for line in content.splitlines())
        tree_with_wrapper = ast.parse(wrapped_content, filename=filename)
        print("Applied fake class wrapper to ensure parsing of input2.")
        return tree_with_wrapper
    return ast.parse(content, filename=filename)

def remove_lines_with_foo(file_path):
    """
    Removes any line containing "foo" or "Foo" (case-insensitive) using a bash command.

    Args:
        file_path (str): Path to the file to modify.
    """
    try:
        command = f"sed -i '/[Ff][Oo][Oo]/d' {file_path}"
        subprocess.run(command, shell=True, check=True)
        print("Removed all lines containing 'foo' or 'Foo' from the result file.")
    except Exception as e:
        raise RuntimeError(f"Failed to remove lines containing 'foo' or 'Foo' from {file_path}: {e}")

def merge_ast(tree1, tree2):
    """
    Merges two ASTs by appending elements from tree2 into tree1.

    If tree2 contains function definitions (methods) and tree1 ends with a class,
    those functions are appended to the body of the last class in tree1.

    Args:
        tree1 (ast.Module): The AST of the first file.
        tree2 (ast.Module): The AST of the second file.

    Returns:
        ast.Module: The merged AST.
    """
    if not isinstance(tree1, ast.Module) or not isinstance(tree2, ast.Module):
        raise ValueError("Both ASTs must be ast.Module instances.")

    body1 = tree1.body
    body2 = tree2.body

    # If the last element of tree1 is a class definition, append functions from tree2 to it.
    if body1 and isinstance(body1[-1], ast.ClassDef):
        class_node = body1[-1]
        for node in body2:
            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                class_node.body.append(node)
            else:
                body1.append(node)
    else:
        body1.extend(body2)

    return tree1

def main():
    import argparse
    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from the individual .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Output path for game.txt")

    # Combine command
    combine_parser = subparsers.add_parser("combine", help="Combine two files into one result file.")
    combine_parser.add_argument("--input1", type=str, required=True, help="Path to the first input file (e.g., temp1.txt)")
    combine_parser.add_argument("--input2", type=str, required=True, help="Path to the second input file (e.g., temp2.txt)")
    combine_parser.add_argument("--output", type=str, default="result.txt", help="Output file path (e.g., result.txt)")

    args = parser.parse_args()
    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "combine":
        combine_files(args.input1, args.input2, args.output)
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
media_rw
import json
from collections import defaultdict
from scipy.stats import pearsonr

# Load your JSON files (from current directory or wherever you run this)
with open('f1.json') as f1_file:
    data_f1 = json.load(f1_file)
with open('f2.json') as f2_file:
    data_f2 = json.load(f2_file)
with open('f3.json') as f3_file:
    data_f3 = json.load(f3_file)

fighter_stats = data_f1.get('fighter_stats', {})
conflicts = data_f3

# Map conflict name to start year for quick lookup
conflict_year_map = {}
for cname, cdata in conflicts.items():
    start = cdata.get('start')
    if start is not None:
        conflict_year_map[cname] = start

def get_nation(fighter):
    info = data_f2.get(fighter, {})
    return info.get('nation')

nation_age_ratios = defaultdict(lambda: defaultdict(list))
nation_age_conflicts = defaultdict(lambda: defaultdict(set))

year_nation_kills = defaultdict(lambda: defaultdict(float))
year_nation_weighted_age = defaultdict(lambda: defaultdict(float))

total_pairs = 0
skipped_no_in_service = 0
skipped_no_conflict_year = 0
skipped_zero_kills_losses = 0
skipped_negative_age = 0
matched_pairs = 0

for fighter, conflicts_data in fighter_stats.items():
    in_service = data_f2.get(fighter, {}).get('in_service')
    nation = get_nation(fighter)
    if in_service is None or nation is None:
        skipped_no_in_service += 1
        continue
    for conflict_name, stats in conflicts_data.items():
        if conflict_name == "Total":
            continue
        start_year = conflict_year_map.get(conflict_name)
        if start_year is None:
            skipped_no_conflict_year += 1
            continue
        kills = stats.get('Kills', 0)
        losses = stats.get('Loss', 0)
        total_pairs += 1
        if kills == 0 and losses == 0:
            skipped_zero_kills_losses += 1
            continue
        age = start_year - in_service
        if age < 0:
            skipped_negative_age += 1
            continue
        kill_ratio = kills / losses if losses > 0 else kills
        if kill_ratio == 0:
            continue
        matched_pairs += 1
        nation_age_ratios[nation][age].append(kill_ratio)
        if len(nation_age_conflicts[nation][age]) < 3:
            nation_age_conflicts[nation][age].add(conflict_name)

        year_nation_kills[start_year][nation] += kills
        year_nation_weighted_age[start_year][nation] += kills * age

def print_summary():
    print(f"Total (fighter, conflict) pairs: {total_pairs}")
    print(f"Skipped no in_service or nation: {skipped_no_in_service}")
    print(f"Skipped no conflict year: {skipped_no_conflict_year}")
    print(f"Skipped zero kills or losses: {skipped_zero_kills_losses}")
    print(f"Skipped negative age: {skipped_negative_age}")
    print(f"Matched pairs: {matched_pairs}")
    print()

def print_table(filter_ages=None):
    for nation, age_data in nation_age_ratios.items():
        print(f"Nation: {nation} Age-to-Average Kill Ratio Buckets:")
        ages = sorted(age_data.keys())
        avg_ratios = []
        age_vals = []
        for age in ages:
            if filter_ages is not None and age not in filter_ages:
                continue
            ratios = age_data[age]
            avg_ratio = sum(ratios) / len(ratios)
            age_vals.append(age)
            avg_ratios.append(avg_ratio)
            conflicts_sample = ', '.join(sorted(nation_age_conflicts[nation][age]))
            print(f"  Age {age}: Avg Ratio {avg_ratio:.2f} (Conflicts: {conflicts_sample})")
        if len(age_vals) > 1:
            r, p = pearsonr(age_vals, avg_ratios)
            print(f"Pearson r: {r:.4f}")
            print(f"P-value: {p:.4f}")
        else:
            print("Not enough data for correlation.")
        print()

def compute_difficulty_factor(filter_years=None):
    print("Difficulty factors by year and side (weighted average aircraft age):")
    side_nations = {
        'USA': ['USA'],
        'USSR+France': ['USSR', 'France']
    }

    years = sorted(year_nation_kills.keys())
    if filter_years is not None:
        years = [y for y in years if y in filter_years]

    for year in years:
        total_kills = 0
        side_kills = {}
        side_avg_age = {}
        for side, nations in side_nations.items():
            kills = sum(year_nation_kills[year].get(n, 0) for n in nations)
            total_kills += kills
            side_kills[side] = kills

        if total_kills == 0:
            continue

        for side, nations in side_nations.items():
            weighted_age_sum = sum(year_nation_weighted_age[year].get(n, 0) for n in nations)
            kills_sum = sum(year_nation_kills[year].get(n, 0) for n in nations)
            avg_age = weighted_age_sum / kills_sum if kills_sum > 0 else 0
            side_avg_age[side] = avg_age

        print(f"Year {year}:")
        for side in side_nations:
            print(f"  {side} Difficulty Factor (Avg Aircraft Age): {side_avg_age[side]:.2f}")
    print()

print_summary()
print_table()

all_ages = set(age for nation in nation_age_ratios for age in nation_age_ratios[nation])
current_ages = all_ages.copy()

all_difficulty_years = set(year_nation_kills.keys())
current_difficulty_years = all_difficulty_years.copy()

compute_difficulty_factor(filter_years=current_difficulty_years)

# User interaction loop for filtering
while True:
    removed_ages = all_ages - current_ages
    removed_difficulty_years = all_difficulty_years - current_difficulty_years

    print(f"Currently shown age buckets: {', '.join(map(str, sorted(current_ages))) if current_ages else '(none)'}")
    print(f"Removed age buckets: {', '.join(map(str, sorted(removed_ages))) if removed_ages else '(none)'}")
    print(f"Currently shown difficulty years: {', '.join(map(str, sorted(current_difficulty_years))) if current_difficulty_years else '(none)'}")
    print(f"Removed difficulty years: {', '.join(map(str, sorted(removed_difficulty_years))) if removed_difficulty_years else '(none)'}")

    user_input = input(
        "Enter command:\n"
        "  'add <ages>', 'remove <ages>' to filter kill ratio ages\n"
        "  'adddif <years>', 'removedif <years>' to filter difficulty factor years\n"
        "or press Enter to quit: ").strip().lower()

    if not user_input:
        print("Exiting.")
        break

    parts = user_input.split(maxsplit=1)
    if len(parts) != 2 or parts[0] not in ('add', 'remove', 'adddif', 'removedif'):
        print("Invalid command. Use 'add <values>', 'remove <values>', 'adddif <values>' or 'removedif <values>'.")
        continue

    cmd, values_part = parts
    try:
        values_to_change = set(int(x.strip()) for x in values_part.split(','))
    except ValueError:
        print("Invalid values; please enter comma-separated integers.")
        continue

    if cmd == 'add':
        current_ages.update(values_to_change)
    elif cmd == 'remove':
        current_ages.difference_update(values_to_change)
    elif cmd == 'adddif':
        current_difficulty_years.update(values_to_change)
    elif cmd == 'removedif':
        current_difficulty_years.difference_update(values_to_change)

    print_summary()
    print_table(filter_ages=current_ages)
    
    
import numpy as np
from sklearn.linear_model import LinearRegression

# First, collect difficulty factors per year & side in dicts for reuse
side_nations = {
    'Capitalism': ['USA'],
    'Communism': ['USSR', 'France']
}

years = sorted(year_nation_kills.keys())

# Build dictionaries of difficulty factors by year and side
difficulty_by_year_side = {}
kill_ratios_by_year_side = {}

for year in years:
    difficulty_by_year_side[year] = {}
    kill_ratios_by_year_side[year] = {}
    for side, nations in side_nations.items():
        kills = sum(year_nation_kills[year].get(n, 0) for n in nations)
        weighted_age_sum = sum(year_nation_weighted_age[year].get(n, 0) for n in nations)
        avg_age = weighted_age_sum / kills if kills > 0 else 0
        difficulty_by_year_side[year][side] = avg_age

        # For kill ratio per side, sum kills and sum losses (loss data is not in your snippet, 
        # so we will approximate kill ratio as total kills for now)
        # If you want accurate kill ratios, you'd need losses data similarly aggregated
        kill_ratios_by_year_side[year][side] = kills  # using kills as proxy for kill ratio here

# Filter years where both sides have nonzero difficulty
filtered_years = [y for y in years if difficulty_by_year_side[y]['Capitalism'] > 0 and difficulty_by_year_side[y]['Communism'] > 0]

print("Year | Difficulty Diff (Communism - Capitalism) | Difficulty Ratio (Communism / Capitalism) | Capitalism Kills | Communism Kills")
diff_list = []
ratio_list = []
cap_kill_ratios = []
com_kill_ratios = []
for y in filtered_years:
    diff = difficulty_by_year_side[y]['Communism'] - difficulty_by_year_side[y]['Capitalism']
    ratio = difficulty_by_year_side[y]['Communism'] / difficulty_by_year_side[y]['Capitalism']
    cap_kills = kill_ratios_by_year_side[y]['Capitalism']
    com_kills = kill_ratios_by_year_side[y]['Communism']
    print(f"{y} | {diff:.3f} | {ratio:.3f} | {cap_kills:.1f} | {com_kills:.1f}")

    diff_list.append(diff)
    ratio_list.append(ratio)
    cap_kill_ratios.append(cap_kills)
    com_kill_ratios.append(com_kills)

# Convert lists to numpy arrays for regression
X_diff = np.array(diff_list).reshape(-1, 1)
X_ratio = np.array(ratio_list).reshape(-1, 1)

# Function to run linear regression and print results
def run_regression(X, y, side_name, var_name):
    model = LinearRegression()
    model.fit(X, y)
    r_sq = model.score(X, y)
    coef = model.coef_[0]
    intercept = model.intercept_
    print(f"\nRegression of {side_name} kill count on {var_name}:")
    print(f"  R^2: {r_sq:.3f}")
    print(f"  Coefficient: {coef:.3f}")
    print(f"  Intercept: {intercept:.3f}")

print("\n--- Regression Results ---")
run_regression(X_diff, np.array(cap_kill_ratios), 'Capitalism', 'difficulty difference')
run_regression(X_ratio, np.array(cap_kill_ratios), 'Capitalism', 'difficulty ratio')

run_regression(X_diff, np.array(com_kill_ratios), 'Communism', 'difficulty difference')
run_regression(X_ratio, np.array(com_kill_ratios), 'Communism', 'difficulty ratio')

compute_difficulty_factor(filter_years=current_difficulty_years)
media_rw
import json
from collections import defaultdict
from scipy.stats import pearsonr

# Load your JSON files (assumes they are in the same directory)
with open('f1.json') as f1_file:
    data_f1 = json.load(f1_file)
with open('f2.json') as f2_file:
    data_f2 = json.load(f2_file)
with open('f3.json') as f3_file:
    data_f3 = json.load(f3_file)

fighter_stats = data_f1['fighter_stats']
conflicts = data_f3

# Map conflict name to start year for quick lookup
conflict_year_map = {}
for cname, cdata in conflicts.items():
    start = cdata.get('start')
    if start is not None:
        conflict_year_map[cname] = start

# Helper function: get nation of a fighter
def get_nation(fighter):
    info = data_f2.get(fighter, {})
    return info.get('nation')

# Collect kill ratios by nation and age
nation_age_ratios = defaultdict(lambda: defaultdict(list))
nation_age_conflicts = defaultdict(lambda: defaultdict(set))

# Yearly kills and weighted age sums for difficulty factor
year_nation_kills = defaultdict(lambda: defaultdict(float))
year_nation_weighted_age = defaultdict(lambda: defaultdict(float))

# Debug counters
total_pairs = 0
skipped_no_in_service = 0
skipped_no_conflict_year = 0
skipped_zero_kills_losses = 0
skipped_negative_age = 0
matched_pairs = 0

for fighter, conflicts_data in fighter_stats.items():
    in_service = data_f2.get(fighter, {}).get('in_service')
    nation = get_nation(fighter)
    if in_service is None or nation is None:
        skipped_no_in_service += 1
        continue
    for conflict_name, stats in conflicts_data.items():
        if conflict_name == "Total":
            continue  # Skip totals
        start_year = conflict_year_map.get(conflict_name)
        if start_year is None:
            skipped_no_conflict_year += 1
            continue
        kills = stats.get('Kills', 0)
        losses = stats.get('Loss', 0)
        total_pairs += 1
        if kills == 0 and losses == 0:
            skipped_zero_kills_losses += 1
            continue
        age = start_year - in_service
        if age < 0:
            skipped_negative_age += 1
            continue
        kill_ratio = kills / losses if losses > 0 else kills
        if kill_ratio == 0:
            continue
        matched_pairs += 1
        nation_age_ratios[nation][age].append(kill_ratio)
        if len(nation_age_conflicts[nation][age]) < 3:
            nation_age_conflicts[nation][age].add(conflict_name)

        # Track kills and weighted age sums for difficulty factor
        year_nation_kills[start_year][nation] += kills
        year_nation_weighted_age[start_year][nation] += kills * age

def print_summary():
    print(f"Total (fighter, conflict) pairs: {total_pairs}")
    print(f"Skipped no in_service or nation: {skipped_no_in_service}")
    print(f"Skipped no conflict year: {skipped_no_conflict_year}")
    print(f"Skipped zero kills or losses: {skipped_zero_kills_losses}")
    print(f"Skipped negative age: {skipped_negative_age}")
    print(f"Matched pairs: {matched_pairs}")
    print()
media_rw
import cv2
import numpy as np
import serial
import time

# --- Bluetooth serial setup ---
# Replace 'COM3' with your Bluetooth serial port (Windows) or '/dev/rfcomm0' on Linux
bt_port = 'COM3'
bt_baud = 9600
try:
    bt_serial = serial.Serial(bt_port, bt_baud, timeout=1)
except serial.SerialException:
    print("Bluetooth serial port not found or busy.")
    bt_serial = None

# --- OpenCV video capture ---
cap = cv2.VideoCapture(0)  # Use 0 for default webcam or replace with video file

def send_command(cmd):
    if bt_serial and bt_serial.is_open:
        bt_serial.write(cmd.encode())
        print(f"Sent command: {cmd}")

def process_frame(frame):
    # Convert to grayscale and blur
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(gray, (15, 15), 0)

    # Threshold to get bright areas (simulate target detection)
    _, thresh = cv2.threshold(blur, 200, 255, cv2.THRESH_BINARY)

    # Find contours
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    if contours:
        # Find largest contour
        largest = max(contours, key=cv2.contourArea)
        (x, y), radius = cv2.minEnclosingCircle(largest)

        # Draw circle on frame
        cv2.circle(frame, (int(x), int(y)), int(radius), (0, 255, 0), 2)

        # Calculate offset from center
        height, width = frame.shape[:2]
        offset_x = x - width / 2
        offset_y = y - height / 2

        # Determine steering commands based on offset thresholds
        steer_cmd = ''
        thresh_offset = 30  # pixels

        if offset_x > thresh_offset:
            steer_cmd += 'R'  # Turn Right
        elif offset_x < -thresh_offset:
            steer_cmd += 'L'  # Turn Left

        if offset_y > thresh_offset:
            steer_cmd += 'D'  # Pitch Down
        elif offset_y < -thresh_offset:
            steer_cmd += 'U'  # Pitch Up

        if steer_cmd:
            send_command(steer_cmd)

    return frame

try:
    while True:
        ret, frame = cap.read()
        if not ret:
            break

        frame = process_frame(frame)

        cv2.imshow('Target Tracking', frame)
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

except KeyboardInterrupt:
    pass

finally:
    if bt_serial:
        bt_serial.close()
    cap.release()
    cv2.destroyAllWindows()
media_rw
import re
from math import sqrt

# Helper function to safely load Python dicts from files
def load_dict_from_file(filename):
    with open(filename, 'r', encoding='utf-8') as f:
        content = f.read()
    # Use eval since file is a python dict string; be careful in real apps
    data = eval(content)
    return data

# Improved caliber parser to accept '20mm' or '20 mm'
def parse_caliber(gun_str):
    if not gun_str or not isinstance(gun_str, str):
        return None
    m = re.search(r'(\d+(?:\.\d+)?)\s*mm', gun_str.lower())
    if m:
        try:
            return float(m.group(1))
        except ValueError:
            return None
    return None

# Pearson correlation coefficient calculation
def pearson_corr(x, y):
    n = len(x)
    if n < 2:
        return None
    mean_x = sum(x) / n
    mean_y = sum(y) / n
    numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))
    denominator_x = sqrt(sum((xi - mean_x) ** 2 for xi in x))
    denominator_y = sqrt(sum((yi - mean_y) ** 2 for yi in y))
    if denominator_x == 0 or denominator_y == 0:
        return None
    return numerator / (denominator_x * denominator_y)

def main():
    # Load fighter stats and fighter info
    print("Loading file: f1.txt")
    fighter_stats_data = load_dict_from_file("f1.txt")
    print(f"Loaded {len(fighter_stats_data.get('fighter_stats', {}))} fighters from f1.txt")

    print("Loading file: f2.txt")
    fighters_info = load_dict_from_file("f2.txt")
    print(f"Loaded {len(fighters_info)} fighters info from f2.txt")

    # Keys samples for debug
    print(f"fighter_stats keys sample: {list(fighter_stats_data.get('fighter_stats', {}).keys())[:5]}")
    print(f"fighters keys sample: {list(fighters_info.keys())[:5]}")

    kills_list = []
    caliber_list = []
    details = []

    print("\nProcessing fighters to extract kills and gun caliber...\n")

    for fighter_name, stats in fighter_stats_data.get('fighter_stats', {}).items():
        fighter_info = fighters_info.get(fighter_name)
        if not fighter_info:
            print(f"  No fighter info found for '{fighter_name}' in f2.txt")
            continue
        gun = fighter_info.get('gun')
        if not gun:
            print(f"  Fighter '{fighter_name}' has no 'gun' field in f2.txt")
            continue

        caliber = parse_caliber(gun)
        if caliber is None:
            print(f"  Could not parse caliber from gun '{gun}' for fighter '{fighter_name}'")
            continue

        # Sum kills from all conflicts under fighter_stats[fighter_name]
        total_kills = 0
        for conflict, conflict_stats in stats.items():
            if conflict == "Total":
                # Use total if available (safer, less prone to summation errors)
                total_kills = conflict_stats.get("Kills", 0)
                break
        else:
            # If no Total, sum manually
            for conflict_stats in stats.values():
                total_kills += conflict_stats.get("Kills", 0)

        kills_list.append(total_kills)
        caliber_list.append(caliber)
        details.append((fighter_name, gun, caliber, total_kills))

    print(f"Total valid data points: {len(kills_list)}\n")

    if len(kills_list) < 2:
        print("Not enough data points to compute correlation.")
        return

    r = pearson_corr(kills_list, caliber_list)
    if r is None:
        print("Could not compute correlation (division by zero).")
        return

    print(f"Pearson correlation coefficient (Kills vs Gun Caliber): {r:.4f}\n")

    # Print table header
    print(f"{'Fighter':<15} {'Gun':<20} {'Caliber':<8} {'Kills':<5}")
    print("-" * 55)
    for fighter_name, gun, caliber, total_kills in details:
        print(f"{fighter_name:<15} {gun:<20} {caliber:<8.1f} {total_kills:<5}")

if __name__ == "__main__":
    main()
media_rw
from collections import defaultdict

class FRKM:
    def __init__(self, fighter_stats, fighter_info, year_nation_kills, nation_age_ratios, difficulty_by_year):
        """
        fighter_stats: dict from F1.json (fighter  conflict  stats)
        fighter_info: dict from F2.json (fighter  metadata)
        year_nation_kills: dict year  nation  kills
        nation_age_ratios: dict nation  age  ratios
        difficulty_by_year: dict year  side  difficulty factor (age)
        """
        self.fighter_stats = fighter_stats
        self.fighter_info = fighter_info
        self.year_nation_kills = year_nation_kills
        self.nation_age_ratios = nation_age_ratios
        self.difficulty_by_year = difficulty_by_year

        # Precompute side membership for nations (example USA/USSR+France)
        self.side_map = {
            'USA': ['USA'],
            'USSR+France': ['USSR', 'France']
        }

    def _compute_kill_ratios(self):
        """
        Computes kill/loss ratios per fighter aircraft over all conflicts.
        Returns dict fighter -> {'kills': int, 'losses': int, 'ratio': float}
        """
        results = {}
        for fighter, conflicts in self.fighter_stats.items():
            total_kills = 0
            total_losses = 0
            for conflict, stats in conflicts.items():
                total_kills += stats.get('Kills', 0)
                total_losses += stats.get('Loss', 0)
            ratio = (total_kills / total_losses) if total_losses > 0 else float('inf') if total_kills > 0 else 0
            results[fighter] = {
                'kills': total_kills,
                'losses': total_losses,
                'ratio': ratio
            }
        return results

    def _compute_enemy_aircraft_mix(self):
        """
        For each year, calculates the mix (%) of enemy aircraft types engaged.
        Returns dict year -> dict fighter -> percentage (0-100)
        """
        # This requires access to detailed year+fighter kill or engagement data.
        # Assuming that fighter_stats does not have year info, this is a stub.
        # User must provide or link data with year info externally.
        # For demo, returning empty dict.
        return {}

    def _control_for_difficulty(self, kill_ratios):
        """
        Adjust kill ratios by factoring out difficulty (age).
        For demo, just normalize by average difficulty factor across all years.
        """
        # Average difficulty factor USA side for example:
        avg_difficulty = 0
        count = 0
        for year, sides in self.difficulty_by_year.items():
            if 'USA' in sides:
                avg_difficulty += sides['USA']
                count += 1
        avg_difficulty = avg_difficulty / count if count > 0 else 1

        adjusted_ratios = {}
        for fighter, data in kill_ratios.items():
            # Adjust ratio dividing by difficulty to "partial out" age effect
            adjusted_ratio = data['ratio'] / avg_difficulty if avg_difficulty != 0 else data['ratio']
            adjusted_ratios[fighter] = {
                **data,
                'adjusted_ratio': adjusted_ratio
            }
        return adjusted_ratios

    def print_tables(self):
        """
        Prints tables for each aircraft with:
          - raw kill ratio
          - adjusted kill ratio (controlling for difficulty/age)
          - enemy aircraft mix (if available)
        """
        kill_ratios = self._compute_kill_ratios()
        adjusted = self._control_for_difficulty(kill_ratios)
        enemy_mix = self._compute_enemy_aircraft_mix()  # stub returns empty

        print("Kill Ratios and Adjusted Kill Ratios per Aircraft:\n")
        print(f"{'Aircraft':10} | {'Kills':5} | {'Losses':6} | {'Ratio':7} | {'Adj. Ratio':10} | Enemy Mix")
        print("-"*70)
        for fighter, data in adjusted.items():
            mix_str = "N/A"
            # In real use, get enemy mix for relevant years, summarized here as N/A
            print(f"{fighter:10} | {data['kills']:5} | {data['losses']:6} | {data['ratio']:7.2f} | {data['adjusted_ratio']:10.2f} | {mix_str}")
        print()
media_rw
import json
from collections import defaultdict
from sklearn.linear_model import LinearRegression
import numpy as np

# === Load JSON data ===
with open('F1.json') as f:
    fighter_stats = json.load(f)['fighter_stats']

with open('F2.json') as f:
    aircraft_info = json.load(f)

with open('F3.json') as f:
    conflict_years = json.load(f)

# === Prepare year_nation_kills and year_nation_weighted_age ===
year_nation_kills = defaultdict(lambda: defaultdict(int))
year_nation_weighted_age = defaultdict(lambda: defaultdict(float))

for ac, conflicts in fighter_stats.items():
    ac_info = aircraft_info.get(ac)
    if not ac_info:
        continue
    nation = ac_info.get('nation')
    in_service_year = ac_info.get('in_service')
    if not nation or in_service_year is None:
        continue
    for conflict, stats in conflicts.items():
        year = conflict_years.get(conflict, {}).get('start')
        if not year:
            continue
        kills = stats.get('Kills', 0)
        year_nation_kills[year][nation] += kills
        age = year - in_service_year
        if age < 0:
            age = 0
        year_nation_weighted_age[year][nation] += age * kills

# === Define sides and their nations ===
side_nations = {
    'USA': ['USA'],
    'USSR+France': ['USSR', 'France']
}

nation_to_side = {}
for side, nations in side_nations.items():
    for n in nations:
        nation_to_side[n] = side

# === Compute difficulty factors per year and side ===
difficulty_by_year = {}
for year in sorted(year_nation_kills.keys()):
    total_kills = sum(year_nation_kills[year].values())
    if total_kills == 0:
        continue
    side_ages = {}
    for side, nations in side_nations.items():
        kills = sum(year_nation_kills[year].get(n, 0) for n in nations)
        weighted_age = sum(year_nation_weighted_age[year].get(n, 0) for n in nations)
        side_ages[side] = weighted_age / kills if kills > 0 else 0
    difficulty_by_year[year] = side_ages

# === Build aircraft to side map ===
ac_to_side = {}
for ac, info in aircraft_info.items():
    nation = info.get('nation')
    if nation in nation_to_side:
        ac_to_side[ac] = nation_to_side[nation]

# === Collect kills per aircraft per year (needed for opponent mix) ===
year_ac_kills = defaultdict(lambda: defaultdict(int))  # year -> ac -> kills

for ac, conflicts in fighter_stats.items():
    for conflict, stats in conflicts.items():
        year = conflict_years.get(conflict, {}).get('start')
        if not year:
            continue
        kills = stats.get('Kills', 0)
        year_ac_kills[year][ac] += kills

# === Compute opponent mix helper function ===
def compute_opponent_mix(ac, year):
    ac_side = ac_to_side.get(ac)
    if not ac_side:
        return {}

    opponent_sides = [side for side in side_nations if side != ac_side]
    opponent_acs = [a for a, s in ac_to_side.items() if s in opponent_sides]

    total_opponent_kills = sum(year_ac_kills[year].get(a, 0) for a in opponent_acs)
    if total_opponent_kills == 0:
        return {}

    mix = {}
    for opp_ac in opponent_acs:
        kills = year_ac_kills[year].get(opp_ac, 0)
        if kills > 0:
            mix[opp_ac] = kills / total_opponent_kills
    return mix

# === Build regression model for kill ratio vs difficulty ===
def build_regression_model():
    X = []
    y = []
    for ac, conflicts in fighter_stats.items():
        side = ac_to_side.get(ac)
        if not side:
            continue
        for conflict, stats in conflicts.items():
            year = conflict_years.get(conflict, {}).get('start')
            if not year:
                continue
            difficulty = difficulty_by_year.get(year, {}).get(side)
            if difficulty is None:
                continue
            kills = stats.get('Kills', 0)
            losses = stats.get('Loss', 0)
            if kills == 0 and losses == 0:
                continue
            if losses == 0:
                kill_ratio = kills
            else:
                kill_ratio = kills / losses
            X.append([difficulty])
            y.append(kill_ratio)
    if not X:
        return None
    model = LinearRegression()
    model.fit(X, y)
    return model

# === Load year filter from temp.txt ===
def load_year_filter_from_temp():
    try:
        with open('temp.txt', 'r') as f:
            lines = f.readlines()
            years = set(int(line.strip()) for line in lines if line.strip().isdigit())
            if years:
                return years
    except Exception as e:
        print(f"WARNING: Could not read year filter from temp.txt: {e}")
    return None  # No filter means include all

# === Main function to compute and display residual kill ratios with opponent mix ===
def print_residual_kill_tables():
    print("Residual Kill Ratio Tables Per Aircraft\n")
    model = build_regression_model()
    year_filter = load_year_filter_from_temp()
    print(year_filter)
    print("foo")
    for ac in sorted(fighter_stats.keys()):
        ac_info = aircraft_info.get(ac, {})
        nation = ac_info.get('nation', 'Unknown')
        in_service = ac_info.get('in_service', '?')
        side = ac_to_side.get(ac)
        if not side:
            continue

        print(f"Aircraft: {ac} (Nation: {nation}, In-Service Year: {in_service})")
        header = f"{'Year':>6} | {'Kills':>5} | {'Losses':>7} | {'Kill Ratio':>10} | {'Difficulty':>10} | {'Residual':>10} | Opponent Mix (AC: %)"
        print(header)
        print("-" * len(header))

        any_data = False
        for conflict, stats in fighter_stats[ac].items():
            year = conflict_years.get(conflict, {}).get('start')
            if not year:
                continue
            if year_filter is not None and year not in year_filter:
                # Skip years not in filter
                continue

            kills = stats.get('Kills', 0)
            losses = stats.get('Loss', 0)
            if kills == 0 and losses == 0:
                continue
            if losses == 0:
                kill_ratio = kills
            else:
                kill_ratio = kills / losses

            difficulty = difficulty_by_year.get(year, {}).get(side)
            expected = model.predict([[difficulty]])[0] if model and difficulty is not None else None
            residual = kill_ratio - expected if expected is not None else None

            diff_str = f"{difficulty:10.3f}" if difficulty is not None else " " * 10
            resid_str = f"{residual:10.3f}" if residual is not None else " " * 10

            mix = compute_opponent_mix(ac, year)
            mix_str = ', '.join(f"{opp_ac}:{pct*100:.1f}%" for opp_ac, pct in sorted(mix.items(), key=lambda x: x[1], reverse=True))

            print(f"{year:6} | {kills:5} | {losses:7} | {kill_ratio:10.3f} | {diff_str} | {resid_str} | {mix_str}")
            any_data = True

        if not any_data:
            print("No valid combat data for this aircraft.")
        print("\n")

# === Run the print function ===
if __name__ == "__main__":
    print_residual_kill_tables()
media_rw
import os
import json
from scipy.stats import pearsonr
import valf3  # your helper module (assumed present)
from valf1 import (
    nation_age_ratios, nation_age_conflicts,
    year_nation_kills, year_nation_weighted_age,
    print_summary, conflict_year_map
)

# --- Ensure JSON files exist with defaults ---

def ensure_json_file(filename, default_data):
    if not os.path.exists(filename):
        print(f"File '{filename}' not found. Creating with default content.")
        try:
            with open(filename, 'w') as f:
                json.dump(default_data, f, indent=2)
        except Exception as e:
            print(f"ERROR: Could not create '{filename}': {e}")
            exit(1)
    else:
        print(f"File '{filename}' exists.")

def load_json(filename):
    try:
        with open(filename, 'r') as f:
            return json.load(f)
    except json.JSONDecodeError:
        print(f"ERROR: JSON decode error in '{filename}', resetting to empty dict.")
        with open(filename, 'w') as f:
            json.dump({}, f)
        return {}
    except Exception as e:
        print(f"ERROR: Unexpected error loading '{filename}': {e}")
        exit(1)

# Filenames and their default content
files_and_defaults = {
    'F1.json': {},
    'F2.json': {},
    'F3.json': {},
    'opponent_mix_weights.json': {}
}

for filename, default in files_and_defaults.items():
    ensure_json_file(filename, default)

fighter_stats = load_json('F1.json')
aircraft_metadata = load_json('F2.json')
conflict_years = load_json('F3.json')
opponent_mix_weights = load_json('opponent_mix_weights.json')

def get_conflict_start_year(conflict_name):
    entry = conflict_years.get(conflict_name)
    if entry and 'start' in entry:
        return entry['start']
    return None

def get_aircraft_side(aircraft):
    meta = aircraft_metadata.get(aircraft, {})
    nation = meta.get('nation', 'Unknown')
    if nation == 'USA':
        return 'USA'
    elif nation in ('USSR', 'France'):
        return 'USSR+France'
    else:
        return 'Other'

difficulty_by_year = {}

def compute_difficulty_factor(filter_years=None):
    print("Difficulty factors by year and side (weighted average aircraft age):")
    side_nations = {
        'USA': ['USA'],
        'USSR+France': ['USSR', 'France']
    }

    years = sorted(year_nation_kills.keys())
    if filter_years is not None:
        years = [y for y in years if y in filter_years]

    global difficulty_by_year
    difficulty_by_year = {}

    for year in years:
        total_kills = sum(year_nation_kills[year].values())
        if total_kills == 0:
            continue

        side_ages = {}
        for side, nations in side_nations.items():
            kills = sum(year_nation_kills[year].get(n, 0) for n in nations)
            weighted_age = sum(year_nation_weighted_age[year].get(n, 0) for n in nations)
            side_ages[side] = weighted_age / kills if kills > 0 else 0

        difficulty_by_year[year] = side_ages

        print(f"Year {year}:")
        for side in side_nations:
            print(f"  {side} Difficulty Factor (Avg Aircraft Age): {side_ages[side]:.2f}")
    print()

def print_table(filter_ages=None):
    for nation, age_data in nation_age_ratios.items():
        print(f"Nation: {nation} Age-to-Average Kill Ratio Buckets:")
        ages = sorted(age_data.keys())
        avg_ratios = []
        age_vals = []
        for age in ages:
            if filter_ages is not None and age not in filter_ages:
                continue
            ratios = age_data[age]
            avg_ratio = sum(ratios) / len(ratios)
            age_vals.append(age)
            avg_ratios.append(avg_ratio)
            conflicts_sample = ', '.join(sorted(nation_age_conflicts[nation][age]))
            print(f"  Age {age}: Avg Ratio {avg_ratio:.2f} (Conflicts: {conflicts_sample})")
        if len(age_vals) > 1:
            r, p = pearsonr(age_vals, avg_ratios)
            print(f"Pearson r: {r:.4f}")
            print(f"P-value: {p:.4f}")
        else:
            print("Not enough data for correlation.")
        print()

def print_difficulty_analysis():
    print("Comparative Difficulty Analysis:")
    print("Year | Diff (USSR+France - USA) | Ratio (USSR+France / USA) | USA Kill Ratio | USSR+France Kill Ratio")
    print("-" * 85)
    valid_years = [y for y in difficulty_by_year if all(s in difficulty_by_year[y] and difficulty_by_year[y][s] > 0 for s in ['USA', 'USSR+France'])]

    usa_ratios = []
    ussr_ratios = []
    diffs = []
    ratios = []

    for year in sorted(valid_years):
        d_usa = difficulty_by_year[year]['USA']
        d_comm = difficulty_by_year[year]['USSR+France']
        diff = d_comm - d_usa
        ratio = d_comm / d_usa if d_usa > 0 else 0

        usa_kills = year_nation_kills[year].get('USA', 0)
        comm_kills = sum(year_nation_kills[year].get(n, 0) for n in ['USSR', 'France'])
        total_kills = usa_kills + comm_kills
        usa_ratio = usa_kills / total_kills if total_kills else 0
        comm_ratio = comm_kills / total_kills if total_kills else 0

        print(f"{year} | {diff:24.2f} | {ratio:25.2f} | {usa_ratio:.3f}         | {comm_ratio:.3f}")

        diffs.append(diff)
        ratios.append(ratio)
        usa_ratios.append(usa_ratio)
        ussr_ratios.append(comm_ratio)

    def regress(x, y, label):
        if len(x) > 1:
            r, p = pearsonr(x, y)
            print(f"{label} Pearson r: {r:.4f}, p = {p:.4f}")
        else:
            print(f"{label}: Not enough data for regression.")

    print()
    regress(diffs, usa_ratios, "USA vs Diff")
    regress(ratios, usa_ratios, "USA vs Ratio")
    regress(diffs, ussr_ratios, "USSR+France vs Diff")
    regress(ratios, ussr_ratios, "USSR+France vs Ratio")

def print_aircraft_residual_kill_tables(filter_years=None):
    print("\nResidual Kill Ratio Tables by Aircraft (kills normalized by difficulty factor):\n")
    for aircraft, conflicts in fighter_stats.items():
        kills_by_year = {}
        for conflict_name, stats in conflicts.items():
            start_year = get_conflict_start_year(conflict_name)
            if start_year is None:
                continue
            if filter_years is not None and start_year not in filter_years:
                continue
            kills = stats.get('Kills', 0)
            kills_by_year[start_year] = kills_by_year.get(start_year, 0) + kills

        if not kills_by_year:
            continue

        side = get_aircraft_side(aircraft)

        print(f"Aircraft: {aircraft}")
        print(f"{'Year':<6} {'Kills':<6} {'Difficulty':<10} {'Residual':<10} Opponent Mix")
        print("-" * 80)

        for year in sorted(kills_by_year.keys()):
            kills = kills_by_year[year]
            difficulty = difficulty_by_year.get(year, {}).get(side, None)
            if difficulty is None or difficulty == 0:
                difficulty = 1

            residual = kills / difficulty

            opp_mix = opponent_mix_weights.get(str(year), {})
            opp_mix_str = ", ".join(f"{ac}: {w*100:.0f}%" for ac, w in opp_mix.items()) if opp_mix else "N/A"

            print(f"{year:<6} {kills:<6} {difficulty:<10.2f} {residual:<10.2f} {opp_mix_str}")

        print()

# --- Write current difficulty years to temp.txt ---

def write_temp_file():
    try:
        with open('temp.txt', 'w') as f:
            for year in sorted(current_difficulty_years):
                f.write(f"{year}\n")
    except Exception as e:
        print(f"Failed to write temp.txt: {e}")

# --- Initial data state sets ---

all_ages = set(age for nation in nation_age_ratios for age in nation_age_ratios[nation])
current_ages = set(all_ages)

all_difficulty_years = set(year_nation_kills.keys())
current_difficulty_years = set(all_difficulty_years)

# --- Initial output ---

print_summary()
print_table(filter_ages=current_ages)
compute_difficulty_factor(filter_years=current_difficulty_years)
print_difficulty_analysis()
print_aircraft_residual_kill_tables(filter_years=current_difficulty_years)
write_temp_file()

# --- Interactive command loop ---

while True:
    removed_ages = all_ages - current_ages
    removed_difficulty_years = all_difficulty_years - current_difficulty_years

    print("\nCurrently shown age buckets:", sorted(current_ages) or "(none)")
    print("Removed age buckets:", sorted(removed_ages) or "(none)")
    print("Currently shown difficulty years:", sorted(current_difficulty_years) or "(none)")
    print("Removed difficulty years:", sorted(removed_difficulty_years) or "(none)")

    valf3.print_residual_kill_tables()

    user_input = input(
        "\nEnter command:\n"
        "  'add <ages>' or 'remove <ages>' (e.g., 'add 4,7')\n"
        "  'adddif <years>' or 'removedif <years>'\n"
        "  Press Enter to quit: "
    ).strip().lower()

    if not user_input:
        print("Exiting.")
        break

    parts = user_input.split(maxsplit=1)
    if len(parts) != 2 or parts[0] not in ('add', 'remove', 'adddif', 'removedif'):
        print("Invalid command.")
        continue

    try:
        values = set(int(x.strip()) for x in parts[1].split(','))
    except ValueError:
        print("Invalid input: must be integers separated by commas.")
        continue

    if parts[0] == 'add':
        current_ages.update(values)
    elif parts[0] == 'remove':
        current_ages.difference_update(values)
    elif parts[0] == 'adddif':
        current_difficulty_years.update(values)
    elif parts[0] == 'removedif':
        current_difficulty_years.difference_update(values)

    # Refresh outputs and temp.txt
    print_summary()
    print_table(filter_ages=current_ages)
    compute_difficulty_factor(filter_years=current_difficulty_years)
    print_difficulty_analysis()
    print_aircraft_residual_kill_tables(filter_years=current_difficulty_years)
    write_temp_file()
