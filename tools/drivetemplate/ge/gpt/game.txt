media_rw
#python cs.py split --input game.txt
#python cs.py rebuild --output game.txt

import re
import os
import ast
import textwrap

def split_game_txt(input_file="game.txt"):
    """Splits game.txt into individual Python files based on class names."""
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("media_rw")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """Rebuilds game.txt by concatenating all .py files in the current directory."""
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("media_rw\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def validate_snippet(snippet):
    """Validates the syntax of a code snippet using Python's AST module."""
    try:
        dedented_snippet = textwrap.dedent(snippet)  # Remove unnecessary indentation
        ast.parse(dedented_snippet)
        print("Snippet is syntactically valid.")
        return True
    except SyntaxError as e:
        print(f"Syntax error in snippet: {e}")
        print("Snippet content:")
        print(snippet)
        return False

def modify_file_from_temp(temp_file="temp.txt"):
    """Modifies a .py file based on instructions from temp.txt."""
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        # Validate the snippet syntax before applying
        if not validate_snippet(snippet):
            print("Modification aborted due to invalid syntax in snippet.")
            return

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        # Ensure the specified line range is valid
        with open(filename, "r") as file:
            file_contents = file.readlines()
        if start_line > len(file_contents) or end_line > len(file_contents) + 1:
            print(f"Invalid line range: {start_line}-{end_line}. File has {len(file_contents)} lines.")
            return

        # Create a backup of the file
        backup_filename = f"{filename}.bak"
        os.rename(filename, backup_filename)
        print(f"Backup created: {backup_filename}")

        # Apply modification
        modified_contents = (
            file_contents[:start_line - 1] + file_contents[end_line:]  # Remove specified lines
        )
        modified_contents.insert(start_line - 1, snippet)  # Insert new snippet

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """Dynamically generates temp.txt based on the parameters provided."""
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()
media_rw
#python cs.py split --input game.txt
#python cs.py rebuild --output game.txt

import re
import os
import ast
import textwrap

def split_game_txt(input_file="game.txt"):
    """Splits game.txt into individual Python files based on class names."""
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("

#python cs.py split --input game.txt
#python cs.py rebuild --output game.txt

import re
import os
import ast
import textwrap

def split_game_txt(input_file="game.txt"):
    """Splits game.txt into individual Python files based on class names."""
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("

#python cs.py split --input game.txt
#python cs.py rebuild --output game.txt

import re
import os
import ast
import textwrap

def split_game_txt(input_file="game.txt"):
    """Splits game.txt into individual Python files based on class names."""
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("

#python cs.py rebuild --output game.txt

import re
import os
import ast
import textwrap

def split_game_txt(input_file="game.txt"):
    """Splits game.txt into individual Python files based on class names."""
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("

import re
import os

def split_game_txt(input_file="game.txt"):
    """
    Splits game.txt into individual Python files based on class names.
    """
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("

#python cs.py split --input game.txt
#python cs.py rebuild --output game.txt

import re
import os
import ast
import textwrap

def split_game_txt(input_file="game.txt"):
    """Splits game.txt into individual Python files based on class names."""
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("
media_rw
")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """Rebuilds game.txt by concatenating all .py files in the current directory."""
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("

\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def validate_snippet(snippet):
    """Validates the syntax of a code snippet using Python's AST module."""
    try:
        dedented_snippet = textwrap.dedent(snippet)  # Remove unnecessary indentation
        ast.parse(dedented_snippet)
        print("Snippet is syntactically valid.")
        return True
    except SyntaxError as e:
        print(f"Syntax error in snippet: {e}")
        print("Snippet content:")
        print(snippet)
        return False

def modify_file_from_temp(temp_file="temp.txt"):
    """Modifies a .py file based on instructions from temp.txt."""
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        # Validate the snippet syntax before applying
        if not validate_snippet(snippet):
            print("Modification aborted due to invalid syntax in snippet.")
            return

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        # Ensure the specified line range is valid
        with open(filename, "r") as file:
            file_contents = file.readlines()
        if start_line > len(file_contents) or end_line > len(file_contents) + 1:
            print(f"Invalid line range: {start_line}-{end_line}. File has {len(file_contents)} lines.")
            return

        # Create a backup of the file
        backup_filename = f"{filename}.bak"
        os.rename(filename, backup_filename)
        print(f"Backup created: {backup_filename}")

        # Apply modification
        modified_contents = (
            file_contents[:start_line - 1] + file_contents[end_line:]  # Remove specified lines
        )
        modified_contents.insert(start_line - 1, snippet)  # Insert new snippet

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """Dynamically generates temp.txt based on the parameters provided."""
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()

")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """Rebuilds game.txt by concatenating all .py files in the current directory."""
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("

\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def validate_snippet(snippet):
    """Validates the syntax of a code snippet using Python's AST module."""
    try:
        dedented_snippet = textwrap.dedent(snippet)  # Remove unnecessary indentation
        ast.parse(dedented_snippet)
        print("Snippet is syntactically valid.")
        return True
    except SyntaxError as e:
        print(f"Syntax error in snippet: {e}")
        print("Snippet content:")
        print(snippet)
        return False

def modify_file_from_temp(temp_file="temp.txt"):
    """Modifies a .py file based on instructions from temp.txt."""
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        # Validate the snippet syntax before applying
        if not validate_snippet(snippet):
            print("Modification aborted due to invalid syntax in snippet.")
            return

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        # Ensure the specified line range is valid
        with open(filename, "r") as file:
            file_contents = file.readlines()
        if start_line > len(file_contents) or end_line > len(file_contents) + 1:
            print(f"Invalid line range: {start_line}-{end_line}. File has {len(file_contents)} lines.")
            return

        # Create a backup of the file
        backup_filename = f"{filename}.bak"
        os.rename(filename, backup_filename)
        print(f"Backup created: {backup_filename}")

        # Apply modification
        modified_contents = (
            file_contents[:start_line - 1] + file_contents[end_line:]  # Remove specified lines
        )
        modified_contents.insert(start_line - 1, snippet)  # Insert new snippet

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """Dynamically generates temp.txt based on the parameters provided."""
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()

")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """Rebuilds game.txt by concatenating all .py files in the current directory."""
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("

\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def validate_snippet(snippet):
    """Validates the syntax of a code snippet using Python's AST module."""
    try:
        dedented_snippet = textwrap.dedent(snippet)  # Remove unnecessary indentation
        ast.parse(dedented_snippet)
        print("Snippet is syntactically valid.")
        return True
    except SyntaxError as e:
        print(f"Syntax error in snippet: {e}")
        print("Snippet content:")
        print(snippet)
        return False

def modify_file_from_temp(temp_file="temp.txt"):
    """Modifies a .py file based on instructions from temp.txt."""
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        # Validate the snippet syntax before applying
        if not validate_snippet(snippet):
            print("Modification aborted due to invalid syntax in snippet.")
            return

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        # Ensure the specified line range is valid
        with open(filename, "r") as file:
            file_contents = file.readlines()
        if start_line > len(file_contents) or end_line > len(file_contents) + 1:
            print(f"Invalid line range: {start_line}-{end_line}. File has {len(file_contents)} lines.")
            return

        # Create a backup of the file
        backup_filename = f"{filename}.bak"
        os.rename(filename, backup_filename)
        print(f"Backup created: {backup_filename}")

        # Apply modification
        modified_contents = (
            file_contents[:start_line - 1] + file_contents[end_line:]  # Remove specified lines
        )
        modified_contents.insert(start_line - 1, snippet)  # Insert new snippet

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """Dynamically generates temp.txt based on the parameters provided."""
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()

")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """Rebuilds game.txt by concatenating all .py files in the current directory."""
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("

\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def validate_snippet(snippet):
    """Validates the syntax of a code snippet using Python's AST module."""
    try:
        dedented_snippet = textwrap.dedent(snippet)  # Remove unnecessary indentation
        ast.parse(dedented_snippet)
        print("Snippet is syntactically valid.")
        return True
    except SyntaxError as e:
        print(f"Syntax error in snippet: {e}")
        print("Snippet content:")
        print(snippet)
        return False

def modify_file_from_temp(temp_file="temp.txt"):
    """Modifies a .py file based on instructions from temp.txt."""
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        # Validate the snippet syntax before applying
        if not validate_snippet(snippet):
            print("Modification aborted due to invalid syntax in snippet.")
            return

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        # Ensure the specified line range is valid
        with open(filename, "r") as file:
            file_contents = file.readlines()
        if start_line > len(file_contents) or end_line > len(file_contents) + 1:
            print(f"Invalid line range: {start_line}-{end_line}. File has {len(file_contents)} lines.")
            return

        # Create a backup of the file
        backup_filename = f"{filename}.bak"
        os.rename(filename, backup_filename)
        print(f"Backup created: {backup_filename}")

        # Apply modification
        modified_contents = (
            file_contents[:start_line - 1] + file_contents[end_line:]  # Remove specified lines
        )
        modified_contents.insert(start_line - 1, snippet)  # Insert new snippet

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """Dynamically generates temp.txt based on the parameters provided."""
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()

")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """Rebuilds game.txt by concatenating all .py files in the current directory."""
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("

\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def validate_snippet(snippet):
    """Validates the syntax of a code snippet using Python's AST module."""
    try:
        dedented_snippet = textwrap.dedent(snippet)  # Remove unnecessary indentation
        ast.parse(dedented_snippet)
        print("Snippet is syntactically valid.")
        return True
    except SyntaxError as e:
        print(f"Syntax error in snippet: {e}")
        print("Snippet content:")
        print(snippet)
        return False

def modify_file_from_temp(temp_file="temp.txt"):
    """Modifies a .py file based on instructions from temp.txt."""
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        # Validate the snippet syntax before applying
        if not validate_snippet(snippet):
            print("Modification aborted due to invalid syntax in snippet.")
            return

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        # Ensure the specified line range is valid
        with open(filename, "r") as file:
            file_contents = file.readlines()
        if start_line > len(file_contents) or end_line > len(file_contents) + 1:
            print(f"Invalid line range: {start_line}-{end_line}. File has {len(file_contents)} lines.")
            return

        # Create a backup of the file
        backup_filename = f"{filename}.bak"
        os.rename(filename, backup_filename)
        print(f"Backup created: {backup_filename}")

        # Apply modification
        modified_contents = (
            file_contents[:start_line - 1] + file_contents[end_line:]  # Remove specified lines
        )
        modified_contents.insert(start_line - 1, snippet)  # Insert new snippet

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """Dynamically generates temp.txt based on the parameters provided."""
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()

")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """
    Rebuilds game.txt by concatenating all .py files in the current directory.
    """
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("

\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def modify_file_from_temp(temp_file="temp.txt"):
    """
    Modifies a .py file based on instructions from temp.txt.
    """
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        with open(filename, "r") as file:
            file_contents = file.readlines()

        # Replace lines
        modified_contents = file_contents[:start_line - 1] + file_contents[end_line:]
        modified_contents.insert(start_line - 1, snippet)

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """
    Dynamically generates temp.txt based on the parameters provided.
    """
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()
media_rw
import math
import random

class Tank:
    def __init__(self, canvas, x, y, color="green", ui=None):
        """
        Initializes the Tank object and draws it on the canvas.

        Args:
            canvas (tk.Canvas): The canvas to draw the tank on.
            x (float): The x-coordinate of the tank's center.
            y (float): The y-coordinate of the tank's center.
            color (str): The primary color of the tank (default: green).
            ui (GameUI, optional): An instance of GameUI for logging.
        """
        self.canvas = canvas
        self.x = x
        self.y = y
        self.color = color
        self.ui = ui  # Optional: Reference to GameUI for logging

        # Default angles for hull and turret in degrees
        self.hull_angle = 0
        self.turret_angle = 0

        # Components of the tank
        self.hull = None
        self.turret = None
        self.gun = None

        # Health for destruction logic
        self.health = 10  # Default health for tank

        # Draw the initial tank
        self.draw()

    def draw(self):
        """
        Draws the tank components (hull, turret, gun) on the canvas.
        This method updates their positions and directions.
        """
        self._clear_previous_drawings()

        # Hull dimensions
        hull_width, hull_height = 30, 20
        turret_radius = 8
        gun_length = 20

        # Calculate hull rotation (trigonometric rotation)
        hull_dx = hull_width / 2 * math.cos(math.radians(self.hull_angle))
        hull_dy = hull_width / 2 * math.sin(math.radians(self.hull_angle))
        offset_x = hull_height / 2 * math.sin(math.radians(self.hull_angle))
        offset_y = hull_height / 2 * math.cos(math.radians(self.hull_angle))

        # Define corners of the rotated hull rectangle
        corners = [
            (self.x - hull_dx - offset_x, self.y - hull_dy + offset_y),
            (self.x + hull_dx - offset_x, self.y + hull_dy + offset_y),
            (self.x + hull_dx + offset_x, self.y + hull_dy - offset_y),
            (self.x - hull_dx + offset_x, self.y - hull_dy - offset_y),
        ]

        self.hull = self.canvas.create_polygon(corners, fill=self.color)

        # Turret center remains at the hull's center
        self.turret = self.canvas.create_oval(
            self.x - turret_radius, self.y - turret_radius,
            self.x + turret_radius, self.y + turret_radius,
            fill="darkgreen"
        )

        # Gun end point based on turret_angle
        gun_dx = gun_length * math.cos(math.radians(self.turret_angle))
        gun_dy = gun_length * math.sin(math.radians(self.turret_angle))
        self.gun = self.canvas.create_line(
            self.x, self.y,
            self.x + gun_dx, self.y + gun_dy,
            fill="black", width=3
        )

    def _clear_previous_drawings(self):
        """
        Clears the previous drawings of the tank components before redrawing.
        """
        if self.hull:
            self.canvas.delete(self.hull)
        if self.turret:
            self.canvas.delete(self.turret)
        if self.gun:
            self.canvas.delete(self.gun)

    def take_damage(self, damage):
        """
        Reduces the tank's health by a specified amount and triggers destruction if health drops to zero.

        Args:
            damage (int): The amount of damage to inflict.
        """
        self.health -= damage
        if self.health <= 0:
            self.health = 0
            self.ui.update_log("[LOG] Tank destroyed!")
            self.turret_toss()

    def turret_toss(self, debris_count=6, range_min=15, range_max=30):
        """
        Simulates the turret toss with randomized debris scattering.

        Args:
            debris_count (int): Number of debris pieces.
            range_min (int): Minimum range for debris to scatter.
            range_max (int): Maximum range for debris to scatter.
        """
        self.ui.update_log(f"[LOG] Turret toss initiated at ({self.x}, {self.y})")

        # Toss the turret itself
        turret_dx = random.uniform(-range_max, range_max)
        turret_dy = random.uniform(-range_max, range_max)
        turret_piece = self.canvas.create_oval(
            self.x - 5, self.y - 5,
            self.x + 5, self.y + 5,
            fill="darkgreen"
        )
        self._animate_debris(turret_piece, turret_dx, turret_dy)

        # Scatter debris pieces
        for _ in range(debris_count):
            debris_dx = random.uniform(-range_max, range_max)
            debris_dy = random.uniform(-range_max, range_max)
            debris_piece = self.canvas.create_oval(
                self.x - 3, self.y - 3,
                self.x + 3, self.y + 3,
                fill="gray"
            )
            self._animate_debris(debris_piece, debris_dx, debris_dy)

    def _animate_debris(self, debris, dx, dy, steps=20):
        """
        Animates a piece of debris along a given trajectory.

        Args:
            debris (int): The canvas object ID for the debris.
            dx (float): The x-velocity of the debris.
            dy (float): The y-velocity of the debris.
            steps (int): Number of animation steps.
        """
        def step_animation(step=0):
            if step < steps:
                self.canvas.move(debris, dx / steps, dy / steps)
                self.canvas.after(50, step_animation, step + 1)
            else:
                self.canvas.delete(debris)  # Remove debris when animation completes

        step_animation()
media_rw
import tkinter as tk
import random
from GameUI import GameUI
from TerrainManager import TerrainManager
from PlayerManager import PlayerManager
from EnemyManager import EnemyManager
from CombatManager import CombatManager
from bomber import Bomber  # Import the Bomber class
import math

class TacticalMap:
    def __init__(self, root, on_replay=None):
        """
        Initializes the TacticalMap, setting up game managers and the UI.

        Args:
            root (tk.Tk): The root window for the game.
            on_replay (callable): Optional callback function to restart the game.
        """
        self.root = root
        self.ui = GameUI(root)
        self.terrain_manager = TerrainManager(self.ui.grid_elements, self.ui.canvas)
        self.player_manager = PlayerManager(self.ui.grid_elements, self.terrain_manager, self.ui)
        self.enemy_manager = EnemyManager(
            self.ui.grid_elements, self.terrain_manager, enemy_count=5, ui=self.ui
        )
        self.combat_manager = CombatManager(
            self.ui.grid_elements,
            player_stats={"name": "T-64 Tank", "hp": 20, "ammo": 5},
            enemy_stats={"name": "Enemy Unit", "hp": 10},
            ui=self.ui,
            player_manager=self.player_manager,
        )
        self.bomber = None  # Bomber instance for debugging purposes
        self.on_replay = on_replay
        self.turn = "Player"
        self.grid_rows = 7
        self.grid_cols = 7
        self.determine_grid_dimensions()
        self.initialize_game()

    def determine_grid_dimensions(self):
        """
        Dynamically sets grid dimensions based on screen size.
        """
        screen_width = self.ui.root.winfo_screenwidth()
        screen_height = self.ui.root.winfo_screenheight()

        usable_width = int(screen_width * 0.95)
        usable_height = int(screen_height * 0.90)

        tile_size = 50
        self.grid_cols = max(1, usable_width // tile_size)
        self.grid_rows = max(1, usable_height // tile_size)

        self.ui.canvas.config(width=usable_width, height=usable_height)

    def initialize_game(self):
        """
        Sets up the game grid, generates terrain, deploys units, and renders the bomber. Retries if necessary.
        """
        self.ui.create_map(rows=self.grid_rows, cols=self.grid_cols, cell_click_callback=self.on_cell_click)

        for _ in range(5):
            if self.terrain_manager.generate_terrain(enemy_count=5):
                try:
                    player_pos = self.player_manager.deploy_player()
                    self.enemy_manager.deploy_enemies()
                    self.ui.update_log(f"Game initialized. Player spawned at: {player_pos}")

                    # Render the bomber for debugging purposes
                    self.deploy_bomber_debug(x=200, y=150)  # Example coordinates on the canvas
                    return
                except ValueError:
                    self.ui.update_log("Deployment failed. Retrying...")
        self.ui.update_log("Failed to initialize game.")
        self.end_game(victory=False)

    def deploy_bomber_debug(self, x, y):
        """
        Renders the Myasischev M4 Bison bomber on the map for debugging purposes.

        Args:
            x (float): The x-coordinate on the canvas.
            y (float): The y-coordinate on the canvas.
        """
        self.bomber = Bomber(self.ui.canvas, x=x, y=y, ui=self.ui)
        self.ui.update_log("[DEBUG] Bomber rendered on the map for testing.")

        # Start the spin test for the bomber
        self.bomber.spin_test()

        # Schedule the bomber to self-destruct after 10 seconds
        self.ui.canvas.after(10000, self.trigger_bomber_explosion)

    def trigger_bomber_explosion(self):
        """
        Handles the bomber's self-destruction by triggering an explosion.
        """
        if self.bomber:
            self.ui.update_log("[DEBUG] Bomber self-destruction triggered!")
            self.combat_manager.trigger_explosion((self.bomber.x, self.bomber.y))
            self.bomber.trigger_explosion()  # Call the bomber's explosion method
            self.bomber = None  # Remove bomber reference after explosion

    def on_cell_click(self, coord):
        """
        Handles a player's action when a cell is clicked.

        Args:
            coord (str): The coordinate of the clicked cell.
        """
        if self.turn == "Player":
            # Update hull orientation immediately
            player_position = self.player_manager.player_position
            dx = int(coord[1:]) - int(player_position[1:])
            dy = ord(coord[0]) - ord(player_position[0])

            if dx != 0 or dy != 0:
                self.player_manager.hull_angle = math.degrees(math.atan2(dy, dx))
                self.ui.draw_tank(player_position, self.player_manager.hull_angle, self.player_manager.turret_angle)
                self.ui.update_log(
                    f"[DEBUG] Hull angle updated to {self.player_manager.hull_angle:.2f}° on click."
                )

            self.handle_player_action(coord)

    def handle_player_action(self, coord):
        """
        Processes the player's action: move, attack, or use artillery.

        Args:
            coord (str): The target cell coordinate.
        """
        player_position = self.player_manager.player_position
        distance_row = abs(ord(coord[0]) - ord(player_position[0]))
        distance_col = abs(int(coord[1:]) - int(player_position[1:]))

        # Handle artillery attack
        if max(distance_row, distance_col) > 1:
            if self.player_manager.player_stats["ammo"] > 0:
                results = self.combat_manager.artillery_attack(
                    coord, self.enemy_manager.enemy_positions
                )
                self.player_manager.player_stats["ammo"] -= 1
                for result in results:
                    self.ui.update_log(result)
                self.ui.update_log(
                    f"Artillery fired. Ammo left: {self.player_manager.player_stats['ammo']}"
                )
                self.end_turn()
            else:
                self.ui.update_log("No ammo left!")
            return

        # Handle adjacent move or attack
        if max(distance_row, distance_col) == 1:
            terrain = self.terrain_manager.get_terrain(coord)
            if coord in self.enemy_manager.enemy_positions:
                result = self.combat_manager.player_attack(coord, self.enemy_manager.enemy_positions)
                self.ui.update_log(result)
                if not self.enemy_manager.enemy_positions:
                    self.end_game(victory=True)
            elif terrain in ["Empty", "Forest"]:
                self.player_manager.move_player_smoothly(coord)
                self.end_turn()
            else:
                self.ui.update_log("Cannot move to that terrain!")
        else:
            self.ui.update_log("Invalid move. Choose an adjacent tile.")

    def enemy_action(self):
        """
        Executes the enemies' turn, including movement and attacks.
        """
        self.ui.update_log("Enemies are taking their turn...")

        for enemy_pos in list(self.enemy_manager.enemy_positions.keys()):
            if self.enemy_manager.is_adjacent(enemy_pos, self.player_manager.player_position):
                result = self.combat_manager.enemy_attack(self.player_manager.player_position)
                self.ui.update_log(result)
                if "Player is defeated!" in result:
                    self.player_manager.handle_destruction()  # Trigger turret toss before ending the game
                    self.end_game(victory=False)
                    return
            else:
                new_pos = self.enemy_manager.move_toward_player(
                    enemy_pos, self.player_manager.player_position
                )
                if new_pos != enemy_pos:
                    self.enemy_manager.update_enemy_position(enemy_pos, new_pos)

        if not self.enemy_manager.enemy_positions:
            self.end_game(victory=True)
        else:
            self.end_turn()

    def end_turn(self):
        """
        Alternates turns between the player and the enemies.
        """
        if self.turn == "Player":
            self.turn = "Enemy"
            self.enemy_action()
        else:
            self.turn = "Player"
            self.ui.update_log("Your turn!")

    def end_game(self, victory):
        """
        Concludes the game with a victory or defeat message.
        """
        message = "You Win!" if victory else "Game Over!"
        self.ui.update_log(message)
        restart_command = self.on_replay if self.on_replay is not None else self.reset
        self.ui.display_game_over_overlay(message, restart_command=restart_command)

    def reset(self):
        """
        Resets the TacticalMap to its initial state for a new game.
        """
        self.ui.reset()
        self.terrain_manager.reset()
        self.player_manager.reset()
        self.enemy_manager.reset()
        self.combat_manager = CombatManager(
            self.ui.grid_elements,
            player_stats={"name": "T-64 Tank", "hp": 20, "ammo": 5},
            enemy_stats={"name": "Enemy Unit", "hp": 10},
            ui=self.ui,
            player_manager=self.player_manager,
        )
        self.turn = "Player"
        self.initialize_game()

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Turn-Based Tactical Simulation")
    game = TacticalMap(root)
    root.mainloop()
media_rw
import random

class CombatManager:
    def __init__(self, grid_elements, player_stats, enemy_stats, ui, player_manager):
        """
        Initializes the CombatManager with references to the grid elements,
        the player's statistics, the enemy's statistics, the GameUI, and the PlayerManager.

        Args:
            grid_elements (dict): Dictionary of canvas rectangles for the grid.
            player_stats (dict): Dictionary containing player stats (e.g., {"hp": 20, "ammo": 5}).
            enemy_stats (dict): Dictionary containing enemy stats (e.g., {"hp": 10}).
            ui (GameUI): Instance of GameUI for rendering on the canvas.
            player_manager (PlayerManager): Instance of PlayerManager for managing the player.
        """
        self.grid_elements = grid_elements
        self.player_stats = player_stats
        self.enemy_stats = enemy_stats
        self.ui = ui  # Reference to the GameUI
        self.player_manager = player_manager  # Reference to the PlayerManager for turret updates

    def player_attack(self, target_coord, enemy_positions):
        """
        Handles the player's attack on an enemy unit and aims the turret at the target.

        Args:
            target_coord (str): The coordinate of the enemy being attacked.
            enemy_positions (dict): A dictionary mapping enemy positions to their HP.

        Returns:
            str: A message describing the outcome of the attack.
        """
        # Aim the turret at the target coordinate
        self.player_manager.aim_turret(target_coord)

        if target_coord in enemy_positions:
            enemy_positions[target_coord] -= 5  # Damage the enemy by 5 points
            if enemy_positions[target_coord] <= 0:
                del enemy_positions[target_coord]  # Remove defeated enemy
                self.ui.update_cell(target_coord, "Empty", "lightgray")  # Clear cell
                return f"Enemy at {target_coord} is defeated!"
            else:
                return f"Enemy at {target_coord} HP reduced to {enemy_positions[target_coord]}."
        return "No enemy to attack at the selected position."

    def artillery_attack(self, target_coord, enemy_positions):
        """
        Handles artillery attack, which damages the target coordinate and adjacent tiles.
        Aims the turret at the primary target coordinate.

        Args:
            target_coord (str): The main target coordinate for the artillery attack.
            enemy_positions (dict): A dictionary mapping enemy positions to their HP.

        Returns:
            list: A list of messages describing the outcomes at each affected coordinate.
        """
        # Aim the turret at the primary target coordinate
        self.player_manager.aim_turret(target_coord)

        results = []
        row = ord(target_coord[0])
        col = int(target_coord[1:])

        # Generate a list of affected coordinates (target + adjacent)
        affected_coords = [
            target_coord,
            f"{chr(row - 1)}{col}",
            f"{chr(row + 1)}{col}",
            f"{chr(row)}{col - 1}",
            f"{chr(row)}{col + 1}"
        ]

        self.ui.update_log(f"[DEBUG] Artillery targeted at {target_coord}. Affected coordinates: {affected_coords}")

        for coord in affected_coords:
            if coord in enemy_positions:
                enemy_positions[coord] -= 10  # Artillery deals 10 damage
                if enemy_positions[coord] <= 0:
                    del enemy_positions[coord]
                    self.ui.update_cell(coord, "Empty", "lightgray")
                    results.append(f"Enemy at {coord} destroyed by artillery.")
                else:
                    results.append(f"Enemy at {coord} hit by artillery. HP now {enemy_positions[coord]}.")
            elif coord in self.grid_elements:
                results.append(f"Artillery hit {coord}, but no enemies present.")

        return results

    def enemy_attack(self, player_position):
        """
        Handles the enemy's attack on the player.

        Args:
            player_position (str): The current position of the player.

        Returns:
            str: A message describing the result of the enemy's attack.
        """
        self.player_stats["hp"] -= 5  # Enemy deals a fixed 5 damage
        self.ui.update_log(f"[LOG] Enemy attacked! Player HP reduced to {self.player_stats['hp']}.")
        
        if self.player_stats["hp"] <= 0:
            self.ui.update_log("[DEBUG] Player HP has dropped to 0 or below. Triggering destruction.")
            # Trigger the player's destruction sequence
            self.player_manager.handle_destruction()
            return "Player is defeated!"
        else:
            return f"Player HP reduced to {self.player_stats['hp']}."

    def trigger_explosion(self, position, debris_count=8):
        """
        Creates an explosion effect with debris at the specified position.

        Args:
            position (tuple): (x, y) coordinates for the explosion center.
            debris_count (int): Number of debris pieces to scatter.
        """
        x, y = position
        self.ui.update_log(f"[DEBUG] Explosion triggered at ({x}, {y}).")

        for _ in range(debris_count):
            dx = random.uniform(-20, 20)
            dy = random.uniform(-20, 20)
            debris_piece = self.ui.canvas.create_oval(
                x - 5, y - 5, x + 5, y + 5,
                fill="orange"
            )
            self._animate_debris(debris_piece, dx, dy)

    def _animate_debris(self, debris, dx, dy, steps=20):
        """
        Animates a piece of debris along a trajectory.

        Args:
            debris (int): The canvas object ID of the debris.
            dx (float): x-velocity.
            dy (float): y-velocity.
            steps (int): Number of animation steps.
        """
        def step_animation(step=0):
            if step < steps:
                self.ui.canvas.move(debris, dx / steps, dy / steps)
                self.ui.canvas.after(50, step_animation, step + 1)
            else:
                self.ui.canvas.delete(debris)
        step_animation()

    def is_adjacent(self, pos1, pos2):
        """
        Determines if two grid positions are adjacent (including diagonally).

        Args:
            pos1 (str): The first grid position (e.g., "A1").
            pos2 (str): The second grid position (e.g., "B2").

        Returns:
            bool: True if the two positions share a side or corner, False otherwise.
        """
        row_diff = abs(ord(pos1[0]) - ord(pos2[0]))
        col_diff = abs(int(pos1[1:]) - int(pos2[1:]))
        return max(row_diff, col_diff) == 1

    def reset(self, player_stats=None, enemy_stats=None):
        """
        Resets the CombatManager to its initial state for a new game.

        Args:
            player_stats (dict, optional): Updated stats for the player.
            enemy_stats (dict, optional): Updated stats for the enemies.
        """
        self.player_stats = player_stats if player_stats else {"hp": 20, "ammo": 5}
        self.enemy_stats = enemy_stats if enemy_stats else {"hp": 10}
media_rw
import random

class EnemyManager:
    def __init__(self, grid_elements, terrain_manager, enemy_count, ui):
        """
        Initializes the EnemyManager with references to the grid elements, terrain manager,
        the number of enemy units, and the GameUI instance.

        Args:
            grid_elements (dict): Dictionary of canvas rectangles for the grid.
            terrain_manager (TerrainManager): Instance of TerrainManager for managing terrains.
            enemy_count (int): Number of enemy units to deploy.
            ui (GameUI): Instance of GameUI for rendering on the canvas.
        """
        self.grid_elements = grid_elements  # Reference to canvas elements for the grid
        self.terrain_manager = terrain_manager  # Reference to terrain manager
        self.enemy_positions = {}  # Dictionary to track enemy positions and their HP
        self.enemy_count = enemy_count  # Number of enemy units
        self.ui = ui  # Reference to the GameUI

    def deploy_enemies(self):
        """
        Deploys enemy units on random empty tiles and renders them on the canvas.

        Returns:
            list: A list of coordinates where the enemies are deployed.

        Raises:
            ValueError: If there are not enough empty spaces for deployment.
        """
        empty_cells = [
            coord for coord, terr in self.terrain_manager.terrain.items()
            if terr == "Empty" and coord not in self.enemy_positions
        ]
        if len(empty_cells) < self.enemy_count:
            raise ValueError("Not enough empty spaces to deploy enemies.")

        for coord in random.sample(empty_cells, self.enemy_count):
            self.enemy_positions[coord] = 10  # Assign 10 HP to each enemy
            self.ui.update_cell(coord, "Enemy", "red")  # Render the enemy in red
        return list(self.enemy_positions.keys())

    def move_toward_player(self, enemy_position, player_position):
        """
        Moves an enemy unit toward the player. Handles terrain crossing probabilities.

        Args:
            enemy_position (str): The current position of the enemy unit.
            player_position (str): The current position of the player unit.

        Returns:
            str: The new position of the enemy unit.
        """
        enemy_row, enemy_col = ord(enemy_position[0]), int(enemy_position[1:])
        player_row, player_col = ord(player_position[0]), int(player_position[1:])

        dr = player_row - enemy_row
        dc = player_col - enemy_col

        # Determine direction of movement
        if abs(dr) > abs(dc):
            new_pos = f"{chr(enemy_row + (1 if dr > 0 else -1))}{enemy_col}"
        else:
            new_pos = f"{chr(enemy_row)}{enemy_col + (1 if dc > 0 else -1)}"

        # Validate and attempt the move
        if new_pos in self.grid_elements and enemy_position in self.enemy_positions:
            terrain = self.terrain_manager.get_terrain(new_pos)
            if terrain == "Water":
                if random.random() < 0.5:  # 50% chance to cross
                    self.update_enemy_position(enemy_position, new_pos)
                    return new_pos
                else:
                    return enemy_position
            elif terrain == "Mountain":
                if random.random() < 0.3:  # 30% chance to cross
                    self.update_enemy_position(enemy_position, new_pos)
                    return new_pos
                else:
                    return enemy_position
            elif terrain in ["Empty", "Forest"]:
                self.update_enemy_position(enemy_position, new_pos)
                return new_pos

        # Stay in place if move is invalid
        return enemy_position

    def update_enemy_position(self, old_position, new_position):
        """
        Updates the enemy's position on the canvas.

        Args:
            old_position (str): The previous position of the enemy.
            new_position (str): The new position of the enemy.
        """
        if old_position not in self.enemy_positions:
            print(f"[DEBUG] Invalid old_position: {old_position}. Cannot move enemy.")
            return
        if new_position in self.enemy_positions:
            print(f"[DEBUG] Collision detected! {new_position} is already occupied.")
            return

        self.ui.update_cell(old_position, "Empty", "lightgray")
        self.ui.update_cell(new_position, "Enemy", "red")
        self.enemy_positions[new_position] = self.enemy_positions.pop(old_position)

    def take_damage(self, coord, damage=5):
        """
        Reduces an enemy unit's HP at the specified coordinate and handles its destruction.

        Args:
            coord (str): The coordinate of the enemy unit.
            damage (int): The amount of damage to inflict.
        """
        if coord in self.enemy_positions:
            self.enemy_positions[coord] -= damage
            if self.enemy_positions[coord] <= 0:
                self.handle_destruction(coord)
            else:
                self.ui.update_log(f"[LOG] Enemy at {coord} took {damage} damage. HP: {self.enemy_positions[coord]}")
        else:
            self.ui.update_log(f"[DEBUG] No enemy at {coord} to take damage.")

    def handle_destruction(self, coord):
        """
        Handles the destruction of an enemy unit, including triggering a turret toss animation and removal.

        Args:
            coord (str): The coordinate of the enemy unit being destroyed.
        """
        if coord in self.enemy_positions:
            self.ui.update_log(f"[LOG] Enemy at {coord} destroyed!")
            
            # Trigger turret toss animation at the enemy's position
            rect_id = self.grid_elements.get(coord)
            if rect_id:
                x1, y1, x2, y2 = self.ui.canvas.coords(rect_id)
                center_x, center_y = (x1 + x2) / 2, (y1 + y2) / 2
                self.ui.update_log(f"[DEBUG] Enemy turret toss animation started at ({center_x}, {center_y}).")
                self.ui.turret_toss(center_x, center_y, debris_count=6, range_min=15, range_max=30)
                
            # Remove the enemy and clear the cell
            del self.enemy_positions[coord]
            self.ui.update_cell(coord, "Empty", "lightgray")

    def trigger_explosion(self, coord, debris_count=4):
        """
        Creates an explosion effect with debris at the specified coordinate.

        Args:
            coord (str): The coordinate of the explosion.
            debris_count (int): Number of debris pieces to scatter.
        """
        rect_id = self.grid_elements.get(coord)
        if rect_id:
            x1, y1, x2, y2 = self.ui.canvas.coords(rect_id)
            center_x, center_y = (x1 + x2) / 2, (y1 + y2) / 2
            for _ in range(debris_count):
                dx = random.uniform(-15, 15)
                dy = random.uniform(-15, 15)
                debris_piece = self.ui.canvas.create_oval(
                    center_x - 3, center_y - 3,
                    center_x + 3, center_y + 3,
                    fill="orange"
                )
                self.ui.canvas.after(50, self._animate_debris, debris_piece, dx, dy)

    def _animate_debris(self, debris, dx, dy, steps=20):
        """
        Animates a debris piece along a given trajectory.

        Args:
            debris (int): The canvas object ID for the debris.
            dx (float): The x-velocity of the debris.
            dy (float): The y-velocity of the debris.
            steps (int): Number of animation steps.
        """
        def step_animation(step=0):
            if step < steps:
                self.ui.canvas.move(debris, dx / steps, dy / steps)
                self.ui.canvas.after(50, step_animation, step + 1)
            else:
                self.ui.canvas.delete(debris)
        step_animation()

    def is_adjacent(self, pos1, pos2):
        """
        Checks if two positions are adjacent on the grid.

        Args:
            pos1 (str): The first position (e.g., "A1").
            pos2 (str): The second position (e.g., "B2").

        Returns:
            bool: True if the positions are adjacent, False otherwise.
        """
        row_diff = abs(ord(pos1[0]) - ord(pos2[0]))
        col_diff = abs(int(pos1[1:]) - int(pos2[1:]))
        return max(row_diff, col_diff) == 1

    def reset(self):
        """
        Resets the EnemyManager to its initial state for a new game.
        """
        for coord in list(self.enemy_positions.keys()):
            self.ui.update_cell(coord, "Empty", "lightgray")
        self.enemy_positions.clear()
media_rw
import tkinter as tk
from tkinter import ttk
import math
import random

class GameUI:
    def __init__(self, root):
        """
        Initializes the GameUI with a scrollable map (canvas-based),
        log area, and tank rendering.
        """
        self.root = root

        # Main container for layout organization
        self.main_frame = tk.Frame(self.root)
        self.main_frame.pack(fill="both", expand=True)

        # Create a canvas for the map with vertical and horizontal scrollbars
        self.canvas = tk.Canvas(self.main_frame, bg="white", width=800, height=300)
        self.scrollbar_y = ttk.Scrollbar(self.main_frame, orient="vertical", command=self.canvas.yview)
        self.scrollbar_x = ttk.Scrollbar(self.main_frame, orient="horizontal", command=self.canvas.xview)
        self.canvas.configure(yscrollcommand=self.scrollbar_y.set, xscrollcommand=self.scrollbar_x.set)
        self.scrollbar_y.pack(side="right", fill="y")
        self.scrollbar_x.pack(side="bottom", fill="x")
        self.canvas.pack(side="left", fill="both", expand=True)

        # Internal data structures for managing canvas elements
        self.grid_elements = {}    # Holds grid rectangle IDs and their coordinates
        self.cell_states = {}      # Stores each cell's current state (terrain, units, etc.)
        self.tank_graphics = {}    # Tracks the tank's graphical components

        # Log area for messages
        self.log_area = None
        self.create_log_area()

    def create_log_area(self):
        """
        Creates a text area to display the game log.
        """
        self.log_area = tk.Text(self.root, height=5, wrap="word", bg="lightyellow")
        self.log_area.pack(side="bottom", fill="x")
        self.log_area.configure(state="disabled")

    def create_map(self, rows, cols, cell_click_callback):
        """
        Creates a dynamically sized map grid using canvas rectangles.

        Args:
            rows (int): Number of rows in the grid.
            cols (int): Number of columns in the grid.
            cell_click_callback (callable): Function to call when a cell is clicked.
        """
        self.grid_elements.clear()
        self.cell_states.clear()

        cell_width = 50
        cell_height = 50

        for row in range(rows):
            for col in range(cols):
                coord = f"{chr(65 + row)}{col + 1}"  # e.g., A1, B1, etc.
                x1, y1 = col * cell_width, row * cell_height
                x2, y2 = x1 + cell_width, y1 + cell_height

                rect_id = self.canvas.create_rectangle(x1, y1, x2, y2, fill="lightgray", outline="black")
                self.grid_elements[coord] = rect_id
                self.cell_states[coord] = "Empty"
                self.canvas.tag_bind(rect_id, "<Button-1>", lambda event, c=coord: cell_click_callback(c))

    def update_log(self, message):
        """
        Appends a message to the log area.

        Args:
            message (str): The message to display.
        """
        if self.log_area:
            self.log_area.configure(state="normal")
            self.log_area.insert(tk.END, message + "\n")
            self.log_area.see(tk.END)
            self.log_area.configure(state="disabled")

    def draw_tank(self, coord, hull_angle=0, turret_angle=0):
        """
        Draws a tank at the specified coordinate, adjusting its hull and turret direction.

        Args:
            coord (str): The grid coordinate (e.g., "A1").
            hull_angle (float): The angle of the hull (in degrees).
            turret_angle (float): The angle of the turret (in degrees).
        """
        if coord not in self.grid_elements:
            print(f"[LOG] {coord} is not a valid coordinate.")
            return

        self.clear_tank()

        rect_id = self.grid_elements[coord]
        x1, y1, x2, y2 = self.canvas.coords(rect_id)
        center_x = (x1 + x2) / 2
        center_y = (y1 + y2) / 2

        # Dimensions
        hull_width, hull_height = 30, 20
        turret_radius = 8
        gun_length = 20

        # Calculate hull corners based on the hull angle
        hull_dx = hull_width / 2 * math.cos(math.radians(hull_angle))
        hull_dy = hull_width / 2 * math.sin(math.radians(hull_angle))
        offset_x = hull_height / 2 * math.sin(math.radians(hull_angle))
        offset_y = hull_height / 2 * math.cos(math.radians(hull_angle))

        hull_corners = [
            (center_x - hull_dx - offset_x, center_y - hull_dy + offset_y),
            (center_x + hull_dx - offset_x, center_y + hull_dy + offset_y),
            (center_x + hull_dx + offset_x, center_y + hull_dy - offset_y),
            (center_x - hull_dx + offset_x, center_y - hull_dy - offset_y),
        ]

        # Draw the hull
        self.tank_graphics["hull"] = self.canvas.create_polygon(hull_corners, fill="green")

        # Draw the turret
        self.tank_graphics["turret"] = self.canvas.create_oval(
            center_x - turret_radius, center_y - turret_radius,
            center_x + turret_radius, center_y + turret_radius,
            fill="darkgreen"
        )

        # Draw the gun
        gun_dx = gun_length * math.cos(math.radians(turret_angle))
        gun_dy = gun_length * math.sin(math.radians(turret_angle))
        self.tank_graphics["gun"] = self.canvas.create_line(
            center_x, center_y,
            center_x + gun_dx, center_y + gun_dy,
            fill="black", width=3
        )

        print(f"[LOG] Tank drawn at {coord} with hull_angle={hull_angle}° and turret_angle={turret_angle}°")

    def clear_tank(self):
        """
        Clears all tank graphics from the canvas.
        """
        for part in self.tank_graphics.values():
            self.canvas.delete(part)
        self.tank_graphics.clear()

    def update_cell(self, coord, terrain_type, color):
        """
        Updates the visual appearance of a cell on the grid.

        Args:
            coord (str): The coordinate of the cell (e.g., "A1").
            terrain_type (str): The terrain type designation (e.g., "Forest").
            color (str): The fill color for the cell.
        """
        if coord in self.grid_elements:
            rect_id = self.grid_elements[coord]
            self.canvas.itemconfig(rect_id, fill=color)
            self.cell_states[coord] = terrain_type

    def display_game_over_overlay(self, message, restart_command=None):
        """
        Displays a game over overlay on the canvas along with a 'Play Again' button if provided.

        Args:
            message (str): A message to display (e.g., "You Win!" or "Game Over!").
            restart_command (callable, optional): Function to call when the play-again button is clicked.
        """
        width = self.canvas.winfo_width()
        height = self.canvas.winfo_height()

        # Create a semi-transparent overlay
        self.canvas.create_rectangle(0, 0, width, height, fill="black", stipple="gray50", tags="game_over_overlay")

        # Display the game over message
        self.canvas.create_text(
            width // 2, height // 2,
            text=message,
            fill="white",
            font=("Helvetica", 32, "bold"),
            tags="game_over_text"
        )

        if restart_command:
            restart_button = tk.Button(self.root, text="Play Again", command=restart_command, bg="green", fg="white")
            self.canvas.create_window(width // 2, height // 2 + 50, window=restart_button, tags="restart_button")
        
        print(f"[LOG] Game Over overlay displayed with message: {message}")

    def reset(self):
        """
        Resets the GameUI: clears canvas elements, grid, and log.
        """
        self.canvas.delete("all")
        self.grid_elements.clear()
        self.cell_states.clear()
        self.tank_graphics.clear()
        if self.log_area:
            self.log_area.configure(state="normal")
            self.log_area.delete(1.0, tk.END)
            self.log_area.configure(state="disabled")
            
    def turret_toss(self, x, y, debris_count=6, range_min=15, range_max=30):
        """
        Creates a turret toss animation with randomized debris.

        Args:
            x (float): The x-coordinate for the toss center.
            y (float): The y-coordinate for the toss center.
            debris_count (int): Number of debris pieces to create.
            range_min (int): Minimum scatter range.
            range_max (int): Maximum scatter range.
        """
        for _ in range(debris_count):
            dx = random.uniform(-range_max, range_max)
            dy = random.uniform(-range_max, range_max)
            debris_piece = self.canvas.create_oval(
                x - 3, y - 3, x + 3, y + 3, fill="orange"
            )
            self._animate_debris(debris_piece, dx, dy)

    def _animate_debris(self, debris, dx, dy, steps=20):
        """
        Animates a piece of debris along a trajectory.

        Args:
            debris (int): The canvas object ID of the debris.
            dx (float): x-velocity.
            dy (float): y-velocity.
            steps (int): Number of animation steps.
        """
        def step_animation(step=0):
            if step < steps:
                self.canvas.move(debris, dx / steps, dy / steps)
                self.canvas.after(50, step_animation, step + 1)
            else:
                self.canvas.delete(debris)
        step_animation()
media_rw
import random
import math

class PlayerManager:
    def __init__(self, grid_elements, terrain_manager, ui):
        """
        Initializes the PlayerManager with references to the grid elements, terrain manager, and GameUI.

        Args:
            grid_elements (dict): Dictionary of canvas rectangles for the grid.
            terrain_manager (TerrainManager): Instance of TerrainManager for managing terrains.
            ui (GameUI): Instance of GameUI for drawing and managing the UI.
        """
        self.grid_elements = grid_elements
        self.terrain_manager = terrain_manager
        self.ui = ui  # Reference to the GameUI
        self.player_position = None
        self.player_stats = {"hp": 20, "ammo": 1}  # Default player stats
        self.hull_angle = 0  # Hull starts facing default direction
        self.turret_angle = 0  # Turret aligns with hull initially

    def deploy_player(self):
        """
        Deploys the player unit on a random empty tile and displays the tank graphic.

        Returns:
            str: The coordinate of the deployed player unit.

        Raises:
            ValueError: If deployment fails after multiple attempts.
        """
        for _ in range(10):  # Retry up to 10 times for deployment
            self.player_position = random.choice(list(self.grid_elements.keys()))
            if self.terrain_manager.get_terrain(self.player_position) == "Empty":
                # Draw the player's tank on the selected coordinate
                self.ui.draw_tank(self.player_position, self.hull_angle, self.turret_angle)
                self.ui.update_log(f"[DEBUG] Player deployed at: {self.player_position}")
                return self.player_position

        raise ValueError("Failed to deploy player unit after multiple attempts.")

    def move_player_smoothly(self, target_position):
        """
        Smoothly moves the player unit to a specified target position and adjusts the hull angle.

        Args:
            target_position (str): The coordinate to move the player unit to.

        Returns:
            str: The new position of the player unit.
        """
        if target_position not in self.grid_elements:
            self.ui.update_log(f"[LOG] Invalid target position: {target_position}")
            return self.player_position

        # Calculate direction of movement
        start_coord = self.player_position
        dx = int(target_position[1:]) - int(start_coord[1:])  # Horizontal difference
        dy = ord(target_position[0]) - ord(start_coord[0])  # Vertical difference

        # Update the hull angle immediately
        if dx != 0 or dy != 0:
            self.hull_angle = math.degrees(math.atan2(dy, dx))  # Proper angle calculation
            self.ui.update_log(f"[DEBUG] Hull angle updated to {self.hull_angle:.2f}° on movement.")

        # Animate the movement
        self._animate_tank_smoothly(target_position)

        # Update player's position
        self.player_position = target_position
        self.ui.update_log(f"[DEBUG] Player moved to {self.player_position}, Hull angle: {self.hull_angle:.2f}°")
        return self.player_position

    def _animate_tank_smoothly(self, target_position, steps=10):
        """
        Animates the tank's movement from its current position to the target position.

        Args:
            target_position (str): The coordinate to move the tank to.
            steps (int): Number of animation steps to transition smoothly.
        """
        rect_id_start = self.grid_elements[self.player_position]
        rect_id_end = self.grid_elements[target_position]

        # Get coordinates for animation
        x1, y1, x2, y2 = self.ui.canvas.coords(rect_id_start)
        start_x, start_y = (x1 + x2) / 2, (y1 + y2) / 2
        tx1, ty1, tx2, ty2 = self.ui.canvas.coords(rect_id_end)
        end_x, end_y = (tx1 + tx2) / 2, (ty1 + ty2) / 2

        dx = (end_x - start_x) / steps
        dy = (end_y - start_y) / steps

        def move_step(step=0):
            if step > steps:
                # Redraw tank at final position with updated hull angle
                self.ui.draw_tank(target_position, self.hull_angle, self.turret_angle)
                return
            self.ui.canvas.move(self.ui.tank_graphics["hull"], dx, dy)
            self.ui.canvas.move(self.ui.tank_graphics["turret"], dx, dy)
            self.ui.canvas.move(self.ui.tank_graphics["gun"], dx, dy)
            self.ui.canvas.after(50, move_step, step + 1)

        move_step()

    def aim_turret(self, target_position):
        """
        Adjusts the turret to point at the specified target position and logs the calculations.

        Args:
            target_position (str): The coordinate to aim the turret at.
        """
        if target_position not in self.grid_elements:
            self.ui.update_log(f"[LOG] Invalid target position: {target_position}")
            return

        # Calculate direction to target
        current_coord = self.player_position
        dx = int(target_position[1:]) - int(current_coord[1:])
        dy = ord(target_position[0]) - ord(current_coord[0])

        if dx != 0 or dy != 0:
            self.turret_angle = math.degrees(math.atan2(dy, dx))
            self.ui.update_log(f"[DEBUG] Turret aimed at {target_position}, Turret angle: {self.turret_angle:.2f}°")

        # Redraw tank to update turret orientation
        self.ui.draw_tank(self.player_position, self.hull_angle, self.turret_angle)

    def take_damage(self, damage):
        """
        Handles the player's tank taking damage. Triggers destruction if HP falls to zero.

        Args:
            damage (int): The amount of damage to inflict on the player's tank.
        """
        self.player_stats["hp"] -= damage
        self.ui.update_log(f"[LOG] Player took {damage} damage. HP: {self.player_stats['hp']}")
        if self.player_stats["hp"] <= 0:
            self.handle_destruction()

    def handle_destruction(self):
        """
        Triggers the destruction sequence for the player's tank, including a turret toss animation,
        and then displays the game over overlay.
        """
        self.ui.update_log("[DEBUG] Starting player tank destruction sequence.")
        self.ui.update_log(f"[LOG] Player tank destroyed at {self.player_position}. Initiating turret toss.")
        
        # Calculate center of the cell where the tank is located
        rect_id = self.grid_elements[self.player_position]
        x1, y1, x2, y2 = self.ui.canvas.coords(rect_id)
        center_x = (x1 + x2) / 2
        center_y = (y1 + y2) / 2
        self.ui.update_log(f"[DEBUG] Calculated center for turret toss: ({center_x}, {center_y}).")

        # Trigger turret toss animation
        self.ui.turret_toss(center_x, center_y, debris_count=6, range_min=15, range_max=30)
        self.ui.update_log("[DEBUG] Turret toss executed. Waiting for animation to complete...")

        # Delay displaying the game over overlay so the turret toss animation can play
        self.ui.canvas.after(
            1000,
            lambda: self.ui.display_game_over_overlay("Game Over! Your tank has been destroyed!")
        )
        self.ui.update_log("[DEBUG] Game over overlay scheduled to display after delay.")

    def heal_player(self, amount):
        """
        Heals the player by a specified amount.

        Args:
            amount (int): The amount of health to restore.
        """
        self.player_stats["hp"] += amount
        if self.player_stats["hp"] > 20:
            self.player_stats["hp"] = 20
        self.ui.update_log(f"Player healed. Current HP: {self.player_stats['hp']}")

    def reset(self):
        """
        Resets the PlayerManager to its initial state for a new game.
        """
        self.player_position = None
        self.player_stats = {"hp": 20, "ammo": 1}
        self.hull_angle = 0
        self.turret_angle = 0
        self.ui.update_log(f"[LOG] PlayerManager reset. Stats: {self.player_stats}")
media_rw
import random

class UnitManager:
    def __init__(self, map_buttons, terrain_manager, enemy_count):
        """
        Initializes the UnitManager with references to map buttons, terrain, and enemy count.
        """
        self.map_buttons = map_buttons  # Reference to the map buttons
        self.terrain_manager = terrain_manager  # Reference to the terrain manager
        self.player_position = "A1"  # Initial player position
        self.enemy_positions = []  # List of enemy positions
        self.enemy_count = enemy_count  # Total number of enemies to deploy

    def deploy_player(self, player_unit_name):
        """
        Deploys the player unit on a random empty tile.
        """
        for _ in range(5):  # Retry up to 5 times for deployment
            self.player_position = random.choice(list(self.map_buttons.keys()))
            if self.terrain_manager.get_terrain(self.player_position) == "Empty":
                self.map_buttons[self.player_position].config(text=player_unit_name, bg="blue")
                return self.player_position
        # Raise an exception if deployment fails
        raise ValueError("Failed to deploy player unit. Restart required.")

    def deploy_enemies(self, enemy_unit_name):
        """
        Deploys enemy units on random empty tiles.
        """
        empty_cells = [
            coord for coord, terr in self.terrain_manager.terrain.items()
            if terr == "Empty" and self.map_buttons[coord].cget("text") == "Empty"
        ]
        if len(empty_cells) < self.enemy_count:
            raise ValueError("Not enough empty spaces to deploy enemies.")

        self.enemy_positions = random.sample(empty_cells, self.enemy_count)
        for enemy_position in self.enemy_positions:
            self.map_buttons[enemy_position].config(text=enemy_unit_name, bg="red")
        return self.enemy_positions

    def move_unit(self, current_position, target_position, unit_name):
        """
        Moves a unit from the current position to the target position.
        """
        self.map_buttons[current_position].config(text="Empty", bg="lightgray")
        self.map_buttons[target_position].config(text=unit_name, bg="blue")
        return target_position

    def move_enemy(self, enemy_position, target_position, enemy_name):
        """
        Moves an enemy unit from the current position to the target position.
        """
        self.map_buttons[enemy_position].config(text="Empty", bg="lightgray")
        self.map_buttons[target_position].config(text=enemy_name, bg="red")
        return target_position

    def is_adjacent(self, pos1, pos2):
        """
        Determines whether two positions on the map are adjacent.
        """
        row_diff = abs(ord(pos1[0]) - ord(pos2[0]))
        col_diff = abs(int(pos1[1]) - int(pos2[1]))
        return max(row_diff, col_diff) == 1
media_rw
import random

class TerrainManager:
    def __init__(self, grid_elements, canvas):
        """
        Initializes the TerrainManager with references to the grid elements and canvas.

        Args:
            grid_elements (dict): Dictionary of canvas rectangles for the grid.
            canvas (tk.Canvas): The canvas object to update terrain appearance.
        """
        self.grid_elements = grid_elements  # Reference to the grid elements
        self.canvas = canvas  # Reference to the canvas
        self.terrain = {}  # Dictionary to store terrain types for each cell

    def generate_terrain(self, enemy_count, extra_empty=5):
        """
        Generates terrain for the map and ensures a minimum number of empty tiles.

        Args:
            enemy_count (int): Number of enemies to deploy (affects empty tiles needed).
            extra_empty (int): Extra empty tiles to ensure playability.

        Returns:
            bool: True if terrain generation is successful, False otherwise.
        """
        retries = 5  # Maximum number of attempts to generate a valid map
        for _ in range(retries):
            self.terrain.clear()
            empty_count = 0

            # Randomly assign terrain types to each cell
            for coord in self.grid_elements.keys():
                terrain_type = random.choice(["Forest", "Mountain", "Water", "Empty"])
                self.terrain[coord] = terrain_type
                if terrain_type == "Empty":
                    empty_count += 1

            # Check if enough empty tiles are available
            if empty_count >= enemy_count + extra_empty:
                self._apply_terrain_to_canvas()
                return True  # Successful generation

        return False  # Failed to generate a valid map after retries

    def _apply_terrain_to_canvas(self):
        """
        Applies the generated terrain to the canvas, updating its appearance.
        """
        for coord, terrain_type in self.terrain.items():
            rect_id = self.grid_elements.get(coord)
            if rect_id:  # Ensure the coordinate exists in the grid
                if terrain_type == "Forest":
                    self._update_canvas_cell(rect_id, "green")
                elif terrain_type == "Mountain":
                    self._update_canvas_cell(rect_id, "brown")
                elif terrain_type == "Water":
                    self._update_canvas_cell(rect_id, "blue")
                elif terrain_type == "Empty":
                    self._update_canvas_cell(rect_id, "lightgray")

    def _update_canvas_cell(self, rect_id, color):
        """
        Updates the appearance of a canvas cell based on the given color.

        Args:
            rect_id (int): The ID of the rectangle on the canvas.
            color (str): The fill color for the rectangle.
        """
        self.canvas.itemconfig(rect_id, fill=color)

    def get_terrain(self, coord):
        """
        Gets the terrain type for a specific coordinate.

        Args:
            coord (str): The map coordinate (e.g., "A1").

        Returns:
            str: The terrain type (e.g., "Forest", "Mountain", "Water", or "Empty").
        """
        return self.terrain.get(coord, "Unknown")

    def reset(self):
        """
        Resets the TerrainManager to its initial state for a new game.
        """
        # Clear current terrain and reset the canvas cells to default "Empty" state
        self.terrain.clear()
        for coord, rect_id in self.grid_elements.items():
            self._update_canvas_cell(rect_id, "lightgray")
media_rw
import math
from tank import Tank  # Import from the Tank base class
import random

class Bomber(Tank):
    def __init__(self, canvas, x, y, color="gray", ui=None):
        """
        Initializes the Bomber object with attributes for its components and turret configuration.

        Args:
            canvas (tk.Canvas): The canvas to draw the bomber on.
            x (float): The x-coordinate of the bomber's center.
            y (float): The y-coordinate of the bomber's center.
            color (str): The primary color of the bomber (default: gray).
            ui (GameUI, optional): Instance of GameUI for logging/debugging.
        """
        self.canvas = canvas
        self.x = x
        self.y = y
        self.color = color
        self.ui = ui  # UI instance for logging/debugging

        # Initialize graphical components
        self.body = None
        self.wings = None
        self.engines = []
        self.turrets = {}
        self.soviet_star = None
        self.heading_angle = 0  # Default direction (0°)

        # Define turret rotation constraints
        self.turret_limits = {
            "top": (-90, 90),
            "bottom": (90, 270),
            "left": (180, 360),
            "right": (0, 180),
            "rear": (135, 225),
        }

        super().__init__(canvas, x, y, color, ui)
        self.ui.update_log("[DEBUG] Bomber initialized successfully.")

    def draw(self):
        """
        Draws the bomber components, respecting the current heading angle and appearance.
        """
        self.ui.update_log("[DEBUG] Drawing bomber with aerodynamic fuselage and turrets.")
        self._clear_previous_drawings()

        # Dimensions
        body_length = 120
        body_height = 10
        wing_span = 150
        star_size = 12

        # Calculate and draw fuselage with taper and rotation
        fuselage_points = self._calculate_fuselage_points(body_length, body_height)
        self.body = self.canvas.create_polygon(fuselage_points, fill=self.color, outline="black")

        # Draw wings
        self.wings = self.canvas.create_line(
            *self._rotate_point(-wing_span / 2, 0),
            *self._rotate_point(wing_span / 2, 0),
            fill="darkgray", width=4
        )

        # Draw engines symmetrically
        self.engines = []
        for offset in [-40, 40]:
            self.engines.append(self._draw_engine(offset, -10))
            self.engines.append(self._draw_engine(offset, 10))

        # Draw turrets
        self._draw_turrets()

        # Draw the Soviet star
        self.soviet_star = self.canvas.create_text(
            self.x, self.y,
            text="★", fill="red", font=("Helvetica", star_size, "bold")
        )

    def spin_test(self):
        """
        Spins the bomber by 45-degree increments every second to test rotational functionality.
        """
        def rotate_step(angle=0):
            if angle >= 360:
                return
            self.rotate_to_heading(angle)
            self.ui.update_log(f"[DEBUG] Bomber rotated to {angle}°.")
            self.fire_turrets()
            self.canvas.after(1000, rotate_step, angle + 45)

        rotate_step(0)

    def rotate_to_heading(self, heading_angle):
        """
        Rotates the bomber to face a specific heading.

        Args:
            heading_angle (float): The target heading angle in degrees.
        """
        self.heading_angle = heading_angle % 360  # Normalize the angle to 0–360°
        self.ui.update_log(f"[DEBUG] Bomber rotated to heading {self.heading_angle:.2f}°.")
        self.draw()  # Redraw the bomber to reflect the updated heading

    def fire_turrets(self):
        """
        Simulates turret firing by creating projectiles from turret locations.
        """
        self.ui.update_log("[DEBUG] Turrets firing projectiles!")
        for turret_name, turret_data in self.turrets.items():
            angle = turret_data["angle"]
            radians = math.radians(angle)
            projectile_dx = 15 * math.cos(radians)
            projectile_dy = 15 * math.sin(radians)
            x1, y1, x2, y2 = self.canvas.coords(turret_data["id"])
            turret_x = (x1 + x2) / 2
            turret_y = (y1 + y2) / 2
            projectile = self.canvas.create_oval(
                turret_x - 2, turret_y - 2,
                turret_x + 2, turret_y + 2,
                fill="yellow"
            )
            self._animate_projectile(projectile, projectile_dx, projectile_dy)

    def _animate_projectile(self, projectile, dx, dy, steps=20):
        """
        Animates a projectile along a trajectory.

        Args:
            projectile (int): The canvas object ID of the projectile.
            dx (float): The x-velocity of the projectile.
            dy (float): The y-velocity of the projectile.
            steps (int): Number of animation steps.
        """
        def step_animation(step=0):
            if step < steps:
                self.canvas.move(projectile, dx / steps, dy / steps)
                self.canvas.after(50, step_animation, step + 1)
            else:
                self.canvas.delete(projectile)

        step_animation()

    def trigger_explosion(self):
        """
        Triggers an explosion animation at the bomber's location.
        """
        self.ui.update_log("[DEBUG] Triggering airplane explosion.")
        for _ in range(10):
            dx = random.uniform(-50, 50)
            dy = random.uniform(-50, 50)
            debris = self.canvas.create_oval(
                self.x - 5, self.y - 5, self.x + 5, self.y + 5,
                fill="orange"
            )
            self._animate_debris(debris, dx, dy)

    def _animate_debris(self, debris, dx, dy, steps=20):
        """
        Animates debris from the airplane explosion.

        Args:
            debris (int): Canvas object ID for the debris.
            dx (float): x-velocity of the debris.
            dy (float): y-velocity of the debris.
            steps (int): Number of animation steps.
        """
        def step_animation(step=0):
            if step < steps:
                self.canvas.move(debris, dx / steps, dy / steps)
                self.canvas.after(50, step_animation, step + 1)
            else:
                self.canvas.delete(debris)

        step_animation()

    def _calculate_fuselage_points(self, length, height):
        """
        Calculates the rotated fuselage points for a tapered body.

        Args:
            length (float): Length of the fuselage.
            height (float): Height of the main fuselage rectangle.

        Returns:
            list: List of rotated points for the fuselage polygon.
        """
        taper_length = length * 0.25  # Define taper length (25%)
        points = [
            (-length / 2 + taper_length, -height / 2),
            (length / 2 - taper_length, -height / 2),
            (length / 2, 0),
            (length / 2 - taper_length, height / 2),
            (-length / 2 + taper_length, height / 2),
            (-length / 2, 0),
        ]
        return [self._rotate_point(x, y) for x, y in points]

    def _rotate_point(self, x, y):
        """
        Rotates a point around the bomber's center based on the current heading.

        Args:
            x (float): X-coordinate relative to the center.
            y (float): Y-coordinate relative to the center.

        Returns:
            tuple: Rotated (x, y) coordinates.
        """
        radians = math.radians(self.heading_angle)
        rotated_x = self.x + x * math.cos(radians) - y * math.sin(radians)
        rotated_y = self.y + x * math.sin(radians) + y * math.cos(radians)
        return rotated_x, rotated_y

    def _draw_engine(self, x_offset, y_offset):
        """
        Draws an engine at a specified offset, rotated based on the heading.

        Args:
            x_offset (float): Horizontal offset.
            y_offset (float): Vertical offset.

        Returns:
            int: Canvas object ID of the created engine.
        """
        x, y = self._rotate_point(x_offset, y_offset)
        return self.canvas.create_oval(
            x - 5, y - 5, x + 5, y + 5,
            fill="black"
        )

    def _draw_turrets(self):
        """
        Draws turrets at specified positions on the bomber.
        """
        turret_positions = {
            "top": (0, -50),
            "bottom": (0, 50),
            "left": (-60, 0),
            "right": (60, 0),
            "rear": (-40, 30),
        }

        for turret_name, (x_offset, y_offset) in turret_positions.items():
            x, y = self._rotate_point(x_offset, y_offset)
            turret = self.canvas.create_oval(
                x - 4, y - 4, x + 4, y + 4, fill="red"
            )
            self.turrets[turret_name] = {"id": turret, "angle": 0}

    def _clear_previous_drawings(self):
        """
        Clears all previous drawings of the bomber.
        """
        components = [self.body, self.wings, self.soviet_star] + self.engines
        components += [turret["id"] for turret in self.turrets.values()]
        for component in components:
            if component:
                self.canvas.delete(component)
        self.body = None
        self.wings = None
        self.engines = []
        self.turrets = {}
        self.soviet_star = None
media_rw
import tkinter as tk

class GameApp:
    def __init__(self):
        """
        Wraps the entire game within a single object.
        Initializes the Tkinter root and game session.
        """
        self.root = tk.Tk()
        self.root.title("Turn-Based Tactical Simulation")
        self.tactical_map = None
        self.start_game()

    def start_game(self):
        """
        Starts a new game session by initializing TacticalMap and passing the replay callback.
        """
        from TacticalMap import TacticalMap  # Import here to avoid circular dependency
        if self.tactical_map:
            # Ensure TacticalMap is cleared before starting a new game
            self.tactical_map.reset()
        else:
            self.tactical_map = TacticalMap(self.root, on_replay=self.restart_game)

    def restart_game(self):
        """
        Resets the game session without destroying the entire root window.
        """
        if self.tactical_map:
            self.tactical_map.reset()
        else:
            self.start_game()

    def run(self):
        """
        Runs the Tkinter main loop.
        """
        self.root.mainloop()
media_rw
import tkinter as tk

class GameApp:
    def __init__(self):
        """
        Wraps the entire game within a single object.
        Initializes the Tkinter root and game session.
        """
        self.root = tk.Tk()
        self.root.title("Turn-Based Tactical Simulation")
        self.tactical_map = None
        self.start_game()

    def start_game(self):
        """
        Starts a new game session by initializing TacticalMap and passing the replay callback.
        """
        from TacticalMap import TacticalMap  # Import here to avoid circular dependency
        if self.tactical_map:
            # Ensure TacticalMap is cleared before starting a new game
            self.tactical_map.reset()
        else:
            self.tactical_map = TacticalMap(self.root, on_replay=self.restart_game)

    def restart_game(self):
        """
        Resets the game session without destroying the entire root window.
        """
        if self.tactical_map:
            self.tactical_map.reset()
        else:
            self.start_game()

    def run(self):
        """
        Runs the Tkinter main loop.
        """
        self.root.mainloop()
