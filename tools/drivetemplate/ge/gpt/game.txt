media_rw
#python cs.py split --input game.txt
#python cs.py rebuild --output game.txt

import re
import os
import ast
import textwrap

def split_game_txt(input_file="game.txt"):
    """Splits game.txt into individual Python files based on class names."""
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("media_rw")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """Rebuilds game.txt by concatenating all .py files in the current directory."""
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("media_rw\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def validate_snippet(snippet):
    """Validates the syntax of a code snippet using Python's AST module."""
    try:
        dedented_snippet = textwrap.dedent(snippet)  # Remove unnecessary indentation
        ast.parse(dedented_snippet)
        print("Snippet is syntactically valid.")
        return True
    except SyntaxError as e:
        print(f"Syntax error in snippet: {e}")
        print("Snippet content:")
        print(snippet)
        return False

def modify_file_from_temp(temp_file="temp.txt"):
    """Modifies a .py file based on instructions from temp.txt."""
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        # Validate the snippet syntax before applying
        if not validate_snippet(snippet):
            print("Modification aborted due to invalid syntax in snippet.")
            return

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        # Ensure the specified line range is valid
        with open(filename, "r") as file:
            file_contents = file.readlines()
        if start_line > len(file_contents) or end_line > len(file_contents) + 1:
            print(f"Invalid line range: {start_line}-{end_line}. File has {len(file_contents)} lines.")
            return

        # Create a backup of the file
        backup_filename = f"{filename}.bak"
        os.rename(filename, backup_filename)
        print(f"Backup created: {backup_filename}")

        # Apply modification
        modified_contents = (
            file_contents[:start_line - 1] + file_contents[end_line:]  # Remove specified lines
        )
        modified_contents.insert(start_line - 1, snippet)  # Insert new snippet

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """Dynamically generates temp.txt based on the parameters provided."""
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()
media_rw
#python cs.py split --input game.txt
#python cs.py rebuild --output game.txt

import re
import os
import ast
import textwrap

def split_game_txt(input_file="game.txt"):
    """Splits game.txt into individual Python files based on class names."""
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("

#python cs.py split --input game.txt
#python cs.py rebuild --output game.txt

import re
import os
import ast
import textwrap

def split_game_txt(input_file="game.txt"):
    """Splits game.txt into individual Python files based on class names."""
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("

#python cs.py split --input game.txt
#python cs.py rebuild --output game.txt

import re
import os
import ast
import textwrap

def split_game_txt(input_file="game.txt"):
    """Splits game.txt into individual Python files based on class names."""
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("

#python cs.py rebuild --output game.txt

import re
import os
import ast
import textwrap

def split_game_txt(input_file="game.txt"):
    """Splits game.txt into individual Python files based on class names."""
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("

import re
import os

def split_game_txt(input_file="game.txt"):
    """
    Splits game.txt into individual Python files based on class names.
    """
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("

#python cs.py split --input game.txt
#python cs.py rebuild --output game.txt

import re
import os
import ast
import textwrap

def split_game_txt(input_file="game.txt"):
    """Splits game.txt into individual Python files based on class names."""
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("
media_rw
")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """Rebuilds game.txt by concatenating all .py files in the current directory."""
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("

\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def validate_snippet(snippet):
    """Validates the syntax of a code snippet using Python's AST module."""
    try:
        dedented_snippet = textwrap.dedent(snippet)  # Remove unnecessary indentation
        ast.parse(dedented_snippet)
        print("Snippet is syntactically valid.")
        return True
    except SyntaxError as e:
        print(f"Syntax error in snippet: {e}")
        print("Snippet content:")
        print(snippet)
        return False

def modify_file_from_temp(temp_file="temp.txt"):
    """Modifies a .py file based on instructions from temp.txt."""
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        # Validate the snippet syntax before applying
        if not validate_snippet(snippet):
            print("Modification aborted due to invalid syntax in snippet.")
            return

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        # Ensure the specified line range is valid
        with open(filename, "r") as file:
            file_contents = file.readlines()
        if start_line > len(file_contents) or end_line > len(file_contents) + 1:
            print(f"Invalid line range: {start_line}-{end_line}. File has {len(file_contents)} lines.")
            return

        # Create a backup of the file
        backup_filename = f"{filename}.bak"
        os.rename(filename, backup_filename)
        print(f"Backup created: {backup_filename}")

        # Apply modification
        modified_contents = (
            file_contents[:start_line - 1] + file_contents[end_line:]  # Remove specified lines
        )
        modified_contents.insert(start_line - 1, snippet)  # Insert new snippet

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """Dynamically generates temp.txt based on the parameters provided."""
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()

")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """Rebuilds game.txt by concatenating all .py files in the current directory."""
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("

\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def validate_snippet(snippet):
    """Validates the syntax of a code snippet using Python's AST module."""
    try:
        dedented_snippet = textwrap.dedent(snippet)  # Remove unnecessary indentation
        ast.parse(dedented_snippet)
        print("Snippet is syntactically valid.")
        return True
    except SyntaxError as e:
        print(f"Syntax error in snippet: {e}")
        print("Snippet content:")
        print(snippet)
        return False

def modify_file_from_temp(temp_file="temp.txt"):
    """Modifies a .py file based on instructions from temp.txt."""
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        # Validate the snippet syntax before applying
        if not validate_snippet(snippet):
            print("Modification aborted due to invalid syntax in snippet.")
            return

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        # Ensure the specified line range is valid
        with open(filename, "r") as file:
            file_contents = file.readlines()
        if start_line > len(file_contents) or end_line > len(file_contents) + 1:
            print(f"Invalid line range: {start_line}-{end_line}. File has {len(file_contents)} lines.")
            return

        # Create a backup of the file
        backup_filename = f"{filename}.bak"
        os.rename(filename, backup_filename)
        print(f"Backup created: {backup_filename}")

        # Apply modification
        modified_contents = (
            file_contents[:start_line - 1] + file_contents[end_line:]  # Remove specified lines
        )
        modified_contents.insert(start_line - 1, snippet)  # Insert new snippet

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """Dynamically generates temp.txt based on the parameters provided."""
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()

")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """Rebuilds game.txt by concatenating all .py files in the current directory."""
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("

\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def validate_snippet(snippet):
    """Validates the syntax of a code snippet using Python's AST module."""
    try:
        dedented_snippet = textwrap.dedent(snippet)  # Remove unnecessary indentation
        ast.parse(dedented_snippet)
        print("Snippet is syntactically valid.")
        return True
    except SyntaxError as e:
        print(f"Syntax error in snippet: {e}")
        print("Snippet content:")
        print(snippet)
        return False

def modify_file_from_temp(temp_file="temp.txt"):
    """Modifies a .py file based on instructions from temp.txt."""
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        # Validate the snippet syntax before applying
        if not validate_snippet(snippet):
            print("Modification aborted due to invalid syntax in snippet.")
            return

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        # Ensure the specified line range is valid
        with open(filename, "r") as file:
            file_contents = file.readlines()
        if start_line > len(file_contents) or end_line > len(file_contents) + 1:
            print(f"Invalid line range: {start_line}-{end_line}. File has {len(file_contents)} lines.")
            return

        # Create a backup of the file
        backup_filename = f"{filename}.bak"
        os.rename(filename, backup_filename)
        print(f"Backup created: {backup_filename}")

        # Apply modification
        modified_contents = (
            file_contents[:start_line - 1] + file_contents[end_line:]  # Remove specified lines
        )
        modified_contents.insert(start_line - 1, snippet)  # Insert new snippet

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """Dynamically generates temp.txt based on the parameters provided."""
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()

")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """Rebuilds game.txt by concatenating all .py files in the current directory."""
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("

\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def validate_snippet(snippet):
    """Validates the syntax of a code snippet using Python's AST module."""
    try:
        dedented_snippet = textwrap.dedent(snippet)  # Remove unnecessary indentation
        ast.parse(dedented_snippet)
        print("Snippet is syntactically valid.")
        return True
    except SyntaxError as e:
        print(f"Syntax error in snippet: {e}")
        print("Snippet content:")
        print(snippet)
        return False

def modify_file_from_temp(temp_file="temp.txt"):
    """Modifies a .py file based on instructions from temp.txt."""
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        # Validate the snippet syntax before applying
        if not validate_snippet(snippet):
            print("Modification aborted due to invalid syntax in snippet.")
            return

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        # Ensure the specified line range is valid
        with open(filename, "r") as file:
            file_contents = file.readlines()
        if start_line > len(file_contents) or end_line > len(file_contents) + 1:
            print(f"Invalid line range: {start_line}-{end_line}. File has {len(file_contents)} lines.")
            return

        # Create a backup of the file
        backup_filename = f"{filename}.bak"
        os.rename(filename, backup_filename)
        print(f"Backup created: {backup_filename}")

        # Apply modification
        modified_contents = (
            file_contents[:start_line - 1] + file_contents[end_line:]  # Remove specified lines
        )
        modified_contents.insert(start_line - 1, snippet)  # Insert new snippet

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """Dynamically generates temp.txt based on the parameters provided."""
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()

")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """Rebuilds game.txt by concatenating all .py files in the current directory."""
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("

\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def validate_snippet(snippet):
    """Validates the syntax of a code snippet using Python's AST module."""
    try:
        dedented_snippet = textwrap.dedent(snippet)  # Remove unnecessary indentation
        ast.parse(dedented_snippet)
        print("Snippet is syntactically valid.")
        return True
    except SyntaxError as e:
        print(f"Syntax error in snippet: {e}")
        print("Snippet content:")
        print(snippet)
        return False

def modify_file_from_temp(temp_file="temp.txt"):
    """Modifies a .py file based on instructions from temp.txt."""
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        # Validate the snippet syntax before applying
        if not validate_snippet(snippet):
            print("Modification aborted due to invalid syntax in snippet.")
            return

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        # Ensure the specified line range is valid
        with open(filename, "r") as file:
            file_contents = file.readlines()
        if start_line > len(file_contents) or end_line > len(file_contents) + 1:
            print(f"Invalid line range: {start_line}-{end_line}. File has {len(file_contents)} lines.")
            return

        # Create a backup of the file
        backup_filename = f"{filename}.bak"
        os.rename(filename, backup_filename)
        print(f"Backup created: {backup_filename}")

        # Apply modification
        modified_contents = (
            file_contents[:start_line - 1] + file_contents[end_line:]  # Remove specified lines
        )
        modified_contents.insert(start_line - 1, snippet)  # Insert new snippet

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """Dynamically generates temp.txt based on the parameters provided."""
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()

")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """
    Rebuilds game.txt by concatenating all .py files in the current directory.
    """
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("

\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def modify_file_from_temp(temp_file="temp.txt"):
    """
    Modifies a .py file based on instructions from temp.txt.
    """
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        with open(filename, "r") as file:
            file_contents = file.readlines()

        # Replace lines
        modified_contents = file_contents[:start_line - 1] + file_contents[end_line:]
        modified_contents.insert(start_line - 1, snippet)

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """
    Dynamically generates temp.txt based on the parameters provided.
    """
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()
media_rw
import math

class Tank:
    def __init__(self, canvas, x, y, color="green", ui=None):
        """
        Initializes the Tank object and draws it on the canvas.

        Args:
            canvas (tk.Canvas): The canvas to draw the tank on.
            x (float): The x-coordinate of the tank's center.
            y (float): The y-coordinate of the tank's center.
            color (str): The primary color of the tank (default: green).
            ui (GameUI, optional): An instance of GameUI for logging.
        """
        self.canvas = canvas
        self.x = x
        self.y = y
        self.color = color
        self.ui = ui  # Optional: Reference to GameUI for logging

        # Default angles for hull and turret in degrees
        self.hull_angle = 0
        self.turret_angle = 0

        # Components of the tank
        self.hull = None
        self.turret = None
        self.gun = None

        # Draw the initial tank
        self.draw()

    def draw(self):
        """
        Draws the tank components (hull, turret, gun) on the canvas.
        This method updates their positions and directions.
        """
        self._clear_previous_drawings()

        # Hull dimensions
        hull_width, hull_height = 30, 20
        turret_radius = 8
        gun_length = 20

        # Calculate hull rotation (trigonometric rotation)
        hull_dx = hull_width / 2 * math.cos(math.radians(self.hull_angle))
        hull_dy = hull_width / 2 * math.sin(math.radians(self.hull_angle))
        offset_x = hull_height / 2 * math.sin(math.radians(self.hull_angle))
        offset_y = hull_height / 2 * math.cos(math.radians(self.hull_angle))

        # Define corners of the rotated hull rectangle
        corners = [
            (self.x - hull_dx - offset_x, self.y - hull_dy + offset_y),
            (self.x + hull_dx - offset_x, self.y + hull_dy + offset_y),
            (self.x + hull_dx + offset_x, self.y + hull_dy - offset_y),
            (self.x - hull_dx + offset_x, self.y - hull_dy - offset_y),
        ]

        self.hull = self.canvas.create_polygon(corners, fill=self.color)

        # Turret center remains at the hull's center
        self.turret = self.canvas.create_oval(
            self.x - turret_radius, self.y - turret_radius,
            self.x + turret_radius, self.y + turret_radius,
            fill="darkgreen"
        )

        # Gun end point based on turret_angle
        gun_dx = gun_length * math.cos(math.radians(self.turret_angle))
        gun_dy = gun_length * math.sin(math.radians(self.turret_angle))
        self.gun = self.canvas.create_line(
            self.x, self.y,
            self.x + gun_dx, self.y + gun_dy,
            fill="black", width=3
        )

    def _clear_previous_drawings(self):
        """
        Clears the previous drawings of the tank components before redrawing.
        """
        if self.hull:
            self.canvas.delete(self.hull)
        if self.turret:
            self.canvas.delete(self.turret)
        if self.gun:
            self.canvas.delete(self.gun)

    def move(self, new_x, new_y):
        """
        Moves the tank to a new position and updates the hull direction.

        Args:
            new_x (float): The new x-coordinate of the tank's center.
            new_y (float): The new y-coordinate of the tank's center.
        """
        # Calculate direction of movement
        dx = new_x - self.x
        dy = new_y - self.y

        # Update hull angle to reflect movement direction
        if dx != 0 or dy != 0:
            self.hull_angle = math.degrees(math.atan2(dy, dx))

        # Update position and redraw
        self.x = new_x
        self.y = new_y
        self.draw()

    def aim_turret(self, target_x, target_y):
        """
        Rotates the turret to point at a specific target and logs the calculation.

        Args:
            target_x (float): The x-coordinate of the target.
            target_y (float): The y-coordinate of the target.
        """
        # Calculate direction to target
        dx = target_x - self.x
        dy = target_y - self.y

        # Update turret angle to face the target
        if dx != 0 or dy != 0:
            angle_radians = math.atan2(dy, dx)  # Angle in radians
            self.turret_angle = math.degrees(angle_radians)  # Convert to degrees

            # Log debug info in the game log window
            if self.ui:
                debug_message = (f"Turret Aiming: dx={dx}, dy={dy}, "
                                 f"angle_radians={angle_radians:.4f}, "
                                 f"turret_angle={self.turret_angle:.2f}Â°")
                self.ui.update_log(f"[DEBUG] {debug_message}")

        # Redraw the tank to update turret direction
        self.draw()
media_rw
import tkinter as tk
import random
from GameUI import GameUI
from TerrainManager import TerrainManager
from PlayerManager import PlayerManager
from EnemyManager import EnemyManager
from CombatManager import CombatManager
from bomber import Bomber  # Import the new Bomber class
import math

class TacticalMap:
    def __init__(self, root, on_replay=None):
        """
        Initializes the TacticalMap, setting up game managers and the UI.

        Args:
            root (tk.Tk): The root window for the game.
            on_replay (callable): Optional callback function to restart the game.
        """
        self.root = root
        self.ui = GameUI(root)
        self.terrain_manager = TerrainManager(self.ui.grid_elements, self.ui.canvas)
        self.player_manager = PlayerManager(self.ui.grid_elements, self.terrain_manager, self.ui)
        self.enemy_manager = EnemyManager(self.ui.grid_elements, self.terrain_manager, enemy_count=5, ui=self.ui)
        self.combat_manager = CombatManager(
            self.ui.grid_elements,
            player_stats={"name": "T-64 Tank", "hp": 20, "ammo": 5},
            enemy_stats={"name": "Enemy Unit", "hp": 10},
            ui=self.ui,
            player_manager=self.player_manager
        )
        self.bomber = None  # Bomber instance for debugging purposes
        self.on_replay = on_replay
        self.turn = "Player"
        self.grid_rows = 7
        self.grid_cols = 7
        self.determine_grid_dimensions()
        self.initialize_game()

    def determine_grid_dimensions(self):
        """
        Dynamically sets grid dimensions based on screen size.
        """
        screen_width = self.ui.root.winfo_screenwidth()
        screen_height = self.ui.root.winfo_screenheight()

        usable_width = int(screen_width * 0.95)
        usable_height = int(screen_height * 0.90)

        tile_size = 50
        self.grid_cols = max(1, usable_width // tile_size)
        self.grid_rows = max(1, usable_height // tile_size)

        self.ui.canvas.config(width=usable_width, height=usable_height)

    def initialize_game(self):
        """
        Sets up the game grid, generates terrain, deploys units, and renders the bomber. Retries if necessary.
        """
        self.ui.create_map(rows=self.grid_rows, cols=self.grid_cols, cell_click_callback=self.on_cell_click)

        for _ in range(5): 
            if self.terrain_manager.generate_terrain(enemy_count=5):
                try:
                    player_pos = self.player_manager.deploy_player()
                    self.enemy_manager.deploy_enemies()
                    self.ui.update_log(f"Game initialized. Player spawned at: {player_pos}")

                    # Render the bomber for debugging purposes
                    self.deploy_bomber_debug(x=200, y=150)  # Example coordinates on the canvas
                    return
                except ValueError:
                    self.ui.update_log("Deployment failed. Retrying...")
        self.ui.update_log("Failed to initialize game.")
        self.end_game(victory=False)

    def deploy_bomber_debug(self, x, y):
        """
        Renders the Myasischev M4 Bison bomber on the map for debugging purposes.

        Args:
            x (float): The x-coordinate on the canvas.
            y (float): The y-coordinate on the canvas.
        """
        self.bomber = Bomber(self.ui.canvas, x=x, y=y, ui=self.ui)
        self.ui.update_log("[DEBUG] Bomber rendered on the map for testing.")

    def on_cell_click(self, coord):
        """
        Handles a player's action when a cell is clicked.

        Args:
            coord (str): The coordinate of the clicked cell.
        """
        if self.turn == "Player":
            # Update hull orientation immediately
            player_position = self.player_manager.player_position
            dx = int(coord[1:]) - int(player_position[1:])
            dy = ord(coord[0]) - ord(player_position[0])

            if dx != 0 or dy != 0:
                self.player_manager.hull_angle = math.degrees(math.atan2(dy, dx))
                self.ui.draw_tank(player_position, self.player_manager.hull_angle, self.player_manager.turret_angle)
                self.ui.update_log(f"[DEBUG] Hull angle updated to {self.player_manager.hull_angle:.2f}Â° on click.")

            self.handle_player_action(coord)

    def handle_player_action(self, coord):
        """
        Processes the player's action: move, attack, or use artillery.

        Args:
            coord (str): The target cell coordinate.
        """
        player_position = self.player_manager.player_position
        distance_row = abs(ord(coord[0]) - ord(player_position[0]))
        distance_col = abs(int(coord[1:]) - int(player_position[1:]))

        # Handle artillery attack
        if max(distance_row, distance_col) > 1:
            if self.player_manager.player_stats["ammo"] > 0:
                results = self.combat_manager.artillery_attack(coord, self.enemy_manager.enemy_positions)
                self.player_manager.player_stats["ammo"] -= 1
                for result in results:
                    self.ui.update_log(result)
                self.ui.update_log(f"Artillery fired. Ammo left: {self.player_manager.player_stats['ammo']}")
                self.end_turn()
            else:
                self.ui.update_log("No ammo left!")
            return

        # Handle adjacent move or attack
        if max(distance_row, distance_col) == 1:
            terrain = self.terrain_manager.get_terrain(coord)
            if coord in self.enemy_manager.enemy_positions:
                result = self.combat_manager.player_attack(coord, self.enemy_manager.enemy_positions)
                self.ui.update_log(result)
                if not self.enemy_manager.enemy_positions:
                    self.end_game(victory=True)
            elif terrain in ["Empty", "Forest"]:
                self.player_manager.move_player_smoothly(coord)
                self.end_turn()
            else:
                self.ui.update_log("Cannot move to that terrain!")
        else:
            self.ui.update_log("Invalid move. Choose an adjacent tile.")

    def enemy_action(self):
        """
        Executes the enemies' turn, including movement and attacks.
        """
        self.ui.update_log("Enemies are taking their turn...")

        for enemy_pos in list(self.enemy_manager.enemy_positions.keys()):
            if self.enemy_manager.is_adjacent(enemy_pos, self.player_manager.player_position):
                result = self.combat_manager.enemy_attack(self.player_manager.player_position)
                self.ui.update_log(result)
                if "Player is defeated!" in result:
                    self.end_game(victory=False)
                    return
            else:
                new_pos = self.enemy_manager.move_toward_player(enemy_pos, self.player_manager.player_position)
                if new_pos != enemy_pos:
                    self.enemy_manager.update_enemy_position(enemy_pos, new_pos)

        if not self.enemy_manager.enemy_positions:
            self.end_game(victory=True)
        else:
            self.end_turn()

    def end_turn(self):
        """
        Alternates turns between the player and the enemies.
        """
        if self.turn == "Player":
            self.turn = "Enemy"
            self.enemy_action()
        else:
            self.turn = "Player"
            self.ui.update_log("Your turn!")

    def end_game(self, victory):
        """
        Concludes the game with a victory or defeat message.
        """
        message = "You Win!" if victory else "Game Over!"
        self.ui.update_log(message)
        restart_command = self.on_replay if self.on_replay is not None else self.reset
        self.ui.display_game_over_overlay(message, restart_command=restart_command)

    def reset(self):
        """
        Resets the TacticalMap to its initial state for a new game.
        """
        self.ui.reset()
        self.terrain_manager.reset()
        self.player_manager.reset()
        self.enemy_manager.reset()
        self.combat_manager = CombatManager(
            self.ui.grid_elements,
            player_stats={"name": "T-64 Tank", "hp": 20, "ammo": 5},
            enemy_stats={"name": "Enemy Unit", "hp": 10},
            ui=self.ui,
            player_manager=self.player_manager
        )
        self.turn = "Player"
        self.initialize_game()


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Turn-Based Tactical Simulation")
    game = TacticalMap(root)
    root.mainloop()
media_rw
class CombatManager:
    def __init__(self, grid_elements, player_stats, enemy_stats, ui, player_manager):
        """
        Initializes the CombatManager with references to the grid elements,
        the player's statistics, the enemy's statistics, the GameUI, and the PlayerManager.

        Args:
            grid_elements (dict): Dictionary of canvas rectangles for the grid.
            player_stats (dict): Dictionary containing player stats (e.g., {"hp": 20, "ammo": 5}).
            enemy_stats (dict): Dictionary containing enemy stats (e.g., {"hp": 10}).
            ui (GameUI): Instance of GameUI for rendering on the canvas.
            player_manager (PlayerManager): Instance of PlayerManager for managing the player.
        """
        self.grid_elements = grid_elements
        self.player_stats = player_stats
        self.enemy_stats = enemy_stats
        self.ui = ui  # Reference to the GameUI
        self.player_manager = player_manager  # Reference to the PlayerManager for turret updates

    def player_attack(self, target_coord, enemy_positions):
        """
        Handles the player's attack on an enemy unit and aims the turret at the target.

        Args:
            target_coord (str): The coordinate of the enemy being attacked.
            enemy_positions (dict): A dictionary mapping enemy positions to their HP.

        Returns:
            str: A message describing the outcome of the attack.
        """
        # Aim the turret at the target coordinate
        self.player_manager.aim_turret(target_coord)

        if target_coord in enemy_positions:
            enemy_positions[target_coord] -= 5  # Damage the enemy by 5 points
            if enemy_positions[target_coord] <= 0:
                del enemy_positions[target_coord]  # Remove defeated enemy
                self.ui.update_cell(target_coord, "Empty", "lightgray")  # Clear cell
                return f"Enemy at {target_coord} is defeated!"
            else:
                return f"Enemy at {target_coord} HP reduced to {enemy_positions[target_coord]}."
        return "No enemy to attack at the selected position."

    def artillery_attack(self, target_coord, enemy_positions):
        """
        Handles artillery attack, which damages the target coordinate and adjacent tiles.
        Aims the turret at the primary target coordinate.

        Args:
            target_coord (str): The main target coordinate for the artillery attack.
            enemy_positions (dict): A dictionary mapping enemy positions to their HP.

        Returns:
            list: A list of messages describing the outcomes at each affected coordinate.
        """
        # Aim the turret at the primary target coordinate
        self.player_manager.aim_turret(target_coord)

        results = []
        row = ord(target_coord[0])
        col = int(target_coord[1:])

        # Generate a list of affected coordinates (target + adjacent)
        affected_coords = [
            target_coord,
            f"{chr(row - 1)}{col}",
            f"{chr(row + 1)}{col}",
            f"{chr(row)}{col - 1}",
            f"{chr(row)}{col + 1}"
        ]

        self.ui.update_log(f"[DEBUG] Artillery targeted at {target_coord}. Affected coordinates: {affected_coords}")

        for coord in affected_coords:
            if coord in enemy_positions:
                enemy_positions[coord] -= 10  # Artillery deals 10 damage
                if enemy_positions[coord] <= 0:
                    del enemy_positions[coord]
                    self.ui.update_cell(coord, "Empty", "lightgray")
                    results.append(f"Enemy at {coord} destroyed by artillery.")
                else:
                    results.append(f"Enemy at {coord} hit by artillery. HP now {enemy_positions[coord]}.")
            elif coord in self.grid_elements:
                results.append(f"Artillery hit {coord}, but no enemies present.")

        return results

    def enemy_attack(self, player_position):
        """
        Handles the enemy's attack on the player.

        Args:
            player_position (str): The current position of the player.

        Returns:
            str: A message describing the result of the enemy's attack.
        """
        self.player_stats["hp"] -= 5  # Enemy deals a fixed 5 damage
        if self.player_stats["hp"] <= 0:
            return "Player is defeated!"
        else:
            return f"Player HP reduced to {self.player_stats['hp']}."

    def is_adjacent(self, pos1, pos2):
        """
        Determines if two grid positions are adjacent (including diagonally).

        Args:
            pos1 (str): The first grid position (e.g., "A1").
            pos2 (str): The second grid position (e.g., "B2").

        Returns:
            bool: True if the two positions share a side or corner, False otherwise.
        """
        row_diff = abs(ord(pos1[0]) - ord(pos2[0]))
        col_diff = abs(int(pos1[1:]) - int(pos2[1:]))
        return max(row_diff, col_diff) == 1

    def reset(self, player_stats=None, enemy_stats=None):
        """
        Resets the CombatManager to its initial state for a new game.

        Args:
            player_stats (dict, optional): Updated stats for the player.
            enemy_stats (dict, optional): Updated stats for the enemies.
        """
        self.player_stats = player_stats if player_stats else {"hp": 20, "ammo": 5}
        self.enemy_stats = enemy_stats if enemy_stats else {"hp":"10"}
media_rw
import random

class EnemyManager:
    def __init__(self, grid_elements, terrain_manager, enemy_count, ui):
        """
        Initializes the EnemyManager with references to the grid elements, terrain manager,
        the number of enemy units, and the GameUI instance.

        Args:
            grid_elements (dict): Dictionary of canvas rectangles for the grid.
            terrain_manager (TerrainManager): Instance of TerrainManager for managing terrains.
            enemy_count (int): Number of enemy units to deploy.
            ui (GameUI): Instance of GameUI for rendering on the canvas.
        """
        self.grid_elements = grid_elements  # Reference to canvas elements for the grid
        self.terrain_manager = terrain_manager  # Reference to terrain manager
        self.enemy_positions = {}  # Dictionary to track enemy positions and their HP
        self.enemy_count = enemy_count  # Number of enemy units
        self.ui = ui  # Reference to the GameUI

    def deploy_enemies(self):
        """
        Deploys enemy units on random empty tiles and renders them on the canvas.

        Returns:
            list: A list of coordinates where the enemies are deployed.

        Raises:
            ValueError: If there are not enough empty spaces for deployment.
        """
        empty_cells = [
            coord for coord, terr in self.terrain_manager.terrain.items()
            if terr == "Empty" and coord not in self.enemy_positions
        ]
        if len(empty_cells) < self.enemy_count:
            raise ValueError("Not enough empty spaces to deploy enemies.")

        for coord in random.sample(empty_cells, self.enemy_count):
            self.enemy_positions[coord] = 10  # Assign 10 HP to each enemy
            self.ui.update_cell(coord, "Enemy", "red")  # Render the enemy in red
        return list(self.enemy_positions.keys())

    def move_toward_player(self, enemy_position, player_position):
        """
        Moves an enemy unit toward the player. Handles terrain crossing probabilities.

        Args:
            enemy_position (str): The current position of the enemy unit.
            player_position (str): The current position of the player unit.

        Returns:
            str: The new position of the enemy unit.
        """
        enemy_row, enemy_col = ord(enemy_position[0]), int(enemy_position[1:])
        player_row, player_col = ord(player_position[0]), int(player_position[1:])

        dr = player_row - enemy_row
        dc = player_col - enemy_col

        # Determine direction of movement
        if abs(dr) > abs(dc):
            new_pos = f"{chr(enemy_row + (1 if dr > 0 else -1))}{enemy_col}"
        else:
            new_pos = f"{chr(enemy_row)}{enemy_col + (1 if dc > 0 else -1)}"

        # Validate and attempt the move
        if new_pos in self.grid_elements and enemy_position in self.enemy_positions:
            terrain = self.terrain_manager.get_terrain(new_pos)
            if terrain == "Water":
                if random.random() < 0.5:  # 50% chance to cross
                    self.update_enemy_position(enemy_position, new_pos)
                    return new_pos
                else:
                    return enemy_position
            elif terrain == "Mountain":
                if random.random() < 0.3:  # 30% chance to cross
                    self.update_enemy_position(enemy_position, new_pos)
                    return new_pos
                else:
                    return enemy_position
            elif terrain in ["Empty", "Forest"]:
                self.update_enemy_position(enemy_position, new_pos)
                return new_pos

        # Stay in place if move is invalid
        return enemy_position

    def update_enemy_position(self, old_position, new_position):
        """
        Updates the enemy's position on the canvas.

        Args:
            old_position (str): The previous position of the enemy.
            new_position (str): The new position of the enemy.
        """
        # Validate positions
        if old_position not in self.enemy_positions:
            print(f"[DEBUG] Invalid old_position: {old_position}. Cannot move enemy.")
            return
        if new_position in self.enemy_positions:
            print(f"[DEBUG] Collision detected! {new_position} is already occupied.")
            return

        # Clear the old position and update the new one
        self.ui.update_cell(old_position, "Empty", "lightgray")
        self.ui.update_cell(new_position, "Enemy", "red")
        self.enemy_positions[new_position] = self.enemy_positions.pop(old_position)

    def is_adjacent(self, pos1, pos2):
        """
        Checks if two positions are adjacent on the grid.

        Args:
            pos1 (str): The first position (e.g., "A1").
            pos2 (str): The second position (e.g., "B2").

        Returns:
            bool: True if the positions are adjacent, False otherwise.
        """
        row_diff = abs(ord(pos1[0]) - ord(pos2[0]))
        col_diff = abs(int(pos1[1:]) - int(pos2[1:]))
        return max(row_diff, col_diff) == 1

    def reset(self):
        """
        Resets the EnemyManager to its initial state for a new game.
        """
        # Clear enemy positions and reset the canvas
        for coord in list(self.enemy_positions.keys()):
            self.ui.update_cell(coord, "Empty", "lightgray")
        self.enemy_positions.clear()
media_rw
import tkinter as tk
from tkinter import ttk
import math

class GameUI:
    def __init__(self, root):
        """
        Initializes the GameUI with a scrollable map (canvas-based),
        log area, and tank rendering.
        """
        self.root = root

        # Main container for layout organization
        self.main_frame = tk.Frame(self.root)
        self.main_frame.pack(fill="both", expand=True)

        # Create a canvas for the map with vertical and horizontal scrollbars
        self.canvas = tk.Canvas(self.main_frame, bg="white", width=800, height=600)
        self.scrollbar_y = ttk.Scrollbar(self.main_frame, orient="vertical", command=self.canvas.yview)
        self.scrollbar_x = ttk.Scrollbar(self.main_frame, orient="horizontal", command=self.canvas.xview)
        self.canvas.configure(yscrollcommand=self.scrollbar_y.set, xscrollcommand=self.scrollbar_x.set)
        self.scrollbar_y.pack(side="right", fill="y")
        self.scrollbar_x.pack(side="bottom", fill="x")
        self.canvas.pack(side="left", fill="both", expand=True)

        # Internal data structures for managing canvas elements
        self.grid_elements = {}    # Holds grid rectangle IDs and their coordinates
        self.cell_states = {}      # Stores each cell's current state (terrain, units, etc.)
        self.tank_graphics = {}    # Tracks the tank's graphical components

        # Log area for messages
        self.log_area = None
        self.create_log_area()

    def create_log_area(self):
        """
        Creates a text area to display the game log.
        """
        self.log_area = tk.Text(self.root, height=5, wrap="word", bg="lightyellow")
        self.log_area.pack(side="bottom", fill="x")
        self.log_area.configure(state="disabled")

    def create_map(self, rows, cols, cell_click_callback):
        """
        Creates a dynamically sized map grid using canvas rectangles.

        Args:
            rows (int): Number of rows in the grid.
            cols (int): Number of columns in the grid.
            cell_click_callback (callable): Function to call when a cell is clicked.
        """
        self.grid_elements.clear()
        self.cell_states.clear()

        cell_width = 50
        cell_height = 50

        for row in range(rows):
            for col in range(cols):
                coord = f"{chr(65 + row)}{col + 1}"  # e.g., A1, B1, etc.
                x1, y1 = col * cell_width, row * cell_height
                x2, y2 = x1 + cell_width, y1 + cell_height

                rect_id = self.canvas.create_rectangle(x1, y1, x2, y2, fill="lightgray", outline="black")
                self.grid_elements[coord] = rect_id
                self.cell_states[coord] = "Empty"
                self.canvas.tag_bind(rect_id, "<Button-1>", lambda event, c=coord: cell_click_callback(c))

    def update_log(self, message):
        """
        Appends a message to the log area.

        Args:
            message (str): The message to display.
        """
        if self.log_area:
            self.log_area.configure(state="normal")
            self.log_area.insert(tk.END, message + "\n")
            self.log_area.see(tk.END)
            self.log_area.configure(state="disabled")

    def draw_tank(self, coord, hull_angle=0, turret_angle=0):
        """
        Draws a tank at the specified coordinate, adjusting its hull and turret direction.

        Args:
            coord (str): The grid coordinate (e.g., "A1").
            hull_angle (float): The angle of the hull (in degrees).
            turret_angle (float): The angle of the turret (in degrees).
        """
        if coord not in self.grid_elements:
            print(f"[LOG] {coord} is not a valid coordinate.")
            return

        self.clear_tank()

        rect_id = self.grid_elements[coord]
        x1, y1, x2, y2 = self.canvas.coords(rect_id)
        center_x = (x1 + x2) / 2
        center_y = (y1 + y2) / 2

        # Dimensions
        hull_width, hull_height = 30, 20
        turret_radius = 8
        gun_length = 20

        # Calculate hull corners based on the hull angle
        hull_dx = hull_width / 2 * math.cos(math.radians(hull_angle))
        hull_dy = hull_width / 2 * math.sin(math.radians(hull_angle))
        offset_x = hull_height / 2 * math.sin(math.radians(hull_angle))
        offset_y = hull_height / 2 * math.cos(math.radians(hull_angle))

        hull_corners = [
            (center_x - hull_dx - offset_x, center_y - hull_dy + offset_y),
            (center_x + hull_dx - offset_x, center_y + hull_dy + offset_y),
            (center_x + hull_dx + offset_x, center_y + hull_dy - offset_y),
            (center_x - hull_dx + offset_x, center_y - hull_dy - offset_y),
        ]

        # Draw the hull
        self.tank_graphics["hull"] = self.canvas.create_polygon(hull_corners, fill="green")

        # Draw the turret
        self.tank_graphics["turret"] = self.canvas.create_oval(
            center_x - turret_radius, center_y - turret_radius,
            center_x + turret_radius, center_y + turret_radius,
            fill="darkgreen"
        )

        # Draw the gun
        gun_dx = gun_length * math.cos(math.radians(turret_angle))
        gun_dy = gun_length * math.sin(math.radians(turret_angle))
        self.tank_graphics["gun"] = self.canvas.create_line(
            center_x, center_y,
            center_x + gun_dx, center_y + gun_dy,
            fill="black", width=3
        )

        print(f"[LOG] Tank drawn at {coord} with hull_angle={hull_angle}Â° and turret_angle={turret_angle}Â°")

    def clear_tank(self):
        """
        Clears all tank graphics from the canvas.
        """
        for part in self.tank_graphics.values():
            self.canvas.delete(part)
        self.tank_graphics.clear()

    def update_cell(self, coord, terrain_type, color):
        """
        Updates the visual appearance of a cell on the grid.

        Args:
            coord (str): The coordinate of the cell (e.g., "A1").
            terrain_type (str): The terrain type designation (e.g., "Forest").
            color (str): The fill color for the cell.
        """
        if coord in self.grid_elements:
            rect_id = self.grid_elements[coord]
            self.canvas.itemconfig(rect_id, fill=color)
            self.cell_states[coord] = terrain_type

    def display_game_over_overlay(self, message, restart_command=None):
        """
        Displays a game over overlay on the canvas along with a 'Play Again' button if provided.

        Args:
            message (str): A message to display (e.g., "You Win!" or "Game Over!").
            restart_command (callable, optional): Function to call when the play-again button is clicked.
        """
        width = self.canvas.winfo_width()
        height = self.canvas.winfo_height()

        # Create a semi-transparent overlay
        self.canvas.create_rectangle(0, 0, width, height, fill="black", stipple="gray50", tags="game_over_overlay")

        # Display the game over message
        self.canvas.create_text(
            width // 2, height // 2,
            text=message,
            fill="white",
            font=("Helvetica", 32, "bold"),
            tags="game_over_text"
        )

        if restart_command:
            restart_button = tk.Button(self.root, text="Play Again", command=restart_command, bg="green", fg="white")
            self.canvas.create_window(width // 2, height // 2 + 50, window=restart_button, tags="restart_button")
        
        print(f"[LOG] Game Over overlay displayed with message: {message}")

    def reset(self):
        """
        Resets the GameUI: clears canvas elements, grid, and log.
        """
        self.canvas.delete("all")
        self.grid_elements.clear()
        self.cell_states.clear()
        self.tank_graphics.clear()
        if self.log_area:
            self.log_area.configure(state="normal")
            self.log_area.delete(1.0, tk.END)
            self.log_area.configure(state="disabled")
media_rw
import random
import math

class PlayerManager:
    def __init__(self, grid_elements, terrain_manager, ui):
        """
        Initializes the PlayerManager with references to the grid elements, terrain manager, and GameUI.

        Args:
            grid_elements (dict): Dictionary of canvas rectangles for the grid.
            terrain_manager (TerrainManager): Instance of TerrainManager for managing terrains.
            ui (GameUI): Instance of GameUI for drawing and managing the UI.
        """
        self.grid_elements = grid_elements
        self.terrain_manager = terrain_manager
        self.ui = ui  # Reference to the GameUI
        self.player_position = None
        self.player_stats = {"hp": 20, "ammo": 1}  # Default player stats
        self.hull_angle = 0  # Hull starts facing default direction
        self.turret_angle = 0  # Turret aligns with hull initially

    def deploy_player(self):
        """
        Deploys the player unit on a random empty tile and displays the tank graphic.

        Returns:
            str: The coordinate of the deployed player unit.

        Raises:
            ValueError: If deployment fails after multiple attempts.
        """
        for _ in range(10):  # Retry up to 10 times for deployment
            self.player_position = random.choice(list(self.grid_elements.keys()))
            if self.terrain_manager.get_terrain(self.player_position) == "Empty":
                # Draw the player's tank on the selected coordinate
                self.ui.draw_tank(self.player_position, self.hull_angle, self.turret_angle)
                self.ui.update_log(f"[DEBUG] Player deployed at: {self.player_position}")
                return self.player_position

        raise ValueError("Failed to deploy player unit after multiple attempts.")

    def move_player_smoothly(self, target_position):
        """
        Smoothly moves the player unit to a specified target position and adjusts the hull angle.

        Args:
            target_position (str): The coordinate to move the player unit to.

        Returns:
            str: The new position of the player unit.
        """
        if target_position not in self.grid_elements:
            self.ui.update_log(f"[LOG] Invalid target position: {target_position}")
            return self.player_position

        # Calculate direction of movement
        start_coord = self.player_position
        dx = int(target_position[1:]) - int(start_coord[1:])  # Horizontal difference
        dy = ord(target_position[0]) - ord(start_coord[0])  # Vertical difference

        # Update the hull angle immediately
        if dx != 0 or dy != 0:
            self.hull_angle = math.degrees(math.atan2(dy, dx))  # Proper angle calculation
            self.ui.update_log(f"[DEBUG] Hull angle updated to {self.hull_angle:.2f}Â° on movement.")

        # Animate the movement
        self._animate_tank_smoothly(target_position)

        # Update player's position
        self.player_position = target_position
        self.ui.update_log(f"[DEBUG] Player moved to {self.player_position}, Hull angle: {self.hull_angle:.2f}Â°")
        return self.player_position

    def _animate_tank_smoothly(self, target_position, steps=10):
        """
        Animates the tank's movement from its current position to the target position.

        Args:
            target_position (str): The coordinate to move the tank to.
            steps (int): Number of animation steps to transition smoothly.
        """
        rect_id_start = self.grid_elements[self.player_position]
        rect_id_end = self.grid_elements[target_position]

        # Get coordinates for animation
        x1, y1, x2, y2 = self.ui.canvas.coords(rect_id_start)
        start_x, start_y = (x1 + x2) / 2, (y1 + y2) / 2
        tx1, ty1, tx2, ty2 = self.ui.canvas.coords(rect_id_end)
        end_x, end_y = (tx1 + tx2) / 2, (ty1 + ty2) / 2

        dx = (end_x - start_x) / steps
        dy = (end_y - start_y) / steps

        def move_step(step=0):
            if step > steps:
                # Redraw tank at final position with updated hull angle
                self.ui.draw_tank(target_position, self.hull_angle, self.turret_angle)
                return
            self.ui.canvas.move(self.ui.tank_graphics["hull"], dx, dy)
            self.ui.canvas.move(self.ui.tank_graphics["turret"], dx, dy)
            self.ui.canvas.move(self.ui.tank_graphics["gun"], dx, dy)
            self.ui.canvas.after(50, move_step, step + 1)

        move_step()

    def aim_turret(self, target_position):
        """
        Adjusts the turret to point at the specified target position and logs the calculations.

        Args:
            target_position (str): The coordinate to aim the turret at.
        """
        if target_position not in self.grid_elements:
            self.ui.update_log(f"[LOG] Invalid target position: {target_position}")
            return

        # Calculate direction to target
        current_coord = self.player_position
        dx = int(target_position[1:]) - int(current_coord[1:])
        dy = ord(target_position[0]) - ord(current_coord[0])

        if dx != 0 or dy != 0:
            self.turret_angle = math.degrees(math.atan2(dy, dx))
            self.ui.update_log(f"[DEBUG] Turret aimed at {target_position}, Turret angle: {self.turret_angle:.2f}Â°")

        # Redraw tank to update turret orientation
        self.ui.draw_tank(self.player_position, self.hull_angle, self.turret_angle)

    def heal_player(self, amount):
        """
        Heals the player by a specified amount.

        Args:
            amount (int): The amount of health to restore.
        """
        self.player_stats["hp"] += amount
        if self.player_stats["hp"] > 20:  # Cap at max health
            self.player_stats["hp"] = 20
        self.ui.update_log(f"Player healed. Current HP: {self.player_stats['hp']}")

    def use_ammo(self):
        """
        Reduces the player's ammo by 1 when artillery is fired.

        Returns:
            bool: True if ammo was used successfully, False if no ammo is left.
        """
        if self.player_stats["ammo"] > 0:
            self.player_stats["ammo"] -= 1
            self.ui.update_log(f"[LOG] Ammo used. Remaining ammo: {self.player_stats['ammo']}")
            return True
        self.ui.update_log(f"[LOG] No ammo left!")
        return False

    def reset(self):
        """
        Resets the PlayerManager to its initial state for a new game.
        """
        self.player_position = None
        self.player_stats = {"hp": 20, "ammo": 1}  # Reset health and ammo
        self.hull_angle = 0
        self.turret_angle = 0
        self.ui.update_log(f"[LOG] PlayerManager reset. Stats: {self.player_stats}")
media_rw
import random

class UnitManager:
    def __init__(self, map_buttons, terrain_manager, enemy_count):
        """
        Initializes the UnitManager with references to map buttons, terrain, and enemy count.
        """
        self.map_buttons = map_buttons  # Reference to the map buttons
        self.terrain_manager = terrain_manager  # Reference to the terrain manager
        self.player_position = "A1"  # Initial player position
        self.enemy_positions = []  # List of enemy positions
        self.enemy_count = enemy_count  # Total number of enemies to deploy

    def deploy_player(self, player_unit_name):
        """
        Deploys the player unit on a random empty tile.
        """
        for _ in range(5):  # Retry up to 5 times for deployment
            self.player_position = random.choice(list(self.map_buttons.keys()))
            if self.terrain_manager.get_terrain(self.player_position) == "Empty":
                self.map_buttons[self.player_position].config(text=player_unit_name, bg="blue")
                return self.player_position
        # Raise an exception if deployment fails
        raise ValueError("Failed to deploy player unit. Restart required.")

    def deploy_enemies(self, enemy_unit_name):
        """
        Deploys enemy units on random empty tiles.
        """
        empty_cells = [
            coord for coord, terr in self.terrain_manager.terrain.items()
            if terr == "Empty" and self.map_buttons[coord].cget("text") == "Empty"
        ]
        if len(empty_cells) < self.enemy_count:
            raise ValueError("Not enough empty spaces to deploy enemies.")

        self.enemy_positions = random.sample(empty_cells, self.enemy_count)
        for enemy_position in self.enemy_positions:
            self.map_buttons[enemy_position].config(text=enemy_unit_name, bg="red")
        return self.enemy_positions

    def move_unit(self, current_position, target_position, unit_name):
        """
        Moves a unit from the current position to the target position.
        """
        self.map_buttons[current_position].config(text="Empty", bg="lightgray")
        self.map_buttons[target_position].config(text=unit_name, bg="blue")
        return target_position

    def move_enemy(self, enemy_position, target_position, enemy_name):
        """
        Moves an enemy unit from the current position to the target position.
        """
        self.map_buttons[enemy_position].config(text="Empty", bg="lightgray")
        self.map_buttons[target_position].config(text=enemy_name, bg="red")
        return target_position

    def is_adjacent(self, pos1, pos2):
        """
        Determines whether two positions on the map are adjacent.
        """
        row_diff = abs(ord(pos1[0]) - ord(pos2[0]))
        col_diff = abs(int(pos1[1]) - int(pos2[1]))
        return max(row_diff, col_diff) == 1
media_rw
import random

class TerrainManager:
    def __init__(self, grid_elements, canvas):
        """
        Initializes the TerrainManager with references to the grid elements and canvas.

        Args:
            grid_elements (dict): Dictionary of canvas rectangles for the grid.
            canvas (tk.Canvas): The canvas object to update terrain appearance.
        """
        self.grid_elements = grid_elements  # Reference to the grid elements
        self.canvas = canvas  # Reference to the canvas
        self.terrain = {}  # Dictionary to store terrain types for each cell

    def generate_terrain(self, enemy_count, extra_empty=5):
        """
        Generates terrain for the map and ensures a minimum number of empty tiles.

        Args:
            enemy_count (int): Number of enemies to deploy (affects empty tiles needed).
            extra_empty (int): Extra empty tiles to ensure playability.

        Returns:
            bool: True if terrain generation is successful, False otherwise.
        """
        retries = 5  # Maximum number of attempts to generate a valid map
        for _ in range(retries):
            self.terrain.clear()
            empty_count = 0

            # Randomly assign terrain types to each cell
            for coord in self.grid_elements.keys():
                terrain_type = random.choice(["Forest", "Mountain", "Water", "Empty"])
                self.terrain[coord] = terrain_type
                if terrain_type == "Empty":
                    empty_count += 1

            # Check if enough empty tiles are available
            if empty_count >= enemy_count + extra_empty:
                self._apply_terrain_to_canvas()
                return True  # Successful generation

        return False  # Failed to generate a valid map after retries

    def _apply_terrain_to_canvas(self):
        """
        Applies the generated terrain to the canvas, updating its appearance.
        """
        for coord, terrain_type in self.terrain.items():
            rect_id = self.grid_elements.get(coord)
            if rect_id:  # Ensure the coordinate exists in the grid
                if terrain_type == "Forest":
                    self._update_canvas_cell(rect_id, "green")
                elif terrain_type == "Mountain":
                    self._update_canvas_cell(rect_id, "brown")
                elif terrain_type == "Water":
                    self._update_canvas_cell(rect_id, "blue")
                elif terrain_type == "Empty":
                    self._update_canvas_cell(rect_id, "lightgray")

    def _update_canvas_cell(self, rect_id, color):
        """
        Updates the appearance of a canvas cell based on the given color.

        Args:
            rect_id (int): The ID of the rectangle on the canvas.
            color (str): The fill color for the rectangle.
        """
        self.canvas.itemconfig(rect_id, fill=color)

    def get_terrain(self, coord):
        """
        Gets the terrain type for a specific coordinate.

        Args:
            coord (str): The map coordinate (e.g., "A1").

        Returns:
            str: The terrain type (e.g., "Forest", "Mountain", "Water", or "Empty").
        """
        return self.terrain.get(coord, "Unknown")

    def reset(self):
        """
        Resets the TerrainManager to its initial state for a new game.
        """
        # Clear current terrain and reset the canvas cells to default "Empty" state
        self.terrain.clear()
        for coord, rect_id in self.grid_elements.items():
            self._update_canvas_cell(rect_id, "lightgray")
media_rw
import math
from tank import Tank  # Ensure consistent lowercase import

class Bomber(Tank):
    def __init__(self, canvas, x, y, color="gray", ui=None):
        """
        Initializes the Bomber object and ensures that all attributes are properly initialized.

        Args:
            canvas (tk.Canvas): The canvas to draw the bomber on.
            x (float): The x-coordinate of the bomber's center.
            y (float): The y-coordinate of the bomber's center.
            color (str): The primary color of the bomber (default: gray).
            ui (GameUI, optional): An instance of GameUI for logging.
        """
        # Initialize bomber-specific components to avoid AttributeError
        self.body = None
        self.wings = None
        self.engines = []
        self.turrets = []
        self.soviet_star = None

        # Now call the parent constructor
        super().__init__(canvas, x, y, color, ui)

        print("[DEBUG] Bomber initialized successfully with all attributes set.")

    def draw(self):
        """
        Draws the bomber components (body, engines, wings, turrets) on the canvas.
        """
        print("[DEBUG] Entering draw() method.")
        self._clear_previous_drawings()

        # Bomber dimensions
        body_width, body_height = 80, 30
        wing_span = 100
        engine_radius = 8
        turret_radius = 5

        # Draw body (fuselage)
        self.body = self.canvas.create_oval(
            self.x - body_width / 2, self.y - body_height / 2,
            self.x + body_width / 2, self.y + body_height / 2,
            fill=self.color
        )
        print("[DEBUG] Bomber body created.")

        # Draw wings
        self.wings = self.canvas.create_line(
            self.x - wing_span / 2, self.y,
            self.x + wing_span / 2, self.y,
            fill="darkgray", width=3
        )
        print("[DEBUG] Bomber wings created.")

        # Draw engines (4 total, 2 on each wing root)
        self.engines = [
            self.canvas.create_oval(
                self.x - 30 - engine_radius, self.y - 10 - engine_radius,
                self.x - 30 + engine_radius, self.y - 10 + engine_radius,
                fill="black"
            ),
            self.canvas.create_oval(
                self.x - 30 - engine_radius, self.y + 10 - engine_radius,
                self.x - 30 + engine_radius, self.y + 10 + engine_radius,
                fill="black"
            ),
            self.canvas.create_oval(
                self.x + 30 - engine_radius, self.y - 10 - engine_radius,
                self.x + 30 + engine_radius, self.y - 10 + engine_radius,
                fill="black"
            ),
            self.canvas.create_oval(
                self.x + 30 - engine_radius, self.y + 10 - engine_radius,
                self.x + 30 + engine_radius, self.y + 10 + engine_radius,
                fill="black"
            )
        ]
        print("[DEBUG] Bomber engines created.")

        # Draw turrets
        self.turrets = [
            self.canvas.create_oval(  # Chin turret
                self.x - turret_radius, self.y + body_height / 2 - turret_radius,
                self.x + turret_radius, self.y + body_height / 2 + turret_radius,
                fill="red"
            ),
            self.canvas.create_oval(  # Rear turret
                self.x - turret_radius, self.y - body_height / 2 - turret_radius,
                self.x + turret_radius, self.y - body_height / 2 + turret_radius,
                fill="red"
            ),
            self.canvas.create_oval(  # Left turret
                self.x - body_width / 2 - turret_radius, self.y - turret_radius,
                self.x - body_width / 2 + turret_radius, self.y + turret_radius,
                fill="red"
            ),
            self.canvas.create_oval(  # Right turret
                self.x + body_width / 2 - turret_radius, self.y - turret_radius,
                self.x + body_width / 2 + turret_radius, self.y + turret_radius,
                fill="red"
            )
        ]
        print("[DEBUG] Bomber turrets created.")

        # Draw the Soviet star
        self.soviet_star = self.canvas.create_text(
            self.x, self.y,
            text="â", fill="red", font=("Helvetica", 16, "bold")
        )
        print("[DEBUG] Soviet star created.")

    def _clear_previous_drawings(self):
        """
        Safely clears the previous drawings of the bomber components before redrawing.
        """
        print("[DEBUG] Entering _clear_previous_drawings() method.")
        components = [self.body, self.wings, self.soviet_star] + self.engines + self.turrets
        for component in components:
            if component:  # Check if component exists before attempting to delete
                self.canvas.delete(component)

        # Reset attributes to ensure they are not reused accidentally
        self.body = None
        self.wings = None
        self.engines = []
        self.turrets = []
        self.soviet_star = None
        print("[DEBUG] All previous components cleared.")
media_rw
import tkinter as tk

class GameApp:
    def __init__(self):
        """
        Wraps the entire game within a single object.
        Initializes the Tkinter root and game session.
        """
        self.root = tk.Tk()
        self.root.title("Turn-Based Tactical Simulation")
        self.tactical_map = None
        self.start_game()

    def start_game(self):
        """
        Starts a new game session by initializing TacticalMap and passing the replay callback.
        """
        from TacticalMap import TacticalMap  # Import here to avoid circular dependency
        if self.tactical_map:
            # Ensure TacticalMap is cleared before starting a new game
            self.tactical_map.reset()
        else:
            self.tactical_map = TacticalMap(self.root, on_replay=self.restart_game)

    def restart_game(self):
        """
        Resets the game session without destroying the entire root window.
        """
        if self.tactical_map:
            self.tactical_map.reset()
        else:
            self.start_game()

    def run(self):
        """
        Runs the Tkinter main loop.
        """
        self.root.mainloop()
media_rw
import tkinter as tk

class GameApp:
    def __init__(self):
        """
        Wraps the entire game within a single object.
        Initializes the Tkinter root and game session.
        """
        self.root = tk.Tk()
        self.root.title("Turn-Based Tactical Simulation")
        self.tactical_map = None
        self.start_game()

    def start_game(self):
        """
        Starts a new game session by initializing TacticalMap and passing the replay callback.
        """
        from TacticalMap import TacticalMap  # Import here to avoid circular dependency
        if self.tactical_map:
            # Ensure TacticalMap is cleared before starting a new game
            self.tactical_map.reset()
        else:
            self.tactical_map = TacticalMap(self.root, on_replay=self.restart_game)

    def restart_game(self):
        """
        Resets the game session without destroying the entire root window.
        """
        if self.tactical_map:
            self.tactical_map.reset()
        else:
            self.start_game()

    def run(self):
        """
        Runs the Tkinter main loop.
        """
        self.root.mainloop()
