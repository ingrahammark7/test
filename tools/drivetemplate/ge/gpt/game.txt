media_rw
#python cs.py split --input game.txt
#python cs.py rebuild --output game.txt

import re
import os
import ast
import textwrap

def split_game_txt(input_file="game.txt"):
    """Splits game.txt into individual Python files based on class names."""
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("media_rw")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """Rebuilds game.txt by concatenating all .py files in the current directory."""
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("media_rw\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def validate_snippet(snippet):
    """Validates the syntax of a code snippet using Python's AST module."""
    try:
        dedented_snippet = textwrap.dedent(snippet)  # Remove unnecessary indentation
        ast.parse(dedented_snippet)
        print("Snippet is syntactically valid.")
        return True
    except SyntaxError as e:
        print(f"Syntax error in snippet: {e}")
        print("Snippet content:")
        print(snippet)
        return False

def modify_file_from_temp(temp_file="temp.txt"):
    """Modifies a .py file based on instructions from temp.txt."""
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        # Validate the snippet syntax before applying
        if not validate_snippet(snippet):
            print("Modification aborted due to invalid syntax in snippet.")
            return

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        # Ensure the specified line range is valid
        with open(filename, "r") as file:
            file_contents = file.readlines()
        if start_line > len(file_contents) or end_line > len(file_contents) + 1:
            print(f"Invalid line range: {start_line}-{end_line}. File has {len(file_contents)} lines.")
            return

        # Create a backup of the file
        backup_filename = f"{filename}.bak"
        os.rename(filename, backup_filename)
        print(f"Backup created: {backup_filename}")

        # Apply modification
        modified_contents = (
            file_contents[:start_line - 1] + file_contents[end_line:]  # Remove specified lines
        )
        modified_contents.insert(start_line - 1, snippet)  # Insert new snippet

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """Dynamically generates temp.txt based on the parameters provided."""
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()
media_rw
#python cs.py split --input game.txt
#python cs.py rebuild --output game.txt

import re
import os
import ast
import textwrap

def split_game_txt(input_file="game.txt"):
    """Splits game.txt into individual Python files based on class names."""
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("

#python cs.py split --input game.txt
#python cs.py rebuild --output game.txt

import re
import os
import ast
import textwrap

def split_game_txt(input_file="game.txt"):
    """Splits game.txt into individual Python files based on class names."""
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("

#python cs.py split --input game.txt
#python cs.py rebuild --output game.txt

import re
import os
import ast
import textwrap

def split_game_txt(input_file="game.txt"):
    """Splits game.txt into individual Python files based on class names."""
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("

#python cs.py rebuild --output game.txt

import re
import os
import ast
import textwrap

def split_game_txt(input_file="game.txt"):
    """Splits game.txt into individual Python files based on class names."""
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("

import re
import os

def split_game_txt(input_file="game.txt"):
    """
    Splits game.txt into individual Python files based on class names.
    """
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("

#python cs.py split --input game.txt
#python cs.py rebuild --output game.txt

import re
import os
import ast
import textwrap

def split_game_txt(input_file="game.txt"):
    """Splits game.txt into individual Python files based on class names."""
    try:
        with open(input_file, "r") as file:
            content = file.read()

        # Split by separator
        sections = content.split("
media_rw
")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """Rebuilds game.txt by concatenating all .py files in the current directory."""
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("

\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def validate_snippet(snippet):
    """Validates the syntax of a code snippet using Python's AST module."""
    try:
        dedented_snippet = textwrap.dedent(snippet)  # Remove unnecessary indentation
        ast.parse(dedented_snippet)
        print("Snippet is syntactically valid.")
        return True
    except SyntaxError as e:
        print(f"Syntax error in snippet: {e}")
        print("Snippet content:")
        print(snippet)
        return False

def modify_file_from_temp(temp_file="temp.txt"):
    """Modifies a .py file based on instructions from temp.txt."""
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        # Validate the snippet syntax before applying
        if not validate_snippet(snippet):
            print("Modification aborted due to invalid syntax in snippet.")
            return

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        # Ensure the specified line range is valid
        with open(filename, "r") as file:
            file_contents = file.readlines()
        if start_line > len(file_contents) or end_line > len(file_contents) + 1:
            print(f"Invalid line range: {start_line}-{end_line}. File has {len(file_contents)} lines.")
            return

        # Create a backup of the file
        backup_filename = f"{filename}.bak"
        os.rename(filename, backup_filename)
        print(f"Backup created: {backup_filename}")

        # Apply modification
        modified_contents = (
            file_contents[:start_line - 1] + file_contents[end_line:]  # Remove specified lines
        )
        modified_contents.insert(start_line - 1, snippet)  # Insert new snippet

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """Dynamically generates temp.txt based on the parameters provided."""
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()

")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """Rebuilds game.txt by concatenating all .py files in the current directory."""
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("

\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def validate_snippet(snippet):
    """Validates the syntax of a code snippet using Python's AST module."""
    try:
        dedented_snippet = textwrap.dedent(snippet)  # Remove unnecessary indentation
        ast.parse(dedented_snippet)
        print("Snippet is syntactically valid.")
        return True
    except SyntaxError as e:
        print(f"Syntax error in snippet: {e}")
        print("Snippet content:")
        print(snippet)
        return False

def modify_file_from_temp(temp_file="temp.txt"):
    """Modifies a .py file based on instructions from temp.txt."""
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        # Validate the snippet syntax before applying
        if not validate_snippet(snippet):
            print("Modification aborted due to invalid syntax in snippet.")
            return

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        # Ensure the specified line range is valid
        with open(filename, "r") as file:
            file_contents = file.readlines()
        if start_line > len(file_contents) or end_line > len(file_contents) + 1:
            print(f"Invalid line range: {start_line}-{end_line}. File has {len(file_contents)} lines.")
            return

        # Create a backup of the file
        backup_filename = f"{filename}.bak"
        os.rename(filename, backup_filename)
        print(f"Backup created: {backup_filename}")

        # Apply modification
        modified_contents = (
            file_contents[:start_line - 1] + file_contents[end_line:]  # Remove specified lines
        )
        modified_contents.insert(start_line - 1, snippet)  # Insert new snippet

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """Dynamically generates temp.txt based on the parameters provided."""
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()

")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """Rebuilds game.txt by concatenating all .py files in the current directory."""
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("

\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def validate_snippet(snippet):
    """Validates the syntax of a code snippet using Python's AST module."""
    try:
        dedented_snippet = textwrap.dedent(snippet)  # Remove unnecessary indentation
        ast.parse(dedented_snippet)
        print("Snippet is syntactically valid.")
        return True
    except SyntaxError as e:
        print(f"Syntax error in snippet: {e}")
        print("Snippet content:")
        print(snippet)
        return False

def modify_file_from_temp(temp_file="temp.txt"):
    """Modifies a .py file based on instructions from temp.txt."""
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        # Validate the snippet syntax before applying
        if not validate_snippet(snippet):
            print("Modification aborted due to invalid syntax in snippet.")
            return

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        # Ensure the specified line range is valid
        with open(filename, "r") as file:
            file_contents = file.readlines()
        if start_line > len(file_contents) or end_line > len(file_contents) + 1:
            print(f"Invalid line range: {start_line}-{end_line}. File has {len(file_contents)} lines.")
            return

        # Create a backup of the file
        backup_filename = f"{filename}.bak"
        os.rename(filename, backup_filename)
        print(f"Backup created: {backup_filename}")

        # Apply modification
        modified_contents = (
            file_contents[:start_line - 1] + file_contents[end_line:]  # Remove specified lines
        )
        modified_contents.insert(start_line - 1, snippet)  # Insert new snippet

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """Dynamically generates temp.txt based on the parameters provided."""
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()

")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """Rebuilds game.txt by concatenating all .py files in the current directory."""
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("

\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def validate_snippet(snippet):
    """Validates the syntax of a code snippet using Python's AST module."""
    try:
        dedented_snippet = textwrap.dedent(snippet)  # Remove unnecessary indentation
        ast.parse(dedented_snippet)
        print("Snippet is syntactically valid.")
        return True
    except SyntaxError as e:
        print(f"Syntax error in snippet: {e}")
        print("Snippet content:")
        print(snippet)
        return False

def modify_file_from_temp(temp_file="temp.txt"):
    """Modifies a .py file based on instructions from temp.txt."""
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        # Validate the snippet syntax before applying
        if not validate_snippet(snippet):
            print("Modification aborted due to invalid syntax in snippet.")
            return

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        # Ensure the specified line range is valid
        with open(filename, "r") as file:
            file_contents = file.readlines()
        if start_line > len(file_contents) or end_line > len(file_contents) + 1:
            print(f"Invalid line range: {start_line}-{end_line}. File has {len(file_contents)} lines.")
            return

        # Create a backup of the file
        backup_filename = f"{filename}.bak"
        os.rename(filename, backup_filename)
        print(f"Backup created: {backup_filename}")

        # Apply modification
        modified_contents = (
            file_contents[:start_line - 1] + file_contents[end_line:]  # Remove specified lines
        )
        modified_contents.insert(start_line - 1, snippet)  # Insert new snippet

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """Dynamically generates temp.txt based on the parameters provided."""
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()

")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """Rebuilds game.txt by concatenating all .py files in the current directory."""
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("

\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def validate_snippet(snippet):
    """Validates the syntax of a code snippet using Python's AST module."""
    try:
        dedented_snippet = textwrap.dedent(snippet)  # Remove unnecessary indentation
        ast.parse(dedented_snippet)
        print("Snippet is syntactically valid.")
        return True
    except SyntaxError as e:
        print(f"Syntax error in snippet: {e}")
        print("Snippet content:")
        print(snippet)
        return False

def modify_file_from_temp(temp_file="temp.txt"):
    """Modifies a .py file based on instructions from temp.txt."""
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        # Validate the snippet syntax before applying
        if not validate_snippet(snippet):
            print("Modification aborted due to invalid syntax in snippet.")
            return

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        # Ensure the specified line range is valid
        with open(filename, "r") as file:
            file_contents = file.readlines()
        if start_line > len(file_contents) or end_line > len(file_contents) + 1:
            print(f"Invalid line range: {start_line}-{end_line}. File has {len(file_contents)} lines.")
            return

        # Create a backup of the file
        backup_filename = f"{filename}.bak"
        os.rename(filename, backup_filename)
        print(f"Backup created: {backup_filename}")

        # Apply modification
        modified_contents = (
            file_contents[:start_line - 1] + file_contents[end_line:]  # Remove specified lines
        )
        modified_contents.insert(start_line - 1, snippet)  # Insert new snippet

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """Dynamically generates temp.txt based on the parameters provided."""
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()

")
        class_content_map = {}

        for section in sections:
            section = section.strip()
            if not section:
                continue

            # Extract class name
            match = re.search(r"class\s+(\w+)", section)
            if match:
                class_name = match.group(1)
                if class_name not in class_content_map:
                    class_content_map[class_name] = section
                else:
                    class_content_map[class_name] += "\n\n" + section
            else:
                if class_content_map:
                    last_class = list(class_content_map.keys())[-1]
                    class_content_map[last_class] += "\n\n" + section

        # Write each class to its own .py file
        for class_name, content in class_content_map.items():
            with open(f"{class_name}.py", "w") as py_file:
                py_file.write(content)
            print(f"Created: {class_name}.py")

        print("Splitting completed.")
    except Exception as e:
        print(f"An error occurred during splitting: {e}")

def rebuild_game_txt(output_file="game.txt"):
    """
    Rebuilds game.txt by concatenating all .py files in the current directory.
    """
    try:
        py_files = [f for f in os.listdir() if f.endswith(".py")]
        with open(output_file, "w") as game_file:
            for py_file in py_files:
                with open(py_file, "r") as file:
                    content = file.read()
                    game_file.write("

\n")
                    game_file.write(content.strip() + "\n")
        print(f"{output_file} successfully rebuilt from .py files.")
    except Exception as e:
        print(f"An error occurred during rebuilding: {e}")

def modify_file_from_temp(temp_file="temp.txt"):
    """
    Modifies a .py file based on instructions from temp.txt.
    """
    try:
        with open(temp_file, "r") as file:
            lines = file.readlines()

        filename = lines[0].strip()
        start_line = int(lines[1].strip())
        end_line = int(lines[2].strip())
        snippet = "".join(lines[3:])

        if not os.path.exists(filename):
            print(f"File {filename} not found.")
            return

        with open(filename, "r") as file:
            file_contents = file.readlines()

        # Replace lines
        modified_contents = file_contents[:start_line - 1] + file_contents[end_line:]
        modified_contents.insert(start_line - 1, snippet)

        with open(filename, "w") as file:
            file.writelines(modified_contents)
        print(f"{filename} successfully modified.")
    except Exception as e:
        print(f"An error occurred during modification: {e}")

def generate_temp_snippet(filename, start_line, end_line, new_code):
    """
    Dynamically generates temp.txt based on the parameters provided.
    """
    try:
        temp_content = f"{filename}\n{start_line}\n{end_line}\n{new_code}"
        with open("temp.txt", "w") as temp_file:
            temp_file.write(temp_content)
        print("Generated temp.txt with the following content:")
        print(temp_content)
    except Exception as e:
        print(f"An error occurred during temp.txt generation: {e}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Manage game.txt and Python files.")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Split command
    split_parser = subparsers.add_parser("split", help="Split game.txt into individual .py files.")
    split_parser.add_argument("--input", type=str, default="game.txt", help="Path to game.txt")

    # Rebuild command
    rebuild_parser = subparsers.add_parser("rebuild", help="Rebuild game.txt from .py files.")
    rebuild_parser.add_argument("--output", type=str, default="game.txt", help="Path to output game.txt")

    # Modify command
    modify_parser = subparsers.add_parser("modify", help="Modify a .py file based on temp.txt.")
    modify_parser.add_argument("--temp", type=str, default="temp.txt", help="Path to temp.txt")

    # Generate temp.txt command
    generate_parser = subparsers.add_parser("generate", help="Generate a temp.txt snippet.")
    generate_parser.add_argument("--filename", type=str, required=True, help="Target filename to modify")
    generate_parser.add_argument("--start", type=int, required=True, help="Start line number")
    generate_parser.add_argument("--end", type=int, required=True, help="End line number")
    generate_parser.add_argument("--code", type=str, required=True, help="Code to insert at start line")

    args = parser.parse_args()

    if args.command == "split":
        split_game_txt(input_file=args.input)
    elif args.command == "rebuild":
        rebuild_game_txt(output_file=args.output)
    elif args.command == "modify":
        modify_file_from_temp(temp_file=args.temp)
    elif args.command == "generate":
        generate_temp_snippet(args.filename, args.start, args.end, args.code)

    # Automatically rebuild game.txt after every run
    rebuild_game_txt()
media_rw
import tkinter as tk
from GameUI import GameUI
from TerrainManager import TerrainManager
from PlayerManager import PlayerManager
from EnemyManager import EnemyManager
from CombatManager import CombatManager


class TacticalMap:
    def __init__(self, root, on_replay=None):
        """
        Initializes the TacticalMap, setting up game managers and the UI.

        Args:
            root (tk.Tk): The root window for the game.
            on_replay (callable): A callback function to restart the game.
        """
        self.root = root
        self.ui = GameUI(root)
        self.terrain_manager = TerrainManager(self.ui.grid_elements)
        self.player_manager = PlayerManager(self.ui.grid_elements, self.terrain_manager, self.ui)
        self.enemy_manager = EnemyManager(self.ui.grid_elements, self.terrain_manager, enemy_count=5, ui=self.ui)
        self.combat_manager = CombatManager(
            self.ui.grid_elements,
            player_stats={"name": "T-64 Tank", "hp": 20, "ammo": 5},
            enemy_stats={"name": "Enemy Unit", "hp": 10},
            ui = self.ui
        )
        self.on_replay = on_replay
        self.turn = "Player"
        self.grid_rows = 7
        self.grid_cols = 7
        self.determine_grid_dimensions()
        self.initialize_game()

    def determine_grid_dimensions(self):
        """
        Dynamically sets grid dimensions based on screen size.
        """
        screen_width = self.ui.root.winfo_screenwidth()
        screen_height = self.ui.root.winfo_screenheight()
        if screen_height >= 2 * screen_width:
            self.grid_rows, self.grid_cols = 14, 7
        else:
            self.grid_rows, self.grid_cols = 7, 7

    def initialize_game(self):
        """
        Sets up the game grid, generates terrain, and deploys units.
        Retries if necessary.
        """
        self.ui.create_map(rows=self.grid_rows, cols=self.grid_cols)
        self.ui.create_log_area()

        for _ in range(5):  # Attempt up to 5 times
            if self.terrain_manager.generate_terrain(enemy_count=5):
                try:
                    player_pos = self.player_manager.deploy_player()
                    enemy_positions = self.enemy_manager.deploy_enemies()
                    # Log initialization message
                    log_message = f"Game initialized. Player spawned at: {player_pos}"
                    self.ui.update_log(log_message)
                    print(log_message)  # Debugging log
                    return
                except ValueError:
                    self.ui.update_log("Deployment failed. Retrying...")
        self.ui.update_log("Failed to initialize game.")
        self.end_game(victory=False)

    def on_cell_click(self, coord):
        """
        Handles a player's action when a cell is clicked.

        Args:
            coord (str): The coordinate of the clicked cell.
        """
        if self.turn == "Player":
            self.handle_player_action(coord)

    def handle_player_action(self, coord):
        """
        Processes the player's action: move, attack, or use artillery.

        Args:
            coord (str): The target cell coordinate.
        """
        player_position = self.player_manager.player_position
        distance_row = abs(ord(coord[0]) - ord(player_position[0]))
        distance_col = abs(int(coord[1:]) - int(player_position[1:]))

        # Artillery attack for distant targets
        if max(distance_row, distance_col) > 1:
            if self.player_manager.player_stats["ammo"] > 0:
                results = self.combat_manager.artillery_attack(coord, self.enemy_manager.enemy_positions)
                self.player_manager.player_stats["ammo"] -= 1
                for result in results:
                    self.ui.update_log(result)
                self.ui.update_log(f"Artillery fired. Ammo left: {self.player_manager.player_stats['ammo']}")
                self.end_turn()
            else:
                self.ui.update_log("No ammo left!")
            return

        # Regular move or attack for adjacent cells
        if max(distance_row, distance_col) == 1:
            terrain = self.terrain_manager.get_terrain(coord)
            if coord in self.enemy_manager.enemy_positions:
                result = self.combat_manager.player_attack(coord, self.enemy_manager.enemy_positions)
                self.ui.update_log(result)
                if not self.enemy_manager.enemy_positions:
                    self.end_game(victory=True)
            elif terrain in ["Empty", "Forest"]:
                self.player_manager.move_player(coord)
                self.end_turn()
            else:
                self.ui.update_log("Cannot move to that terrain!")
        else:
            self.ui.update_log("Invalid move. Choose an adjacent tile.")

    def enemy_action(self):
        """
        Executes the enemies' turn, including movement and attacks.
        """
        self.ui.update_log("Enemies are taking their turn...")
        for enemy_pos in list(self.enemy_manager.enemy_positions.keys()):
            if enemy_pos not in self.enemy_manager.enemy_positions:
                print(f"Skipping invalid enemy position: {enemy_pos}")  # Debugging log
                continue

            if self.enemy_manager.is_adjacent(enemy_pos, self.player_manager.player_position):
                result = self.combat_manager.enemy_attack(self.player_manager.player_position)
                self.ui.update_log(result)
                if self.player_manager.player_stats["hp"] <= 0:
                    self.end_game(victory=False)
                    return
            else:
                new_pos = self.enemy_manager.move_toward_player(enemy_pos, self.player_manager.player_position)
                if new_pos != enemy_pos:
                    self.enemy_manager.update_enemy_position(enemy_pos, new_pos)
        if not self.enemy_manager.enemy_positions:
            self.end_game(victory=True)
        else:
            self.end_turn()

    def end_turn(self):
        """
        Alternates turns between the player and the enemies.
        """
        if self.turn == "Player":
            self.turn = "Enemy"
            self.enemy_action()
        else:
            self.turn = "Player"
            self.ui.update_log("Your turn!")

    def end_game(self, victory):
        """
        Concludes the game with a victory or defeat message.

        Args:
            victory (bool): True if the player wins, False otherwise.
        """
        message = "You Win!" if victory else "Game Over!"
        self.ui.update_log(message)
        self.ui.show_end_screen(message)

    def reset(self):
        """
        Resets the TacticalMap to its initial state for a new game.
        """
        self.ui.reset()
        self.terrain_manager.reset()
        self.player_manager.reset()
        self.enemy_manager.reset()
        self.combat_manager = CombatManager(
            self.ui.grid_elements,
            player_stats={"name": "T-64 Tank", "hp": 20, "ammo": 5},
            enemy_stats={"name": "Enemy Unit", "hp": 10}
        )
        self.turn = "Player"
        self.initialize_game()


if __name__ == "__main__":
    """
    Entry point for running the TacticalMap as a standalone game.
    Creates the root window and starts the game.
    """
    root = tk.Tk()
    root.title("Turn-Based Tactical Simulation")
    game = TacticalMap(root)
    root.mainloop()
media_rw
class CombatManager:
    def __init__(self, grid_elements, player_stats, enemy_stats, ui):
        """
        Initializes the CombatManager with references to the grid elements,
        the player's statistics, the enemy's statistics, and GameUI.

        Args:
            grid_elements (dict): Dictionary of canvas rectangles for the grid.
            player_stats (dict): Dictionary containing player stats (e.g., {"hp": 20, "ammo": 5}).
            enemy_stats (dict): Dictionary containing enemy stats (e.g., {"hp": 10}).
            ui (GameUI): Instance of GameUI for rendering on the canvas.
        """
        self.grid_elements = grid_elements
        self.player_stats = player_stats
        self.enemy_stats = enemy_stats
        self.ui = ui  # Reference to the GameUI

    def player_attack(self, target_coord, enemy_positions):
        """
        Handles the player's attack on an enemy unit.

        Args:
            target_coord (str): The coordinate of the enemy being attacked.
            enemy_positions (dict): A dictionary mapping enemy positions to their HP.

        Returns:
            str: A message describing the outcome of the attack.
        """
        if target_coord in enemy_positions:
            # Damage the enemy by 5 points
            enemy_positions[target_coord] -= 5
            if enemy_positions[target_coord] <= 0:
                # Enemy is defeated; remove it and update the UI
                del enemy_positions[target_coord]
                self.ui.update_cell(target_coord, "Empty", "lightgray")
                return f"Enemy at {target_coord} is defeated!"
            else:
                return f"Enemy at {target_coord} HP reduced to {enemy_positions[target_coord]}."
        return "No enemy to attack at the selected position."

    def artillery_attack(self, target_coord, enemy_positions):
        """
        Handles artillery attack, which damages the target coordinate and adjacent tiles.

        Args:
            target_coord (str): The main target coordinate for the artillery attack.
            enemy_positions (dict): A dictionary mapping enemy positions to their HP.

        Returns:
            list: A list of messages describing the outcomes at each affected coordinate.
        """
        results = []
        row = ord(target_coord[0])
        col = int(target_coord[1:])

        # Generate a list of affected coordinates (target + adjacent)
        affected_coords = [
            target_coord,
            f"{chr(row - 1)}{col}",
            f"{chr(row + 1)}{col}",
            f"{chr(row)}{col - 1}",
            f"{chr(row)}{col + 1}"
        ]

        for coord in affected_coords:
            if coord in enemy_positions:
                # Damage enemy units
                enemy_positions[coord] -= 10  # Artillery deals 10 damage
                if enemy_positions[coord] <= 0:
                    del enemy_positions[coord]
                    self.ui.update_cell(coord, "Empty", "lightgray")
                    results.append(f"Enemy at {coord} destroyed by artillery.")
                else:
                    results.append(f"Enemy at {coord} hit by artillery. HP now {enemy_positions[coord]}.")
            elif coord in self.grid_elements:
                # Empty tiles hit by artillery
                results.append(f"Artillery hit {coord}, but no enemies present.")

        return results

    def enemy_attack(self, player_position):
        """
        Handles the enemy's attack on the player.

        Args:
            player_position (str): The current position of the player.

        Returns:
            str: A message describing the result of the enemy's attack.
        """
        # Enemy deals a fixed 5 damage to the player
        self.player_stats["hp"] -= 5
        if self.player_stats["hp"] <= 0:
            return "Player is defeated!"
        else:
            return f"Player HP reduced to {self.player_stats['hp']}."

    def is_adjacent(self, pos1, pos2):
        """
        Determines if two grid positions are adjacent (including diagonally).

        Args:
            pos1 (str): The first grid position (e.g., "A1").
            pos2 (str): The second grid position (e.g., "B2").

        Returns:
            bool: True if the two positions share a side or corner, False otherwise.
        """
        row_diff = abs(ord(pos1[0]) - ord(pos2[0]))
        col_diff = abs(int(pos1[1:]) - int(pos2[1:]))
        return max(row_diff, col_diff) == 1

    def reset(self, player_stats=None, enemy_stats=None):
        """
        Resets the CombatManager to its initial state for a new game.

        Args:
            player_stats (dict, optional): Updated stats for the player.
            enemy_stats (dict, optional): Updated stats for the enemies.
        """
        # Reset player and enemy stats if provided, or default to starting stats
        self.player_stats = player_stats if player_stats else {"hp": 20, "ammo": 5}
        self.enemy_stats = enemy_stats if enemy_stats else {"hp": "10"}
media_rw
import random

class EnemyManager:
    def __init__(self, grid_elements, terrain_manager, enemy_count, ui):
        """
        Initializes the EnemyManager with references to the grid elements, terrain manager,
        the number of enemy units, and the GameUI instance.

        Args:
            grid_elements (dict): Dictionary of canvas rectangles for the grid.
            terrain_manager (TerrainManager): Instance of TerrainManager for managing terrains.
            enemy_count (int): Number of enemy units to deploy.
            ui (GameUI): Instance of GameUI for rendering on the canvas.
        """
        self.grid_elements = grid_elements  # Reference to canvas elements for the grid
        self.terrain_manager = terrain_manager  # Reference to terrain manager
        self.enemy_positions = {}  # Dictionary to track enemy positions and their HP
        self.enemy_count = enemy_count  # Number of enemy units
        self.ui = ui  # Reference to the GameUI

    def deploy_enemies(self):
        """
        Deploys enemy units on random empty tiles and renders them on the canvas.

        Returns:
            list: A list of coordinates where the enemies are deployed.

        Raises:
            ValueError: If there are not enough empty spaces for deployment.
        """
        empty_cells = [
            coord for coord, terr in self.terrain_manager.terrain.items()
            if terr == "Empty" and coord not in self.enemy_positions
        ]
        if len(empty_cells) < self.enemy_count:
            raise ValueError("Not enough empty spaces to deploy enemies.")

        for coord in random.sample(empty_cells, self.enemy_count):
            self.enemy_positions[coord] = 10  # Assign 10 HP to each enemy
            self.ui.update_cell(coord, "Enemy", "red")  # Render the enemy in red
        return list(self.enemy_positions.keys())

    def move_toward_player(self, enemy_position, player_position):
        """
        Moves an enemy unit toward the player. Handles terrain crossing probabilities.

        Args:
            enemy_position (str): The current position of the enemy unit.
            player_position (str): The current position of the player unit.

        Returns:
            str: The new position of the enemy unit.
        """
        enemy_row, enemy_col = ord(enemy_position[0]), int(enemy_position[1:])
        player_row, player_col = ord(player_position[0]), int(player_position[1:])

        dr = player_row - enemy_row
        dc = player_col - enemy_col

        # Determine direction of movement
        if abs(dr) > abs(dc):
            new_pos = f"{chr(enemy_row + (1 if dr > 0 else -1))}{enemy_col}"
        else:
            new_pos = f"{chr(enemy_row)}{enemy_col + (1 if dc > 0 else -1)}"

        # Validate and attempt the move
        if new_pos in self.grid_elements and enemy_position in self.enemy_positions:
            terrain = self.terrain_manager.get_terrain(new_pos)
            if terrain == "Water":
                if random.random() < 0.5:  # 50% chance to cross
                    self.update_enemy_position(enemy_position, new_pos)
                    return new_pos
                else:
                    return enemy_position
            elif terrain == "Mountain":
                if random.random() < 0.3:  # 30% chance to cross
                    self.update_enemy_position(enemy_position, new_pos)
                    return new_pos
                else:
                    return enemy_position
            elif terrain in ["Empty", "Forest"]:
                self.update_enemy_position(enemy_position, new_pos)
                return new_pos

        # Stay in place if move is invalid
        return enemy_position

    def update_enemy_position(self, old_position, new_position):
        """
        Updates the enemy's position on the canvas.

        Args:
            old_position (str): The previous position of the enemy.
            new_position (str): The new position of the enemy.
        """
        # Clear the old position and update the new one
        self.ui.update_cell(old_position, "Empty", "lightgray")
        self.ui.update_cell(new_position, "Enemy", "red")
        self.enemy_positions[new_position] = self.enemy_positions.pop(old_position)

    def is_adjacent(self, pos1, pos2):
        """
        Checks if two positions are adjacent on the grid.

        Args:
            pos1 (str): The first position (e.g., "A1").
            pos2 (str): The second position (e.g., "B2").

        Returns:
            bool: True if the positions are adjacent, False otherwise.
        """
        row_diff = abs(ord(pos1[0]) - ord(pos2[0]))
        col_diff = abs(int(pos1[1:]) - int(pos2[1:]))
        return max(row_diff, col_diff) == 1

    def reset(self):
        """
        Resets the EnemyManager to its initial state for a new game.
        """
        # Clear enemy positions and reset the canvas
        for coord in list(self.enemy_positions.keys()):
            self.ui.update_cell(coord, "Empty", "lightgray")
        self.enemy_positions.clear()
media_rw
import tkinter as tk
from tkinter import ttk


class GameUI:
    def __init__(self, root):
        """
        Initializes the GameUI with a scrollable map (canvas-based), log area, and tank rendering.
        """
        self.root = root

        # Main container for layout organization
        self.main_frame = tk.Frame(self.root)
        self.main_frame.pack(fill="both", expand=True)

        # Create a canvas for the map with vertical and horizontal scrollbars
        self.canvas = tk.Canvas(self.main_frame, bg="white", width=800, height=600)
        self.scrollbar_y = ttk.Scrollbar(self.main_frame, orient="vertical", command=self.canvas.yview)
        self.scrollbar_x = ttk.Scrollbar(self.main_frame, orient="horizontal", command=self.canvas.xview)

        # Configure the canvas for scrolling
        self.canvas.configure(yscrollcommand=self.scrollbar_y.set, xscrollcommand=self.scrollbar_x.set)
        self.scrollbar_y.pack(side="right", fill="y")
        self.scrollbar_x.pack(side="bottom", fill="x")
        self.canvas.pack(side="left", fill="both", expand=True)

        # Internal data structures for managing canvas elements
        self.grid_elements = {}  # Holds grid rectangle IDs and their coordinates
        self.cell_states = {}    # Store each cell's current state (terrain, units, etc.)
        self.tank_graphics = {}  # Track the tank's graphical components

        # Log area for messages
        self.log_area = None

    def create_map(self, rows, cols):
        """
        Creates a dynamically sized map grid using canvas rectangles.

        Args:
            rows (int): Number of rows in the grid.
            cols (int): Number of columns in the grid.
        """
        self.grid_elements.clear()
        self.cell_states.clear()

        # Dimensions of each cell
        cell_width = 50
        cell_height = 50

        # Draw the grid on the canvas
        for row in range(rows):
            for col in range(cols):
                coord = f"{chr(65 + row)}{col + 1}"  # Example: A1, B1, etc.
                x1, y1 = col * cell_width, row * cell_height
                x2, y2 = x1 + cell_width, y1 + cell_height

                # Draw a rectangle for each cell
                rect_id = self.canvas.create_rectangle(x1, y1, x2, y2, fill="lightgray", outline="black")
                self.grid_elements[coord] = rect_id
                self.cell_states[coord] = "Empty"  # Initialize as empty

                # Bind left-click events to the rectangle
                self.canvas.tag_bind(rect_id, "<Button-1>", lambda event, c=coord: self.on_cell_click(c))

    def create_log_area(self):
        """
        Creates a text area to display the game log.
        """
        self.log_area = tk.Text(self.root, height=5, state="normal", wrap="word", bg="lightyellow")
        self.log_area.pack(side="bottom", fill="x")

    def update_log(self, message):
        """
        Updates the game log with a new message.

        Args:
            message (str): The message to display.
        """
        if self.log_area:
            self.log_area.configure(state="normal")
            self.log_area.insert(tk.END, message + "\n")
            self.log_area.see(tk.END)
            self.log_area.configure(state="disabled")

    def draw_tank(self, coord):
        """
        Draws a tank on the canvas at the specified coordinate.

        Args:
            coord (str): The grid cell (e.g., "A1") to place the tank.
        """
        if coord not in self.grid_elements:
            print(f"[LOG] {coord} is not a valid coordinate.")
            return

        # Clear any existing tank graphics
        self.clear_tank()

        # Get rectangle coordinates
        rect_id = self.grid_elements[coord]
        x1, y1, x2, y2 = self.canvas.coords(rect_id)

        # Calculate the center of the rectangle
        center_x, center_y = (x1 + x2) / 2, (y1 + y2) / 2

        # Tank dimensions
        hull_width, hull_height = 30, 20
        turret_radius = 8

        # Draw the tank's hull (rectangle)
        self.tank_graphics["hull"] = self.canvas.create_rectangle(
            center_x - hull_width / 2, center_y - hull_height / 2,
            center_x + hull_width / 2, center_y + hull_height / 2,
            fill="green"
        )

        # Draw the tank's turret (circle)
        self.tank_graphics["turret"] = self.canvas.create_oval(
            center_x - turret_radius, center_y - turret_radius,
            center_x + turret_radius, center_y + turret_radius,
            fill="darkgreen"
        )

        # Draw the tank's gun (line)
        gun_length = 20
        self.tank_graphics["gun"] = self.canvas.create_line(
            center_x, center_y,
            center_x + gun_length, center_y,
            fill="black", width=3
        )

        # Log the tank's position for debugging
        print(f"[LOG] Tank drawn at {coord} ({center_x}, {center_y}).")

    def clear_tank(self):
        """
        Clears the tank graphic from the canvas.
        """
        for part in self.tank_graphics.values():
            self.canvas.delete(part)
        self.tank_graphics.clear()

    def update_cell(self, coord, terrain_type, color):
        """
        Updates a specific cell with a given terrain type and color.

        Args:
            coord (str): The coordinate of the cell (e.g., "A1").
            terrain_type (str): The type of terrain (e.g., "Forest").
            color (str): The fill color for the terrain.
        """
        if coord in self.grid_elements:
            rect_id = self.grid_elements[coord]
            self.canvas.itemconfig(rect_id, fill=color)
            self.cell_states[coord] = terrain_type

    def on_cell_click(self, coord):
        """
        Placeholder for cell click actions. Can be overridden by TacticalMap.

        Args:
            coord (str): The clicked cell's coordinate (e.g., "A1").
        """
        print(f"[LOG] Cell {coord} clicked.")

    def reset(self):
        """
        Resets the GameUI components for a new game session.
        """
        self.canvas.delete("all")
        self.grid_elements.clear()
        self.cell_states.clear()
        self.tank_graphics.clear()
        if self.log_area:
            self.log_area.configure(state="normal")
            self.log_area.delete(1.0, tk.END)
            self.log_area.configure(state="disabled")
media_rw
import random

class PlayerManager:
    def __init__(self, grid_elements, terrain_manager, ui):
        """
        Initializes the PlayerManager with references to the grid elements, terrain manager, and GameUI.

        Args:
            grid_elements (dict): The dictionary containing the canvas rectangles for the grid.
            terrain_manager (TerrainManager): Instance of TerrainManager for managing terrains.
            ui (GameUI): Instance of GameUI for drawing and managing the UI.
        """
        self.grid_elements = grid_elements
        self.terrain_manager = terrain_manager
        self.ui = ui  # Reference to the GameUI
        self.player_position = None
        self.player_stats = {"hp": 20, "ammo": 1}  # Default player stats

    def deploy_player(self):
        """
        Deploys the player unit on a random empty tile and displays the tank graphic.

        Returns:
            str: The coordinate of the deployed player unit.

        Raises:
            ValueError: If deployment fails after multiple attempts.
        """
        for _ in range(10):  # Retry up to 10 times for deployment
            self.player_position = random.choice(list(self.grid_elements.keys()))
            if self.terrain_manager.get_terrain(self.player_position) == "Empty":
                # Draw the player's tank on the selected coordinate
                self.ui.draw_tank(self.player_position)
                print(f"[LOG] Player deployed at: {self.player_position}")  # Debug log
                return self.player_position

        raise ValueError("Failed to deploy player unit after multiple attempts.")

    def move_player(self, target_position):
        """
        Moves the player unit to a specified target position and updates the tank graphic.

        Args:
            target_position (str): The coordinate to move the player unit to.

        Returns:
            str: The new position of the player unit.
        """
        if target_position not in self.grid_elements:
            print(f"[LOG] Invalid target position: {target_position}")
            return self.player_position

        # Log the move action
        print(f"[LOG] Moving player from {self.player_position} to {target_position}")

        # Update the tank graphic
        self.ui.draw_tank(target_position)
        self.player_position = target_position

        # Log the updated position
        print(f"[LOG] Player successfully moved to {self.player_position}")
        return self.player_position

    def heal_player(self, amount):
        """
        Heals the player by a specified amount.

        Args:
            amount (int): The amount of health to restore.
        """
        self.player_stats["hp"] += amount
        if self.player_stats["hp"] > 20:  # Cap at max health
            self.player_stats["hp"] = 20

    def use_ammo(self):
        """
        Reduces the player's ammo by 1 when artillery is fired.

        Returns:
            bool: True if ammo was used successfully, False if no ammo is left.
        """
        if self.player_stats["ammo"] > 0:
            self.player_stats["ammo"] -= 1
            return True
        return False

    def reset(self):
        """
        Resets the PlayerManager to its initial state for a new game.
        """
        self.player_position = None
        self.player_stats = {"hp": 20, "ammo": 1}  # Reset health and ammo
media_rw
import random

class UnitManager:
    def __init__(self, map_buttons, terrain_manager, enemy_count):
        """
        Initializes the UnitManager with references to map buttons, terrain, and enemy count.
        """
        self.map_buttons = map_buttons  # Reference to the map buttons
        self.terrain_manager = terrain_manager  # Reference to the terrain manager
        self.player_position = "A1"  # Initial player position
        self.enemy_positions = []  # List of enemy positions
        self.enemy_count = enemy_count  # Total number of enemies to deploy

    def deploy_player(self, player_unit_name):
        """
        Deploys the player unit on a random empty tile.
        """
        for _ in range(5):  # Retry up to 5 times for deployment
            self.player_position = random.choice(list(self.map_buttons.keys()))
            if self.terrain_manager.get_terrain(self.player_position) == "Empty":
                self.map_buttons[self.player_position].config(text=player_unit_name, bg="blue")
                return self.player_position
        # Raise an exception if deployment fails
        raise ValueError("Failed to deploy player unit. Restart required.")

    def deploy_enemies(self, enemy_unit_name):
        """
        Deploys enemy units on random empty tiles.
        """
        empty_cells = [
            coord for coord, terr in self.terrain_manager.terrain.items()
            if terr == "Empty" and self.map_buttons[coord].cget("text") == "Empty"
        ]
        if len(empty_cells) < self.enemy_count:
            raise ValueError("Not enough empty spaces to deploy enemies.")

        self.enemy_positions = random.sample(empty_cells, self.enemy_count)
        for enemy_position in self.enemy_positions:
            self.map_buttons[enemy_position].config(text=enemy_unit_name, bg="red")
        return self.enemy_positions

    def move_unit(self, current_position, target_position, unit_name):
        """
        Moves a unit from the current position to the target position.
        """
        self.map_buttons[current_position].config(text="Empty", bg="lightgray")
        self.map_buttons[target_position].config(text=unit_name, bg="blue")
        return target_position

    def move_enemy(self, enemy_position, target_position, enemy_name):
        """
        Moves an enemy unit from the current position to the target position.
        """
        self.map_buttons[enemy_position].config(text="Empty", bg="lightgray")
        self.map_buttons[target_position].config(text=enemy_name, bg="red")
        return target_position

    def is_adjacent(self, pos1, pos2):
        """
        Determines whether two positions on the map are adjacent.
        """
        row_diff = abs(ord(pos1[0]) - ord(pos2[0]))
        col_diff = abs(int(pos1[1]) - int(pos2[1]))
        return max(row_diff, col_diff) == 1
media_rw
import random

class TerrainManager:
    def __init__(self, grid_elements):
        """
        Initializes the TerrainManager with a reference to the grid elements.

        Args:
            grid_elements (dict): Dictionary of canvas rectangles for the grid.
        """
        self.grid_elements = grid_elements  # Reference to the grid elements
        self.terrain = {}  # Dictionary to store terrain types for each cell

    def generate_terrain(self, enemy_count, extra_empty=5):
        """
        Generates terrain for the map and ensures a minimum number of empty tiles.

        Args:
            enemy_count (int): Number of enemies to deploy (affects empty tiles needed).
            extra_empty (int): Extra empty tiles to ensure playability.

        Returns:
            bool: True if terrain generation is successful, False otherwise.
        """
        retries = 5  # Maximum number of attempts to generate a valid map
        for _ in range(retries):
            self.terrain.clear()
            empty_count = 0

            # Randomly assign terrain types to each cell
            for coord in self.grid_elements.keys():
                terrain_type = random.choice(["Forest", "Mountain", "Water", "Empty"])
                self.terrain[coord] = terrain_type
                if terrain_type == "Empty":
                    empty_count += 1

            # Check if enough empty tiles are available
            if empty_count >= enemy_count + extra_empty:
                self._apply_terrain_to_canvas()
                return True  # Successful generation

        return False  # Failed to generate a valid map after retries

    def _apply_terrain_to_canvas(self):
        """
        Applies the generated terrain to the canvas, updating its appearance.
        """
        for coord, terrain_type in self.terrain.items():
            rect_id = self.grid_elements.get(coord)
            if rect_id:  # Ensure the coordinate exists in the grid
                if terrain_type == "Forest":
                    self._update_canvas_cell(rect_id, "Forest", "green")
                elif terrain_type == "Mountain":
                    self._update_canvas_cell(rect_id, "Mountain", "brown")
                elif terrain_type == "Water":
                    self._update_canvas_cell(rect_id, "Water", "blue")
                elif terrain_type == "Empty":
                    self._update_canvas_cell(rect_id, "Empty", "lightgray")

    def _update_canvas_cell(self, rect_id, terrain_type, color):
        """
        Updates the appearance of a canvas cell based on the terrain type.

        Args:
            rect_id (int): The ID of the rectangle on the canvas.
            terrain_type (str): The type of terrain to display.
            color (str): The fill color for the rectangle.
        """
        # Update the rectangle's fill color and optionally add a label
        self.grid_elements[rect_id] = terrain_type
        self.grid_elements[rect_id] = {
            "fill": color,
        }

    def get_terrain(self, coord):
        """
        Gets the terrain type for a specific coordinate.

        Args:
            coord (str): The map coordinate (e.g., "A1").

        Returns:
            str: The terrain type (e.g., "Forest", "Mountain", "Water", or "Empty").
        """
        return self.terrain.get(coord, "Unknown")

    def reset(self):
        """
        Resets the TerrainManager to its initial state for a new game.
        """
        # Clear current terrain and reset the canvas cells to default "Empty" state
        self.terrain.clear()
        for coord, rect_id in self.grid_elements.items():
            self._update_canvas_cell(rect_id, "Empty", "lightgray")
media_rw
import tkinter as tk

class GameApp:
    def __init__(self):
        """
        Wraps the entire game within a single object.
        Initializes the Tkinter root and game session.
        """
        self.root = tk.Tk()
        self.root.title("Turn-Based Tactical Simulation")
        self.tactical_map = None
        self.start_game()

    def start_game(self):
        """
        Starts a new game session by initializing TacticalMap and passing the replay callback.
        """
        from TacticalMap import TacticalMap  # Import here to avoid circular dependency
        if self.tactical_map:
            # Ensure TacticalMap is cleared before starting a new game
            self.tactical_map.reset()
        else:
            self.tactical_map = TacticalMap(self.root, on_replay=self.restart_game)

    def restart_game(self):
        """
        Resets the game session without destroying the entire root window.
        """
        if self.tactical_map:
            self.tactical_map.reset()
        else:
            self.start_game()

    def run(self):
        """
        Runs the Tkinter main loop.
        """
        self.root.mainloop()
media_rw
import tkinter as tk

class GameApp:
    def __init__(self):
        """
        Wraps the entire game within a single object.
        Initializes the Tkinter root and game session.
        """
        self.root = tk.Tk()
        self.root.title("Turn-Based Tactical Simulation")
        self.tactical_map = None
        self.start_game()

    def start_game(self):
        """
        Starts a new game session by initializing TacticalMap and passing the replay callback.
        """
        from TacticalMap import TacticalMap  # Import here to avoid circular dependency
        if self.tactical_map:
            # Ensure TacticalMap is cleared before starting a new game
            self.tactical_map.reset()
        else:
            self.tactical_map = TacticalMap(self.root, on_replay=self.restart_game)

    def restart_game(self):
        """
        Resets the game session without destroying the entire root window.
        """
        if self.tactical_map:
            self.tactical_map.reset()
        else:
            self.start_game()

    def run(self):
        """
        Runs the Tkinter main loop.
        """
        self.root.mainloop()
