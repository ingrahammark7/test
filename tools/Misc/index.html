<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Minimal Large Point Cloud Test</title>
<style>
  body, html { margin:0; padding:0; overflow:hidden; background:#000; }
  #info {
    position: fixed; top: 10px; left: 10px; color: #0f0; font-family: monospace; background: rgba(0,0,0,0.6);
    padding: 6px 10px; border-radius: 5px; z-index: 10;
  }
</style>
</head>
<body>

<div id="info">
  Points: <span id="pointCount">0</span><br />
  FPS: <span id="fps">0</span><br />
  Status: <span id="status">Starting...</span>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.154/build/three.min.js"></script>

<script>
  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
  camera.position.z = 100;

  const renderer = new THREE.WebGLRenderer({ antialias: false });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const infoPointCount = document.getElementById('pointCount');
  const infoFPS = document.getElementById('fps');
  const infoStatus = document.getElementById('status');

  let count = 10000;
  const maxCount = 50000000; // 50 million max

  let geometry, material, points;

  let lastTime = performance.now();
  let frames = 0;
  let fps = 0;

  let growing = true;
  let lastGrowthTime = performance.now();

  function createPoints(n) {
    // Generate random positions inside a cube -50 to +50
    const positions = new Float32Array(n * 3);
    for(let i = 0; i < n * 3; i++) {
      positions[i] = (Math.random() - 0.5) * 100;
    }

    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    // Use basic PointsMaterial for max compatibility
    const mat = new THREE.PointsMaterial({
      color: 0x88ccff,
      size: 1.0,
      sizeAttenuation: true,
      transparent: true,
      opacity: 0.8
    });

    return { geo, mat };
  }

  function initPoints(n) {
    if(points) {
      scene.remove(points);
      geometry.dispose();
      material.dispose();
    }
    try {
      const { geo, mat } = createPoints(n);
      geometry = geo;
      material = mat;
      points = new THREE.Points(geometry, material);
      scene.add(points);
      infoStatus.textContent = 'Rendering';
      return true;
    } catch(e) {
      infoStatus.textContent = 'Failed at ' + n.toLocaleString();
      console.warn('Failed to create points:', e);
      return false;
    }
  }

  let created = initPoints(count);
  if(!created) infoStatus.textContent = 'Initial creation failed';

  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);

    frames++;
    const now = performance.now();
    if(now - lastTime > 1000) {
      fps = Math.round((frames*1000)/(now - lastTime));
      frames = 0;
      lastTime = now;
      infoFPS.textContent = fps;
    }

    // Slowly orbit camera around center
    const t = clock.elapsedTime * 0.1;
    const radius = 120 + Math.log10(count) * 20;
    camera.position.x = Math.sin(t) * radius;
    camera.position.z = Math.cos(t) * radius;
    camera.position.y = 50 + Math.sin(t * 0.5) * 20;
    camera.lookAt(0, 0, 0);

    renderer.render(scene, camera);

    // Grow points count exponentially every 1.5s if FPS > 30 and growing
    if(growing && now - lastGrowthTime > 1500) {
      if(fps > 30) {
        const newCount = Math.floor(count * 1.7);
        if(newCount <= maxCount) {
          const success = initPoints(newCount);
          if(success) {
            count = newCount;
            infoPointCount.textContent = count.toLocaleString();
          } else {
            growing = false;
          }
        } else {
          infoStatus.textContent = 'Reached max count ' + maxCount.toLocaleString();
          growing = false;
        }
      } else {
        infoStatus.textContent = 'FPS dropped below 30, stopping growth';
        growing = false;
      }
      lastGrowthTime = now;
    }
  }

  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>

</body>
</html>