<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Fractal Brane Breakoff Demo</title>
<style>
  body { margin: 0; overflow: hidden; background: #111; }
  canvas { display: block; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
<script>

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(30, 30, 30);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lighting
const dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(10,20,10);
scene.add(dirLight);
scene.add(new THREE.AmbientLight(0x222222));

// Parameters
const GRID_SIZE = 8; // 8x8x8 grid of cubes
const CHUNK_SIZE = 1.5;
const MAX_DETACHED = 200;

// Main grid chunks (attached)
const chunks = [];
const chunkGroup = new THREE.Group();
scene.add(chunkGroup);

// Detached chunks (fracturing and fractal expanding)
const detachedChunks = [];

function createChunk(size, color=0x3399ff) {
  const geometry = new THREE.BoxGeometry(size, size, size);
  const material = new THREE.MeshStandardMaterial({
    color,
    transparent: true,
    opacity: 0.9,
    roughness: 0.4,
    metalness: 0.6
  });
  return new THREE.Mesh(geometry, material);
}

// Initialize the brane grid
for(let x=0; x<GRID_SIZE; x++) {
  for(let y=0; y<GRID_SIZE; y++) {
    for(let z=0; z<GRID_SIZE; z++) {
      const chunk = createChunk(CHUNK_SIZE);
      chunk.position.set(
        (x - GRID_SIZE/2) * CHUNK_SIZE * 1.1,
        (y - GRID_SIZE/2) * CHUNK_SIZE * 1.1,
        (z - GRID_SIZE/2) * CHUNK_SIZE * 1.1
      );
      chunk.userData = { attached: true, gridIndex: [x,y,z] };
      chunks.push(chunk);
      chunkGroup.add(chunk);
    }
  }
}

// Helper: remove chunk from main grid visually (hide it)
function detachChunk(chunk) {
  chunk.visible = false;
  chunk.userData.attached = false;
}

// Detached chunk class with fractal subdivision
class DetachedChunk {
  constructor(position, size, depth=0, maxDepth=2) {
    this.group = new THREE.Group();
    this.size = size;
    this.depth = depth;
    this.maxDepth = maxDepth;
    this.aliveTime = 0;
    this.fadeDuration = 8; // seconds
    this.velocity = new THREE.Vector3(
      (Math.random()-0.5)*1.5,
      (Math.random()-0.5)*1.5,
      (Math.random()-0.5)*1.5
    );
    this.angularVelocity = new THREE.Vector3(
      (Math.random()-0.5)*0.02,
      (Math.random()-0.5)*0.02,
      (Math.random()-0.5)*0.02
    );
    
    // Create mesh cubes for this chunk or subdivide recursively
    if(depth >= maxDepth) {
      const mesh = createChunk(size, 0xff9933);
      mesh.position.set(0,0,0);
      this.group.add(mesh);
      this.meshes = [mesh];
    } else {
      this.meshes = [];
      const half = size / 2;
      const quarter = size / 4;
      for(let dx=-1; dx<=1; dx+=2) {
        for(let dy=-1; dy<=1; dy+=2) {
          for(let dz=-1; dz<=1; dz+=2) {
            const subChunk = new DetachedChunk( new THREE.Vector3(), half, depth+1, maxDepth);
            subChunk.group.position.set(dx*quarter, dy*quarter, dz*quarter);
            this.group.add(subChunk.group);
            this.meshes.push(subChunk);
          }
        }
      }
    }
    
    this.group.position.copy(position);
    scene.add(this.group);
  }
  
  update(delta) {
    this.aliveTime += delta;
    
    // Move & rotate
    this.group.position.addScaledVector(this.velocity, delta);
    this.group.rotation.x += this.angularVelocity.x;
    this.group.rotation.y += this.angularVelocity.y;
    this.group.rotation.z += this.angularVelocity.z;
    
    // Fade out after fadeDuration
    const fadeProgress = (this.aliveTime - this.fadeDuration) / this.fadeDuration;
    if(fadeProgress > 0) {
      const opacity = THREE.MathUtils.clamp(1 - fadeProgress, 0, 1);
      this.setOpacity(opacity);
      if(opacity <= 0) {
        this.dispose();
        return false; // dead
      }
    }
    
    // Update children if fractal (nested DetachedChunks)
    if(this.depth < this.maxDepth) {
      this.meshes.forEach(child => child.update(delta));
    }
    
    return true;
  }
  
  setOpacity(opacity) {
    if(this.depth >= this.maxDepth) {
      this.meshes.forEach(mesh => {
        mesh.material.opacity = opacity;
      });
    } else {
      this.meshes.forEach(child => child.setOpacity(opacity));
    }
  }
  
  dispose() {
    scene.remove(this.group);
  }
}

// Break off chunks randomly over time
function breakOffChunks() {
  if(detachedChunks.length > MAX_DETACHED) return;
  // Pick a random attached chunk
  const attachedChunks = chunks.filter(c => c.userData.attached);
  if(attachedChunks.length === 0) return;
  const chunk = attachedChunks[Math.floor(Math.random()*attachedChunks.length)];
  detachChunk(chunk);
  
  // Spawn detached fractal chunk
  const detached = new DetachedChunk(chunk.position.clone(), CHUNK_SIZE, 0, 2);
  detachedChunks.push(detached);
}

let lastBreakTime = 0;

// Animation loop
const clock = new THREE.Clock();

function animate() {
  const delta = clock.getDelta();
  const elapsed = clock.elapsedTime;
  
  // Break off a chunk every ~0.4 seconds
  if(elapsed - lastBreakTime > 0.4) {
    breakOffChunks();
    lastBreakTime = elapsed;
  }
  
  // Update detached fractal chunks
  for(let i = detachedChunks.length - 1; i >= 0; i--) {
    const alive = detachedChunks[i].update(delta);
    if(!alive) {
      detachedChunks.splice(i,1);
    }
  }
  
  // Slowly rotate the main brane
  chunkGroup.rotation.y += delta * 0.2;
  chunkGroup.rotation.x = Math.sin(elapsed * 0.1) * 0.1;
  
  // Camera orbits slowly around center
  const radius = 30;
  camera.position.x = Math.cos(elapsed * 0.1) * radius;
  camera.position.z = Math.sin(elapsed * 0.1) * radius;
  camera.position.y = 20 + Math.sin(elapsed * 0.3) * 5;
  camera.lookAt(0, 0, 0);
  
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

animate();

// Resize handling
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>