<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Ultimate Air Combat Spectacle</title>
<style>
  body { margin: 0; overflow: hidden; background: #000011; font-family: monospace; }
  canvas { display: block; }
  #fpsCounter {
    position: fixed; top: 10px; left: 10px; color: #0ff; background: rgba(0,0,0,0.5);
    padding: 5px 8px; border-radius: 4px; font-size: 14px; user-select:none; pointer-events:none;
  }
</style>
</head>
<body>
<div id="fpsCounter">FPS: --</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>

<script>
  // --- Setup ---
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 15, 40);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // --- FPS Counter ---
  const fpsCounter = document.getElementById('fpsCounter');
  let lastFrameTime = performance.now();
  let frameCount = 0;

  // --- Starfield ---
  let starCount = 500;
  let stars;
  function createStars() {
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(starCount * 3);
    for(let i=0; i<starCount; i++) {
      positions[i*3] = (Math.random() - 0.5) * 200;
      positions[i*3+1] = (Math.random() - 0.5) * 200;
      positions[i*3+2] = (Math.random() - 0.5) * 200;
    }
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const material = new THREE.PointsMaterial({ color: 0x88ccff, size: 0.4 });
    stars = new THREE.Points(geometry, material);
    scene.add(stars);
  }
  createStars();

  // --- Plane Model ---
  function createPlane(color) {
    const group = new THREE.Group();

    const bodyMat = new THREE.MeshBasicMaterial({ color });
    const wingMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

    const body = new THREE.Mesh(new THREE.BoxGeometry(2, 0.5, 6), bodyMat);
    group.add(body);

    const wingLeft = new THREE.Mesh(new THREE.BoxGeometry(3, 0.1, 1), wingMat);
    wingLeft.position.set(-2.5, 0, 0);
    wingLeft.rotation.y = Math.PI / 10;
    group.add(wingLeft);

    const wingRight = new THREE.Mesh(new THREE.BoxGeometry(3, 0.1, 1), wingMat);
    wingRight.position.set(2.5, 0, 0);
    wingRight.rotation.y = -Math.PI / 10;
    group.add(wingRight);

    group.userData = { bodyMat, wingMat, wingLeft, wingRight };

    return group;
  }

  const playerPlane = createPlane(0x00ffff);
  playerPlane.position.set(0, 0, 0);
  scene.add(playerPlane);

  const enemyPlane = createPlane(0xff4400);
  enemyPlane.position.set(0, 0, -20);
  scene.add(enemyPlane);

  // --- Engine exhaust trails ---
  class EngineTrail {
    constructor(plane, side) {
      this.plane = plane;
      this.side = side; // -1 left, 1 right
      this.particles = [];
      this.geometry = new THREE.BufferGeometry();
      this.positions = new Float32Array(100 * 3);
      this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
      this.material = new THREE.PointsMaterial({
        color: 0x00aaff,
        size: 0.2,
        transparent: true,
        opacity: 0.5,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });
      this.points = new THREE.Points(this.geometry, this.material);
      scene.add(this.points);
    }

    update() {
      // Add new particle behind plane engine
      const pos = new THREE.Vector3(
        this.plane.position.x + this.side * 1.3,
        this.plane.position.y + 0.1,
        this.plane.position.z + 3.2
      );
      this.particles.push({
        position: pos.clone(),
        life: 1,
        velocity: new THREE.Vector3(
          (Math.random()-0.5)*0.02,
          (Math.random()-0.2)*0.01,
          0.05 + Math.random()*0.05
        )
      });

      // Update particles, shift back, and remove dead ones
      let idx = 0;
      for(let i = this.particles.length -1; i >= 0; i--) {
        const p = this.particles[i];
        p.position.add(p.velocity);
        p.life -= 0.02;
        if(p.life <= 0) this.particles.splice(i, 1);
        else {
          this.positions[idx++] = p.position.x;
          this.positions[idx++] = p.position.y;
          this.positions[idx++] = p.position.z;
        }
      }
      // Clear unused positions
      for(; idx < this.positions.length; idx++) this.positions[idx] = 0;

      this.geometry.attributes.position.needsUpdate = true;
    }

    dispose() {
      scene.remove(this.points);
      this.geometry.dispose();
      this.material.dispose();
    }
  }

  const playerTrailLeft = new EngineTrail(playerPlane, -1);
  const playerTrailRight = new EngineTrail(playerPlane, 1);
  const enemyTrailLeft = new EngineTrail(enemyPlane, -1);
  const enemyTrailRight = new EngineTrail(enemyPlane, 1);

  // --- Bullets with trails ---
  class Bullet {
    constructor(position, velocity, color) {
      this.color = color;
      this.mat = new THREE.MeshBasicMaterial({ color });
      this.mesh = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), this.mat);
      this.mesh.position.copy(position);
      this.velocity = velocity;

      this.trailPositions = new Float32Array(8 * 3);
      this.trailGeometry = new THREE.BufferGeometry();
      this.trailGeometry.setAttribute('position', new THREE.BufferAttribute(this.trailPositions, 3));
      this.trailMaterial = new THREE.PointsMaterial({
        color,
        size: 0.25,
        transparent: true,
        opacity: 0.7,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });
      this.trail = new THREE.Points(this.trailGeometry, this.trailMaterial);

      scene.add(this.mesh);
      scene.add(this.trail);
    }

    update() {
      this.mesh.position.add(this.velocity);
      for(let i=0; i < this.trailPositions.length - 3; i++) {
        this.trailPositions[i] = this.trailPositions[i+3];
      }
      this.trailPositions[this.trailPositions.length - 3] = this.mesh.position.x;
      this.trailPositions[this.trailPositions.length - 2] = this.mesh.position.y;
      this.trailPositions[this.trailPositions.length - 1] = this.mesh.position.z;
      this.trail.geometry.attributes.position.needsUpdate = true;
    }

    dispose() {
      scene.remove(this.mesh);
      scene.remove(this.trail);
      this.mesh.geometry.dispose();
      this.mesh.material.dispose();
      this.trail.geometry.dispose();
      this.trail.material.dispose();
    }
  }
  const bullets = [];

  // --- Explosion with sparks ---
  class Explosion {
    constructor(position) {
      this.elapsed = 0;
      this.duration = 1.5;
      this.done = false;

      // Glow sphere
      this.sphereMat = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 1 });
      this.sphere = new THREE.Mesh(new THREE.SphereGeometry(0.5, 8, 8), this.sphereMat);
      this.sphere.position.copy(position);
      scene.add(this.sphere);

      // Halo sprite
      const spriteMap = createGlowTexture();
      const spriteMat = new THREE.SpriteMaterial({ map: spriteMap, color: 0xff5500, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending, depthWrite: false });
      this.halo = new THREE.Sprite(spriteMat);
      this.halo.position.copy(position);
      this.halo.scale.set(3,3,1);
      scene.add(this.halo);

      // Sparks
      this.sparksCount = 30;
      this.sparksPositions = new Float32Array(this.sparksCount * 3);
      this.sparksVelocities = [];
      for(let i=0; i < this.sparksCount; i++) {
        this.sparksPositions[i*3] = position.x;
        this.sparksPositions[i*3+1] = position.y;
        this.sparksPositions[i*3+2] = position.z;
        this.sparksVelocities.push(new THREE.Vector3(
          (Math.random()-0.5)*3,
          (Math.random()-0.5)*3,
          (Math.random()-0.5)*3
        ));
      }
      this.sparksGeometry = new THREE.BufferGeometry();
      this.sparksGeometry.setAttribute('position', new THREE.BufferAttribute(this.sparksPositions, 3));
      this.sparksMaterial = new THREE.PointsMaterial({
        color: 0xffaa33,
        size: 0.15,
        transparent: true,
        opacity: 1,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      this.sparks = new THREE.Points(this.sparksGeometry, this.sparksMaterial);
      scene.add(this.sparks);
    }

    update(delta) {
      this.elapsed += delta;
      const progress = this.elapsed / this.duration;
      // Expand glow
      this.sphere.scale.setScalar(1 + progress * 3);
      this.sphere.material.opacity = 1 - progress;
      this.halo.material.opacity = 0.6 * (1 - progress);
      this.halo.scale.setScalar(3 + progress * 5);

      // Update sparks
      for(let i=0; i<this.sparksCount; i++) {
        this.sparksPositions[i*3] += this.sparksVelocities[i].x * delta * 5;
        this.sparksPositions[i*3+1] += this.sparksVelocities[i].y * delta * 5;
        this.sparksPositions[i*3+2] += this.sparksVelocities[i].z * delta * 5;
      }
      this.sparksMaterial.opacity = 1 - progress;
      this.sparksGeometry.attributes.position.needsUpdate = true;

      if(this.elapsed >= this.duration) {
        scene.remove(this.sphere);
        scene.remove(this.halo);
        scene.remove(this.sparks);
        this.sphere.geometry.dispose();
        this.sphere.material.dispose();
        this.halo.material.map.dispose();
        this.halo.material.dispose();
        this.sparksGeometry.dispose();
        this.sparksMaterial.dispose();
        this.done = true;
      }
    }
  }
  const explosions = [];

  // --- Flare planes ---
  class Flare {
    constructor() {
      this.mesh = new THREE.Mesh(new THREE.SphereGeometry(0.15, 6, 6), new THREE.MeshBasicMaterial({ color: 0xffffaa }));
      this.mesh.position.set((Math.random()-0.5)*180, (Math.random()-0.5)*100 + 20, -100);
      this.velocity = new THREE.Vector3(0, 0, 0.5 + Math.random()*1.5);
      scene.add(this.mesh);
      this.done = false;
    }

    update() {
      this.mesh.position.add(this.velocity);
      if(this.mesh.position.z > 20) {
        scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
        this.done = true;
      }
    }
  }
  const flares = [];

  // --- Audio setup ---
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  const audioCtx = new AudioContext();

  function playFireSound() {
    if(audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.type = 'square';
    osc.frequency.setValueAtTime(1200, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.05);
  }

  function playExplosionSound() {
    if(audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(200, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
    osc.start();
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
    osc.stop(audioCtx.currentTime + 0.2);
  }

  // --- Targets and fire cooldown ---
  let playerTargetX = 0, enemyTargetX = 0, playerTargetZ = -10, enemyTargetZ = -20;
  const clock = new THREE.Clock();
  let playerFireCooldown = 0, enemyFireCooldown = 0, flareSpawnTimer = 0;

  // Pulsation variables for planes
  let pulseTime = 0;

  // Shake variables
  let shakeIntensity = 0;
  const shakeDecay = 0.03;

  // Autorestart variables
  let battleTime = 0;
  const battleDuration = 120; // 2 minutes

  function fireBullet(plane, color, dirZ) {
    const pos = plane.position.clone();
    pos.z += dirZ * 3;
    const velocity = new THREE.Vector3(0, 0, dirZ * 1.5);
    bullets.push(new Bullet(pos, velocity, color));
    playFireSound();
  }

  function detectCollision(obj1, obj2, threshold=2) {
    return obj1.position.distanceTo(obj2.position) < threshold;
  }

  function animate() {
    const now = performance.now();
    frameCount++;
    if(now - lastFrameTime >= 1000) {
      fpsCounter.textContent = `FPS: ${frameCount}`;
      frameCount = 0;
      lastFrameTime = now;
    }

    const delta = clock.getDelta();
    const elapsed = clock.elapsedTime;
    requestAnimationFrame(animate);

    battleTime += delta;
    if(battleTime > battleDuration) {
      // Reset battle smoothly
      battleTime = 0;
      playerPlane.position.set(0,0,0);
      enemyPlane.position.set(0,0,-20);
      bullets.forEach(b => b.dispose());
      bullets.length = 0;
      explosions.forEach(e => {
        scene.remove(e.sphere);
        scene.remove(e.halo);
        if(e.sparks) scene.remove(e.sparks);
      });
      explosions.length = 0;
      flares.forEach(f => {
        scene.remove(f.mesh);
      });
      flares.length = 0;
      playerFireCooldown = 0;
      enemyFireCooldown = 0;
      shakeIntensity = 0;
    }

    pulseTime += delta * 6;
    const pulseFactor = 0.6 + 0.4 * Math.sin(pulseTime);

    // Pulsate planes
    playerPlane.userData.bodyMat.color.setRGB(0, pulseFactor, pulseFactor);
    playerPlane.userData.wingMat.color.setRGB(pulseFactor, pulseFactor, pulseFactor);
    enemyPlane.userData.bodyMat.color.setRGB(pulseFactor, pulseFactor * 0.27, 0);
    enemyPlane.userData.wingMat.color.setRGB(pulseFactor, pulseFactor, pulseFactor);

    // Wing oscillation for realism
    playerPlane.userData.wingLeft.rotation.z = 0.05 * Math.sin(elapsed * 5);
    playerPlane.userData.wingRight.rotation.z = -0.05 * Math.sin(elapsed * 5);
    enemyPlane.userData.wingLeft.rotation.z = 0.05 * Math.cos(elapsed * 4);
    enemyPlane.userData.wingRight.rotation.z = -0.05 * Math.cos(elapsed * 4);

    // New targets every 4 seconds
    if(elapsed % 4 < delta) {
      playerTargetX = (Math.random() - 0.5) * 20;
      enemyTargetX = (Math.random() - 0.5) * 20;
      playerTargetZ = -5 + (Math.random() - 0.5) * 6;
      enemyTargetZ = -20 + (Math.random() - 0.5) * 6;
    }

    // Move planes smoothly toward targets
    playerPlane.position.x += (playerTargetX - playerPlane.position.x) * delta * 1.5;
    playerPlane.position.z += (playerTargetZ - playerPlane.position.z) * delta * 1.5;

    enemyPlane.position.x += (enemyTargetX - enemyPlane.position.x) * delta * 1.2;
    enemyPlane.position.z += (enemyTargetZ - enemyPlane.position.z) * delta * 1.2;

    // Rotate planes to face movement direction
    playerPlane.rotation.y = -Math.atan2(
      playerTargetZ - playerPlane.position.z,
      playerTargetX - playerPlane.position.x
    ) + Math.PI / 2;

    enemyPlane.rotation.y = -Math.atan2(
      enemyTargetZ - enemyPlane.position.z,
      enemyTargetX - enemyPlane.position.x
    ) + Math.PI / 2;

    // Engine trails update
    playerTrailLeft.update();
    playerTrailRight.update();
    enemyTrailLeft.update();
    enemyTrailRight.update();

    // Fire cooldown updates
    playerFireCooldown -= delta * 60;
    enemyFireCooldown -= delta * 60;

    if (playerFireCooldown <= 0) {
      fireBullet(playerPlane, 0x00ffff, -1);
      playerFireCooldown = 30 + Math.random() * 40;
    }
    if (enemyFireCooldown <= 0) {
      fireBullet(enemyPlane, 0xff4400, 1);
      enemyFireCooldown = 40 + Math.random() * 50;
    }

    // Update bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.update();

      // Remove out of bounds bullets
      if (b.mesh.position.z < -60 || b.mesh.position.z > 60) {
        b.dispose();
        bullets.splice(i, 1);
        continue;
      }

      // Collision detection
      if (b.color === 0x00ffff && detectCollision(b.mesh, enemyPlane)) {
        explosions.push(new Explosion(enemyPlane.position.clone()));
        enemyPlane.position.set(100, 100, 100); // temporarily remove enemy
        b.dispose();
        bullets.splice(i, 1);
        shakeIntensity = 1.5;
        playExplosionSound();

        setTimeout(() => {
          enemyPlane.position.set(0, 0, -20);
        }, 4000);
      }

      if (b.color === 0xff4400 && detectCollision(b.mesh, playerPlane)) {
        explosions.push(new Explosion(playerPlane.position.clone()));
        playerPlane.position.set(100, 100, 100); // temporarily remove player
        b.dispose();
        bullets.splice(i, 1);
        shakeIntensity = 1.5;
        playExplosionSound();

        setTimeout(() => {
          playerPlane.position.set(0, 0, 0);
        }, 4000);
      }
    }

    // Update explosions
    for (let i = explosions.length - 1; i >= 0; i--) {
      explosions[i].update(delta);
      if (explosions[i].done) explosions.splice(i, 1);
    }

    // Spawn flares intermittently
    flareSpawnTimer -= delta;
    if (flareSpawnTimer <= 0) {
      flares.push(new Flare());
      flareSpawnTimer = 0.7 + Math.random();
    }

    // Update flares
    for (let i = flares.length - 1; i >= 0; i--) {
      flares[i].update();
      if (flares[i].done) flares.splice(i, 1);
    }

    // Camera follows midpoint between planes with smooth lerp
    const midPoint = new THREE.Vector3().addVectors(playerPlane.position, enemyPlane.position).multiplyScalar(0.5);
    const camTargetPos = midPoint.clone().add(new THREE.Vector3(0, 15, 40));
    camera.position.lerp(camTargetPos, delta * 2);
    camera.lookAt(midPoint);

    // Camera shake
    if (shakeIntensity > 0) {
      camera.position.x += (Math.random() - 0.5) * shakeIntensity;
      camera.position.y += (Math.random() - 0.5) * shakeIntensity;
      shakeIntensity -= shakeDecay;
      if (shakeIntensity < 0) shakeIntensity = 0;
    }

    renderer.render(scene, camera);
  }

  animate();

  // Window resize handler
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>