<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Debug Complex Brane</title>
<style>
  body { margin: 0; overflow: hidden; background: linear-gradient(180deg, #001022 0%, #000000 100%); }
  canvas { display: block; }
</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script id="vertexShader" type="x-shader/x-vertex">
precision highp float;
uniform float time;
varying vec3 vPos;
varying float vHoleMask;
varying float vGlow;

float hash(vec2 p) {
  return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453123);
}

float noise(vec2 p){
  vec2 i = floor(p);
  vec2 f = fract(p);
  float a = hash(i);
  float b = hash(i + vec2(1.0,0.0));
  float c = hash(i + vec2(0.0,1.0));
  float d = hash(i + vec2(1.0,1.0));
  vec2 u = f*f*(3.0-2.0*f);
  return mix(a,b,u.x) + (c - a)* u.y*(1.0 - u.x) + (d - b)* u.x*u.y;
}

float fbm(vec2 p) {
  float f = 0.0;
  float amp = 0.5;
  float freq = 1.0;
  for(int i=0; i<5; i++) {
    f += amp * noise(p * freq);
    freq *= 2.0;
    amp *= 0.5;
  }
  return f;
}

float holeMask(vec3 pos, vec3 center, float radius, float edge) {
  float dist = length(pos - center);
  return smoothstep(radius, radius - edge, dist);
}

void main() {
  vPos = position;

  vec3 pos = position;

  float n1 = fbm(pos.xz * 0.4 + time * 0.2);
  float n2 = fbm(pos.xz * 2.0 - time * 0.5);

  pos.y += sin(pos.x * 0.9 + time) * 1.8;
  pos.y += n1 * 3.5;
  pos.z += cos(pos.x * 1.7 - time * 0.8) * 1.8;
  pos.x += n2 * 2.5;

  float mask = 1.0;
  float glowVal = 0.0;

  for(int i=0; i<7; i++) {
    float speed = 0.3 + float(i) * 0.15;
    float radius = 1.0 + 0.4 * sin(time * (0.5 + float(i)*0.3));
    vec3 center = vec3(
      sin(time * speed + float(i)) * 3.5,
      cos(time * speed * 1.3 + float(i)*1.5) * 3.5,
      sin(time * speed * 0.9 + float(i)*2.0) * 3.5
    );

    float m = holeMask(pos, center, radius, 0.6);
    mask = min(mask, m);

    float dist = length(pos - center);
    glowVal += smoothstep(radius, radius - 0.5, dist);
  }

  vHoleMask = mask;
  vGlow = clamp(glowVal, 0.0, 1.0);

  pos.y += (1.0 - mask) * -15.0;

  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
}
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
precision highp float;
varying vec3 vPos;
varying float vHoleMask;
varying float vGlow;

void main() {
  // Comment out discard to avoid black screen on fail
  // if(vHoleMask < 0.1) discard;

  float heightFactor = smoothstep(-5.0, 5.0, vPos.y);
  vec3 baseColor = mix(vec3(0.05, 0.3, 0.5), vec3(0.15, 0.9, 1.0), heightFactor);
  vec3 glowColor = vec3(0.9, 1.0, 1.0) * pow(vGlow, 3.0);
  vec3 color = mix(baseColor, glowColor, vGlow * 0.9);

  gl_FragColor = vec4(color, 1.0);
}
</script>

<script>
  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 5, 25);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x001011);
  document.body.appendChild(renderer.domElement);

  const ambient = new THREE.AmbientLight(0x224466, 0.7);
  scene.add(ambient);
  const point = new THREE.PointLight(0x66ccff, 1.1, 80);
  point.position.set(10, 20, 20);
  scene.add(point);

  // Reduced segments for better compatibility
  const geometry = new THREE.SphereGeometry(8, 60, 60);

  const uniforms = { time: { value: 0 } };

  const material = new THREE.ShaderMaterial({
    vertexShader: document.getElementById('vertexShader').textContent,
    fragmentShader: document.getElementById('fragmentShader').textContent,
    uniforms,
    side: THREE.DoubleSide,
    transparent: false, // changed from true
    depthWrite: false,  // changed from true
  });

  const brane = new THREE.Mesh(geometry, material);
  scene.add(brane);

  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);

    uniforms.time.value = clock.getElapsedTime();

    const t = uniforms.time.value * 0.15;
    const radius = 25;
    const camX = Math.cos(t) * radius;
    const camZ = Math.sin(t) * radius;
    const camY = 5 + Math.sin(t * 1.3) * 2;

    camera.position.set(camX, camY, camZ);
    camera.lookAt(0, 0, 0);

    renderer.render(scene, camera);
  }

  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>

</body>
</html>