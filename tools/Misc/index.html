<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Complex Brane Flyaround with Web Fractals</title>
<style>
  body { margin: 0; overflow: hidden; background: linear-gradient(180deg, #001022 0%, #000000 100%); }
  canvas { display: block; }
</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script id="vertexShader" type="x-shader/x-vertex">
precision highp float;
uniform float time;
varying vec3 vPos;
varying float vHoleMask;
varying float vGlow;

float hash(vec2 p) {
  return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453123);
}

float noise(vec2 p){
  vec2 i = floor(p);
  vec2 f = fract(p);
  float a = hash(i);
  float b = hash(i + vec2(1.0,0.0));
  float c = hash(i + vec2(0.0,1.0));
  float d = hash(i + vec2(1.0,1.0));
  vec2 u = f*f*(3.0-2.0*f);
  return mix(a,b,u.x) + (c - a)* u.y*(1.0 - u.x) + (d - b)* u.x*u.y;
}

float fbm(vec2 p) {
  float f = 0.0;
  float amp = 0.5;
  float freq = 1.0;
  for(int i=0; i<5; i++) {
    f += amp * noise(p * freq);
    freq *= 2.0;
    amp *= 0.5;
  }
  return f;
}

float holeMask(vec3 pos, vec3 center, float radius, float edge) {
  float dist = length(pos - center);
  return smoothstep(radius, radius - edge, dist);
}

void main() {
  vPos = position;

  vec3 pos = position;

  float n1 = fbm(pos.xz * 0.4 + time * 0.2);
  float n2 = fbm(pos.xz * 2.0 - time * 0.5);

  pos.y += sin(pos.x * 0.9 + time) * 1.8;
  pos.y += n1 * 3.5;
  pos.z += cos(pos.x * 1.7 - time * 0.8) * 1.8;
  pos.x += n2 * 2.5;

  float mask = 1.0;
  float glowVal = 0.0;

  for(int i=0; i<7; i++) {
    float speed = 0.3 + float(i) * 0.15;
    float radius = 1.0 + 0.4 * sin(time * (0.5 + float(i)*0.3));
    vec3 center = vec3(
      sin(time * speed + float(i)) * 3.5,
      cos(time * speed * 1.3 + float(i)*1.5) * 3.5,
      sin(time * speed * 0.9 + float(i)*2.0) * 3.5
    );

    float m = holeMask(pos, center, radius, 0.6);
    mask = min(mask, m);

    float dist = length(pos - center);
    glowVal += smoothstep(radius, radius - 0.5, dist);
  }

  vHoleMask = mask;
  vGlow = clamp(glowVal, 0.0, 1.0);

  pos.y += (1.0 - mask) * -15.0;

  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
}
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
precision highp float;
varying vec3 vPos;
varying float vHoleMask;
varying float vGlow;

void main() {
  float heightFactor = smoothstep(-5.0, 5.0, vPos.y);
  vec3 baseColor = mix(vec3(0.05, 0.3, 0.5), vec3(0.15, 0.9, 1.0), heightFactor);
  vec3 glowColor = vec3(0.9, 1.0, 1.0) * pow(vGlow, 3.0);
  vec3 color = mix(baseColor, glowColor, vGlow * 0.9);

  gl_FragColor = vec4(color, 0.6); // semi-transparent
}
</script>

<script>
// Basic fractal subdivision for a line segment between p0 and p1
function subdivideLine(p0, p1, displacement, depth) {
  if(depth <= 0) return [p0, p1];

  const mid = p0.clone().lerp(p1, 0.5);

  // Displace mid point randomly perpendicular to line
  const dir = new THREE.Vector3().subVectors(p1, p0).normalize();
  const axis = new THREE.Vector3(0,1,0);
  let perp = new THREE.Vector3().crossVectors(dir, axis);
  if(perp.length() < 0.001) perp = new THREE.Vector3(1,0,0);
  perp.normalize();

  const dispAmount = (Math.random() - 0.5) * displacement;
  perp.multiplyScalar(dispAmount);
  mid.add(perp);

  // Recurse subdivide left and right
  const left = subdivideLine(p0, mid, displacement * 0.6, depth - 1);
  const right = subdivideLine(mid, p1, displacement * 0.6, depth - 1);

  // Combine, avoid duplicate mid point
  return left.slice(0, -1).concat(right);
}

class WebFractal {
  constructor(start, end) {
    this.start = start.clone();
    this.end = end.clone();

    // Generate fractal points
    this.points = subdivideLine(start, end, 3.0, 4); // 4 depth, displacement 3 units

    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(this.points.length * 3);
    for(let i=0; i<this.points.length; i++) {
      positions[i*3] = this.points[i].x;
      positions[i*3+1] = this.points[i].y;
      positions[i*3+2] = this.points[i].z;
    }
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    // Material with additive blending and alpha fade
    this.material = new THREE.LineBasicMaterial({
      color: 0x88ccff,
      transparent: true,
      opacity: 1.0,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
    });

    this.line = new THREE.Line(geometry, this.material);

    this.lifetime = 6.0 + Math.random() * 4; // seconds
    this.age = 0;

    scene.add(this.line);
  }

  update(delta) {
    this.age += delta;
    // Fade out last second
    if(this.age > this.lifetime - 1.0) {
      this.material.opacity = Math.max(0, this.lifetime - this.age);
    }

    if(this.age > this.lifetime) {
      scene.remove(this.line);
      this.line.geometry.dispose();
      this.material.dispose();
      return false; // indicate removal
    }
    return true;
  }
}

// Setup scene, camera, renderer as before

const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 5, 25);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x001011);
document.body.appendChild(renderer.domElement);

const ambient = new THREE.AmbientLight(0x224466, 0.7);
scene.add(ambient);
const point = new THREE.PointLight(0x66ccff, 1.1, 80);
point.position.set(10, 20, 20);
scene.add(point);

const geometry = new THREE.SphereGeometry(8, 60, 60);

const uniforms = { time: { value: 0 } };

const material = new THREE.ShaderMaterial({
  vertexShader: document.getElementById('vertexShader').textContent,
  fragmentShader: document.getElementById('fragmentShader').textContent,
  uniforms,
  side: THREE.DoubleSide,
  transparent: true,
  depthWrite: false,
  opacity: 0.6,
});

const brane = new THREE.Mesh(geometry, material);
scene.add(brane);

const clock = new THREE.Clock();

const webs = [];
const maxWebs = 20;
const webSpawnInterval = 0.3; // seconds
let webSpawnTimer = 0;

// Pick random vertices for webs
const braneVertices = [];
const posAttr = geometry.attributes.position;
for(let i=0; i < posAttr.count; i++) {
  const v = new THREE.Vector3().fromBufferAttribute(posAttr, i);
  braneVertices.push(v);
}

function spawnWeb() {
  // pick two random distinct vertices
  let i1 = Math.floor(Math.random() * braneVertices.length);
  let i2 = Math.floor(Math.random() * braneVertices.length);
  if(i2 === i1) i2 = (i2 + 1) % braneVertices.length;

  // Apply brane deformation function to points to match vertex shader displacement
  // We'll replicate vertex shader logic here for approximate sync:

  function deform(pos, time) {
    let p = pos.clone();

    function fbm(p2) {
      // Simple 3 octave noise substitute (from shader noise approximation)
      let f = 0;
      let amp = 0.5;
      let freq = 1;
      for(let i=0; i<3; i++) {
        f += amp * (Math.sin(p2.x*freq + time) * Math.cos(p2.y*freq + time));
        freq *= 2;
        amp *= 0.5;
      }
      return f;
    }

    let n1 = fbm(new THREE.Vector2(p.x * 0.4, p.z * 0.4) + time * 0.2);
    let n2 = fbm(new THREE.Vector2(p.x * 2.0, p.z * 2.0) - time * 0.5);

    p.y += Math.sin(p.x * 0.9 + time) * 1.8;
    p.y += n1 * 3.5;
    p.z += Math.cos(p.x * 1.7 - time * 0.8) * 1.8;
    p.x += n2 * 2.5;

    return p;
  }

  const t = uniforms.time.value;

  const start = deform(braneVertices[i1], t);
  const end = deform(braneVertices[i2], t);

  return new WebFractal(start, end);
}

function animate() {
  requestAnimationFrame(animate);

  const delta = clock.getDelta();
  uniforms.time.value = clock.getElapsedTime();

  // Camera orbit + gentle motion (same as before)
  const t = uniforms.time.value * 0.15;
  const radius = 25;

  const camX = Math.cos(t) * radius * 1.2 + Math.sin(t * 0.7) * 3;
  const camZ = Math.sin(t) * radius * 1.2 + Math.cos(t * 0.5) * 3;
  const camY = 8 + Math.sin(t * 1.3) * 3;

  camera.position.set(camX, camY, camZ);

  const centerX = Math.sin(t * 2.1) * 1.5;
  const centerY = Math.cos(t * 1.7) * 1.5;
  const centerZ = Math.sin(t * 1.3) * 1.5;

  camera.lookAt(centerX, centerY, centerZ);

  // Spawn webs if under max
  webSpawnTimer += delta;
  if(webSpawnTimer > webSpawnInterval && webs.length < maxWebs) {
    webs.push(spawnWeb());
    webSpawnTimer = 0;
  }

  // Update webs and remove expired
  for(let i=webs.length-1; i>=0; i--) {
    if(!webs[i].update(delta)) {
      webs.splice(i, 1);
    }
  }

  renderer.render(scene, camera);
}

animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>