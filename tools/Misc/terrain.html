<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Slidey-Gooey Armor Simulation</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body { margin: 0; overflow: hidden; }
  canvas { display: block; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>

<script>
// --- Scene setup ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 5, 20);

const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lights
const ambient = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambient);
const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
dirLight.position.set(10, 20, 10);
scene.add(dirLight);

// --- Blocks (armor) ---
const blocks = [];
const blockSize = 1;
const layers = 5;
const width = 5;
const height = layers;
const depth = 5;

const blockGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
const blockMaterial = new THREE.MeshPhongMaterial({color: 0x4444ff});

for(let y=0; y<height; y++){
  for(let x=-Math.floor(width/2); x<=Math.floor(width/2); x++){
    for(let z=-Math.floor(depth/2); z<=Math.floor(depth/2); z++){
      const block = new THREE.Mesh(blockGeometry, blockMaterial.clone());
      block.position.set(x*blockSize, y*blockSize, z*blockSize);
      block.userData = {health: 1, velocity: new THREE.Vector3(), affected: false};
      scene.add(block);
      blocks.push(block);
    }
  }
}

// --- Projectile ---
const projectileGeometry = new THREE.CylinderGeometry(0.3, 0.3, 2, 8);
const projectileMaterial = new THREE.MeshPhongMaterial({color: 0xff2222});
const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
projectile.rotation.x = Math.PI/2;
projectile.position.set(0, 2.5, -20);
scene.add(projectile);
let projectileSpeed = 0.5;

// --- Debris array ---
const debris = [];
const debrisMaterial = new THREE.MeshPhongMaterial({color: 0xffaa00});

// --- Touch controls ---
let isDragging = false;
let previousTouch = null;
let touchDistance = 0;

window.addEventListener('touchstart', e => { isDragging = true; previousTouch = e.touches[0]; });
window.addEventListener('touchmove', e => {
  if(!isDragging) return;
  const touch = e.touches[0];
  const dx = touch.clientX - previousTouch.clientX;
  const dy = touch.clientY - previousTouch.clientY;
  camera.rotation.y -= dx * 0.005;
  camera.rotation.x -= dy * 0.005;
  previousTouch = touch;
});
window.addEventListener('touchend', e => { isDragging = false; previousTouch = null; });

// Pinch zoom
window.addEventListener('gesturechange', e => {
  camera.position.z -= e.scale - 1;
});

// --- Animation loop ---
function animate() {
  requestAnimationFrame(animate);

  // Move projectile
  projectile.position.z += projectileSpeed;

  // Check collision with blocks
  blocks.forEach(block => {
    const distance = block.position.distanceTo(projectile.position);
    if(distance < 1.2 && block.userData.health > 0){
      block.userData.affected = true;
      block.userData.health -= 0.2;
      block.material.color.setRGB(1, 0.5 + block.userData.health*0.5, 0.5 + block.userData.health*0.5);

      // Spawn debris
      const d = new THREE.Mesh(blockGeometry, debrisMaterial.clone());
      d.scale.set(0.3,0.3,0.3);
      d.position.copy(block.position);
      d.userData.velocity = new THREE.Vector3((Math.random()-0.5)*0.2, Math.random()*0.3, (Math.random()-0.5)*0.2);
      scene.add(d);
      debris.push(d);
    }
  });

  // Apply debris motion
  debris.forEach((d,i) => {
    d.position.add(d.userData.velocity);
    d.userData.velocity.y -= 0.01; // gravity
    d.material.opacity = Math.max(0, d.material.opacity - 0.005);
    d.material.transparent = true;
    if(d.material.opacity <= 0) {
      scene.remove(d);
      debris.splice(i,1);
    }
  });

  // Slidey-gooey contagion
  blocks.forEach(block => {
    if(block.userData.affected){
      blocks.forEach(nb => {
        if(nb.userData.health > 0 && !nb.userData.affected){
          if(block.position.distanceTo(nb.position) < 1.5){
            nb.userData.affected = true;
          }
        }
      });
    }
  });

  renderer.render(scene, camera);
}
animate();

// Resize handler
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>