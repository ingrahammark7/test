<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>DU Rod Visualization with Trail</title>
<style>
  body { margin: 0; background: #000; overflow: hidden; }
  canvas { display: block; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
<script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lights
const ambientLight = new THREE.AmbientLight(0xffffff, 0.25);
scene.add(ambientLight);
const pointLight = new THREE.PointLight(0xffaa33, 1.2, 100);
pointLight.position.set(10, 20, 30);
scene.add(pointLight);

// DU Rod geometry
const rodLength = 8;
const rodRadius = 0.5;
const rodGeom = new THREE.CylinderGeometry(rodRadius, rodRadius, rodLength, 64, 64, true);
const rodColors = [];
for(let i=0; i<rodGeom.attributes.position.count; i++){
    const y = rodGeom.attributes.position.getY(i) + rodLength/2;
    const intensity = y/rodLength;
    rodColors.push(intensity, intensity*0.3, 0);
}
rodGeom.setAttribute('color', new THREE.Float32BufferAttribute(rodColors,3));
const rodMat = new THREE.MeshStandardMaterial({
    vertexColors: true,
    emissive: 0xff3300,
    emissiveIntensity: 0.6,
    metalness: 0.7,
    roughness: 0.2,
    side: THREE.DoubleSide
});
const projectile = new THREE.Mesh(rodGeom, rodMat);
projectile.rotation.x = Math.PI/2;
scene.add(projectile);

// Outer glow
const glowGeom = new THREE.CylinderGeometry(rodRadius*1.3, rodRadius*1.3, rodLength*1.1, 32);
const glowMat = new THREE.MeshBasicMaterial({
    color: 0xff8800,
    transparent:true,
    opacity:0.25
});
const glow = new THREE.Mesh(glowGeom, glowMat);
glow.rotation.x = Math.PI/2;
scene.add(glow);

// Trail
const trailLength = 50;
const trailGeom = new THREE.BufferGeometry();
const trailPositions = new Float32Array(trailLength * 3);
trailGeom.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
const trailMat = new THREE.LineBasicMaterial({ color: 0xffaa33, transparent:true, opacity:0.6 });
const trailLine = new THREE.Line(trailGeom, trailMat);
scene.add(trailLine);

// Camera
camera.position.set(0,5,15);
camera.lookAt(projectile.position);

let t = 0;
const trailBuffer = [];
function animate(){
    requestAnimationFrame(animate);
    t+=0.02;

    // Rod bobbing and rotation
    projectile.position.y = Math.sin(t)*0.3;
    glow.position.y = projectile.position.y;
    projectile.rotation.z += 0.015;
    glow.rotation.z += 0.015;

    // Heat pulse
    const pulse = 0.6 + 0.4*Math.sin(t*3);
    rodMat.emissiveIntensity = pulse;
    glow.material.opacity = 0.15 + 0.1*Math.sin(t*3);

    // Camera smooth follow
    camera.position.lerp(new THREE.Vector3(0, 5 + Math.sin(t)*0.5, 15), 0.05);
    camera.lookAt(projectile.position);

    // Update trail
    trailBuffer.unshift(projectile.position.clone());
    if(trailBuffer.length > trailLength) trailBuffer.pop();
    for(let i=0;i<trailBuffer.length;i++){
        trailPositions[i*3] = trailBuffer[i].x;
        trailPositions[i*3+1] = trailBuffer[i].y;
        trailPositions[i*3+2] = trailBuffer[i].z;
    }
    trailGeom.attributes.position.needsUpdate = true;
    trailMat.opacity = 0.6 * (1 - trailBuffer.length/trailLength);

    renderer.render(scene,camera);
}
animate();

// Handle resize
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>