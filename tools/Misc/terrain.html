<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Tank on Terrain — Battle Simulation</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html, body { height: 100%; margin: 0; overflow: hidden; }
  canvas { display: block; }
  #overlay {
    position: fixed; right: 8px; top: 8px;
    width: 320px; background: rgba(0,0,0,0.6);
    color: #fff; font-family: monospace;
    font-size: 12px; padding: 8px; border-radius: 6px;
    z-index: 20;
  }
  #controls {
    position: fixed; left: 8px; top: 8px;
    background: rgba(0,0,0,0.6);
    color: #fff;
    padding: 6px;
    border-radius: 6px;
    font-family: monospace;
    font-size: 12px;
    z-index: 20;
  }
  #controls input { vertical-align: middle; }
</style>
</head>
<body>
<div id="controls">
  Speed: <input type="range" id="speedSlider" min="0.1" max="10" step="0.1" value="1">
  <span id="speedVal">1</span>
  &nbsp; | &nbsp;
  Rotation smooth: <input id="rotSmooth" type="range" min="0.01" max="1" step="0.01" value="0.12">
  &nbsp; | &nbsp;
  Tilt blend: <input id="tiltBlend" type="range" min="0" max="1" step="0.01" value="0.5">
  <span id="tiltVal">0.50</span>
</div>
<div id="overlay">Loading files…</div>

<script src="three.min.js"></script>
<script>
(async function(){
  const overlay = document.getElementById('overlay');

  try {
    const [terrainResp, movesResp, shotsResp] = await Promise.all([
      fetch('f.json'),
      fetch('f2.json'),
      fetch('f3.json')
    ]);
    if(!terrainResp.ok) throw new Error('Failed loading f.json');
    if(!movesResp.ok) throw new Error('Failed loading f2.json');
    if(!shotsResp.ok) throw new Error('Failed loading f3.json');

    const terrainData = await terrainResp.json();
    const movesText = await movesResp.text();
    const shotsText = await shotsResp.text();
    overlay.innerText = 'Files loaded — building scene...';
    buildScene(terrainData, movesText, shotsText);
  } catch(err) {
    overlay.innerText = 'Error loading files: ' + err;
    console.error(err);
  }

  function buildScene(terrainData, movesText, shotsText){
    const DEFAULT_TILT_BLEND = 0.5;

    // Terrain keys
    const xKeys = Object.keys(terrainData).map(Number).sort((a,b)=>a-b);
    const zSet = new Set();
    xKeys.forEach(x => { Object.keys(terrainData[String(x)]||{}).forEach(z => zSet.add(Number(z))); });
    const zKeys = Array.from(zSet).sort((a,b)=>a-b);
    const minX = xKeys[0], maxX = xKeys[xKeys.length-1];
    const minZ = zKeys[0], maxZ = zKeys[zKeys.length-1];
    const centerX = (minX + maxX)/2;
    const centerZ = (minZ + maxZ)/2;
    const terrainWidth = maxX - minX;
    const terrainDepth = maxZ - minZ;

    function findNearestIndex(sorted, v){
      let lo=0, hi=sorted.length-1;
      if(v<=sorted[0]) return 0;
      if(v>=sorted[hi]) return hi;
      while(lo<=hi){
        const mid=(lo+hi)>>1;
        if(sorted[mid]===v) return mid;
        if(sorted[mid]<v) lo=mid+1; else hi=mid-1;
      }
      const a=Math.max(0,lo-1), b=Math.min(sorted.length-1,lo);
      return Math.abs(sorted[a]-v)<=Math.abs(sorted[b]-v)?a:b;
    }

    function heightAtIndex(ix, iz){
      const x=xKeys[ix], z=zKeys[iz];
      return terrainData[String(x)]?.[String(z)]||0;
    }

    // Terrain geometry
    const cols=xKeys.length, rows=zKeys.length;
    const geom = new THREE.BufferGeometry();
    const pos = new Float32Array(cols*rows*3);
    let pi=0;
    for(let i=0;i<rows;i++){
      for(let j=0;j<cols;j++){
        const worldX = xKeys[j], worldZ = zKeys[i];
        const h = terrainData[String(worldX)]?.[String(worldZ)]||0;
        pos[pi++] = worldX; pos[pi++] = h; pos[pi++] = worldZ;
      }
    }
    geom.setAttribute('position', new THREE.BufferAttribute(pos,3));
    const idxs=[];
    for(let i=0;i<rows-1;i++){
      for(let j=0;j<cols-1;j++){
        const a=i*cols+j, b=a+1, c=a+cols, d=c+1;
        idxs.push(a,c,b,b,c,d);
      }
    }
    geom.setIndex(idxs);
    geom.computeVertexNormals();
    const mat=new THREE.MeshStandardMaterial({color:0x228B22, flatShading:true});
    const terrainMesh=new THREE.Mesh(geom, mat);
    terrainMesh.position.set(-centerX,0,-centerZ);

    const scene=new THREE.Scene();
    scene.background=new THREE.Color(0x87ceeb);
    scene.add(terrainMesh);
    const dir=new THREE.DirectionalLight(0xffffff,1);
    dir.position.set(centerX+200,400,centerZ+200);
    scene.add(dir);
    scene.add(new THREE.AmbientLight(0x404040));

    const renderer=new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio||1);
    renderer.setSize(window.innerWidth,window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const camera=new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,5000);

    // Tanks
    const rawMoves = movesText.split('|').filter(s=>s.trim());
    const tanks = {};
    rawMoves.forEach(token=>{
      const m = token.trim();
      const match=m.match(/(-?\d+)\s*,\s*(-?\d+)\s*$/);
      if(!match) return;
      const id = m.split(' ')[0], x=Number(match[1]), z=Number(match[2]);
      if(!tanks[id]) tanks[id]={path:[]};
      tanks[id].path.push([x,z]);
    });

    const colors=[0xff0000,0x0000ff,0xffff00,0xff00ff,0x00ffff,0xff8800];
    let colorIdx=0;
    for(const id in tanks){
      const t=tanks[id];
      const geo=new THREE.BoxGeometry(6,4,6);
      const matTank = new THREE.MeshStandardMaterial({color:colors[colorIdx++%colors.length]});
      const mesh=new THREE.Mesh(geo,matTank);
      const firstWp=t.path[0];
      mesh.position.set(firstWp[0]-centerX, heightAtIndex(findNearestIndex(xKeys,firstWp[0]),findNearestIndex(zKeys,firstWp[1]))+2, firstWp[1]-centerZ);
      scene.add(mesh);
      t.mesh=mesh;
      t.currentIndex=0;
      t.progress=0;
      t._tmp={
        forward:new THREE.Vector3(),
        tangentFwd:new THREE.Vector3(),
        right:new THREE.Vector3(),
        normal:new THREE.Vector3()
      };
      t.cooldown=Math.random()*2; // random shot cooldown
    }

    // --- f3.json pre-recorded shots ---
    const preShotsRaw = shotsText.split('|').filter(s => s.trim());
    const preShots = [];
    preShotsRaw.forEach(s => {
      const nums = s.split(',').map(Number);
      if(nums.length !== 4) return;
      const [x1,z1,x2,z2] = nums;
      const nx1 = findNearestIndex(xKeys,x1), nz1 = findNearestIndex(zKeys,z1);
      const nx2 = findNearestIndex(xKeys,x2), nz2 = findNearestIndex(zKeys,z2);
      const h1 = heightAtIndex(nx1,nz1), h2 = heightAtIndex(nx2,nz2);
      const p1 = new THREE.Vector3(xKeys[nx1]-centerX,h1+1,zKeys[nz1]-centerZ);
      const p2 = new THREE.Vector3(xKeys[nx2]-centerX,h2+1,zKeys[nz2]-centerZ);
      const geom = new THREE.BufferGeometry().setFromPoints([p1,p2]);
      const mat = new THREE.LineBasicMaterial({color:0xffffff});
      const line = new THREE.Line(geom, mat);
      scene.add(line);
      preShots.push(line);
    });

    // Dynamic shots
    const shots=[];
    function fireShot(fromTank, toTank){
      const start = fromTank.mesh.position.clone();
      const end = toTank.mesh.position.clone();
      const geom = new THREE.BufferGeometry().setFromPoints([start,end]);
      const mat = new THREE.LineBasicMaterial({color:0xffffff});
      const line = new THREE.Line(geom, mat);
      scene.add(line);
      shots.push({mesh:line, timer:0.1});
    }

    const diag = Math.sqrt(terrainWidth*terrainWidth + terrainDepth*terrainDepth);
    const camPos = new THREE.Vector3(0, diag*0.6, diag*0.6);
    const camVel = new THREE.Vector3();
    camera.position.copy(camPos);
    camera.lookAt(new THREE.Vector3(0,0,0));

    // UI
    let speed=1;
    const speedSlider=document.getElementById('speedSlider');
    const speedVal=document.getElementById('speedVal');
    speedSlider.addEventListener('input', ()=>{ speed=parseFloat(speedSlider.value); speedVal.innerText=speed.toFixed(1); });
    const rotSmoothInput = document.getElementById('rotSmooth');
    const tiltBlendInput = document.getElementById('tiltBlend');
    const tiltValSpan = document.getElementById('tiltVal');
    tiltBlendInput.addEventListener('input', ()=>{ tiltValSpan.innerText=parseFloat(tiltBlendInput.value).toFixed(2); });

    function computeNormalStencil(ix, iz, outVec){
      const ixm=Math.max(0,ix-1), ixp=Math.min(xKeys.length-1, ix+1);
      const izm=Math.max(0,iz-1), izp=Math.min(zKeys.length-1, iz+1);
      const hL = heightAtIndex(ixm,iz), hR = heightAtIndex(ixp,iz);
      const hD = heightAtIndex(ix,izm), hU = heightAtIndex(ix,izp);
      const dx=(xKeys[ixp]-xKeys[ixm])||1;
      const dz=(zKeys[izp]-zKeys[izm])||1;
      const nxn = -(hR-hL)/dx, nyn=2, nzn=-(hU-hD)/dz;
      const len=Math.sqrt(nxn*nxn+nyn*nyn+nzn*nzn)||1;
      outVec.set(nxn/len,nyn/len,nzn/len);
      return outVec;
    }

    let lastTime=performance.now();
    function animate(){
      requestAnimationFrame(animate);
      const now=performance.now();
      let dt=(now-lastTime)/1000;
      if(dt<=0) dt=1/60;
      dt=Math.min(dt,0.05);
      lastTime=now;
      const delta60=dt/(1/60);

      for(const id in tanks){
        const t=tanks[id];
        const wp=t.path;
        if(!wp||wp.length<2) continue;

        // Move along path
        let remaining = speed*delta60;
        while(remaining>0 && t.currentIndex<wp.length-1){
          const cur = wp[t.currentIndex], nxt = wp[t.currentIndex+1];
          const dx=nxt[0]-cur[0], dz=nxt[1]-cur[1];
          const segLen=Math.hypot(dx,dz)||0.001;
          const distLeft=segLen*(1-t.progress);
          if(remaining>=distLeft){ remaining-=distLeft; t.currentIndex++; t.progress=0;}
          else { t.progress+=remaining/segLen; remaining=0;}
        }

        const cur = wp[t.currentIndex], nxt = wp[Math.min(t.currentIndex+1, wp.length-1)];
        const px=THREE.MathUtils.lerp(cur[0],nxt[0],t.progress)-centerX;
        const pz=THREE.MathUtils.lerp(cur[1],nxt[1],t.progress)-centerZ;
        const ix=findNearestIndex(xKeys, px+centerX), iz=findNearestIndex(zKeys, pz+centerZ);
        const py=heightAtIndex(ix,iz)+2;
        t.mesh.position.set(px,py,pz);

        // Smooth orientation / tilt
        const fdx=nxt[0]-cur[0]||0.001, fdz=nxt[1]-cur[1]||0.001;
        const tmp=t._tmp;
        tmp.forward.set(fdx,0,fdz).normalize();
        computeNormalStencil(ix,iz,tmp.normal);
        const fDotN=tmp.forward.dot(tmp.normal);
        tmp.tangentFwd.copy(tmp.forward).sub(tmp.normal.clone().multiplyScalar(fDotN)).normalize();
        tmp.right.crossVectors(tmp.tangentFwd,tmp.normal).normalize();

        const mMat=new THREE.Matrix4();
        mMat.makeBasis(tmp.right,tmp.normal.clone().normalize(),tmp.tangentFwd.clone().negate());
        const desiredQuat=new THREE.Quaternion().setFromRotationMatrix(mMat);

        const yaw=Math.atan2(tmp.forward.x,tmp.forward.z);
        const yawQuat=new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0),yaw);

        const TILT_BLEND=parseFloat(tiltBlendInput.value||DEFAULT_TILT_BLEND);
        const blendedQuat=yawQuat.clone().slerp(desiredQuat,TILT_BLEND);
        const rotSmooth=parseFloat(rotSmoothInput.value)||0.12;
        const slerpFactor=Math.min(1,rotSmooth*delta60);
        t.mesh.quaternion.slerp(blendedQuat,slerpFactor);

        // Shooting logic
        t.cooldown-=dt;
        if(t.cooldown<=0){
          let closest=null, minDist=Infinity;
          for(const otherId in tanks){
            if(otherId===id) continue;
            const o=tanks[otherId];
            const d = t.mesh.position.distanceTo(o.mesh.position);
            if(d<50 && d<minDist){
              minDist=d;
              closest=o;
            }
          }
          if(closest) fireShot(t, closest);
          t.cooldown=Math.random()*2+0.5;
        }
      }

      // Update shots
      for(let i=shots.length-1;i>=0;i--){
        const s=shots[i];
        s.timer-=dt;
        if(s.timer<=0){
          scene.remove(s.mesh);
          shots.splice(i,1);
        }
      }

      // Camera follow first tank
      const firstTank = tanks[Object.keys(tanks)[0]];
      if(firstTank){
        const f=firstTank.mesh;
        const desired=new THREE.Vector3(f.position.x+diag*0.5, f.position.y+diag*0.3, f.position.z+diag*0.5);
        const k=60, damping=12;
        const disp=desired.clone().sub(camPos);
        const acc=disp.multiplyScalar(k).sub(camVel.clone().multiplyScalar(damping)).multiplyScalar(dt);
        camVel.add(acc);
        camPos.add(camVel.clone().multiplyScalar(dt));
        camera.position.copy(camPos);
        camera.lookAt(f.position);
      }

      renderer.render(scene,camera);
    }
    animate();

    window.addEventListener('resize',()=>{
      renderer.setSize(window.innerWidth,window.innerHeight);
      camera.aspect=window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
    });

    overlay.style.display='none';
  }
})();
</script>
</body>
</html>