<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>3D Dogfight Spectacle</title>
<style>
  body, html { margin:0; padding:0; overflow:hidden; background:#87ceeb; }
  #hud {
    position: absolute; top: 10px; left: 10px; font-size: 18px; color: #fff;
    background: rgba(0,0,0,0.5); padding: 10px; border-radius: 6px;
    user-select: none; font-weight: bold; letter-spacing: 1.2px;
    font-family: sans-serif;
  }
</style>
</head>
<body>

<div id="hud">Score: 0</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>

<script>
// === Setup scene and camera ===
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x87ceeb, 0.02);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 30, 70);
camera.lookAt(0, 5, 0);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// === Lighting ===
scene.add(new THREE.AmbientLight(0xffffff, 0.8));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
dirLight.position.set(10, 20, 10);
scene.add(dirLight);

// Explosion flash light
const flashLight = new THREE.PointLight(0xffaa33, 0, 20, 2);
scene.add(flashLight);

// === Helpers ===
const gridHelper = new THREE.GridHelper(100, 40, 0x444444, 0x888888);
scene.add(gridHelper);

// === Plane model creation ===
function createPlane(color=0xff0000){
  const group = new THREE.Group();

  const fuselageGeo = new THREE.CylinderGeometry(0.3, 0.4, 3, 8);
  const fuselageMat = new THREE.MeshStandardMaterial({color: color});
  const fuselage = new THREE.Mesh(fuselageGeo, fuselageMat);
  fuselage.rotation.z = Math.PI/2;
  group.add(fuselage);

  const wingGeo = new THREE.BoxGeometry(1.5, 0.1, 0.5);
  const wingMat = new THREE.MeshStandardMaterial({color: color});
  const wing = new THREE.Mesh(wingGeo, wingMat);
  group.add(wing);

  const tailWingGeo = new THREE.BoxGeometry(0.7, 0.1, 0.3);
  const tailWing = new THREE.Mesh(tailWingGeo, wingMat);
  tailWing.position.set(-1.3, 0.3, 0);
  group.add(tailWing);

  return group;
}

// === Particle classes ===
class Particle {
  constructor(position) {
    const geo = new THREE.SphereGeometry(0.05 + Math.random()*0.05, 6, 6);
    const mat = new THREE.MeshBasicMaterial({color: 0xffaa00, transparent:true, opacity:1});
    this.mesh = new THREE.Mesh(geo, mat);
    this.mesh.position.copy(position);
    this.velocity = new THREE.Vector3(
      (Math.random()-0.5)*0.5,
      (Math.random()-0.5)*0.5,
      (Math.random()-0.5)*0.5
    );
    this.life = 1.0;
    scene.add(this.mesh);
  }
  update(delta) {
    this.mesh.position.addScaledVector(this.velocity, delta);
    this.life -= delta*1.5;
    this.mesh.material.opacity = this.life;
    if(this.life <= 0) {
      scene.remove(this.mesh);
      return false;
    }
    return true;
  }
}

class SmokeParticle {
  constructor(position) {
    const geo = new THREE.PlaneGeometry(0.3,0.3);
    const tex = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/smoke.png');
    const mat = new THREE.MeshBasicMaterial({map: tex, transparent:true, opacity:0.4, depthWrite:false});
    this.mesh = new THREE.Mesh(geo, mat);
    this.mesh.position.copy(position);
    this.mesh.rotation.x = -Math.PI/2;
    this.life = 2.5;
    scene.add(this.mesh);
  }
  update(delta) {
    this.mesh.position.y += delta*0.3;
    this.life -= delta;
    this.mesh.material.opacity = this.life/2.5 * 0.4;
    if(this.life <= 0) {
      scene.remove(this.mesh);
      return false;
    }
    return true;
  }
}

class FlameParticle {
  constructor(position, velocity) {
    const geo = new THREE.SphereGeometry(0.07 + Math.random()*0.03, 6, 6);
    const mat = new THREE.MeshBasicMaterial({color: 0xff3300, transparent:true, opacity:0.8});
    this.mesh = new THREE.Mesh(geo, mat);
    this.mesh.position.copy(position);
    this.velocity = velocity.clone();
    this.life = 0.5 + Math.random()*0.3;
    scene.add(this.mesh);
  }
  update(delta) {
    this.mesh.position.addScaledVector(this.velocity, delta);
    this.life -= delta;
    this.mesh.material.opacity = this.life * 1.5;
    if(this.life <= 0) {
      scene.remove(this.mesh);
      return false;
    }
    return true;
  }
}

// === Bullet class ===
class Bullet {
  constructor(position, direction) {
    const geo = new THREE.SphereGeometry(0.05, 8, 8);
    const mat = new THREE.MeshBasicMaterial({color: 0xffff00});
    this.mesh = new THREE.Mesh(geo, mat);
    this.mesh.position.copy(position);
    this.velocity = direction.clone().multiplyScalar(6);
    this.life = 3.5;
    scene.add(this.mesh);
  }
  update(delta) {
    this.mesh.position.addScaledVector(this.velocity, delta*60);
    this.life -= delta;
    if(this.life <= 0) {
      scene.remove(this.mesh);
      return false;
    }
    return true;
  }
}

// === Missile class (homing) ===
class Missile {
  constructor(position, target) {
    const geo = new THREE.CylinderGeometry(0.05, 0.05, 0.8, 6);
    const mat = new THREE.MeshStandardMaterial({color: 0xff0000});
    this.mesh = new THREE.Mesh(geo, mat);
    this.mesh.rotation.z = Math.PI/2;
    this.mesh.position.copy(position);
    this.velocity = new THREE.Vector3(1,0,0).multiplyScalar(4);
    this.target = target;
    this.alive = true;
    scene.add(this.mesh);
  }
  update(delta) {
    if(!this.alive) return false;

    if(!this.target || !this.target.alive) {
      this.alive = false;
      scene.remove(this.mesh);
      return false;
    }

    const toTarget = this.target.mesh.position.clone().sub(this.mesh.position).normalize();
    const currentDir = this.velocity.clone().normalize();
    const turnRate = 5;
    const newDir = currentDir.lerp(toTarget, turnRate * delta).normalize();

    this.velocity.add(newDir.multiplyScalar(2 * delta));
    if(this.velocity.length() > 7) this.velocity.setLength(7);

    this.mesh.position.addScaledVector(this.velocity, delta);
    this.mesh.lookAt(this.mesh.position.clone().add(this.velocity));

    const dist = this.mesh.position.distanceTo(this.target.mesh.position);
    if(dist < 1.0) {
      this.target.explode();
      this.alive = false;
      for(let i=0; i<40; i++) explosions.push(new Particle(this.mesh.position.clone()));
      scene.remove(this.mesh);
      triggerExplosionFlash(this.mesh.position);
      triggerCameraShake();
      return false;
    }
    return true;
  }
}

// === AI Plane class ===
class AIPlane {
  constructor(color, startPos) {
    this.mesh = createPlane(color);
    this.mesh.position.copy(startPos);
    this.velocity = new THREE.Vector3(
      (Math.random()-0.5)*0.5,
      (Math.random()-0.5)*0.3,
      (Math.random()-0.5)*0.5
    );
    this.acceleration = new THREE.Vector3();
    this.speedLimit = 3.0;
    this.alive = true;
    this.shootCooldown = 0;
    this.missileCooldown = 5 + Math.random()*5;
    this.boostCooldown = 3 + Math.random()*5;
    this.boosting = false;
    this.boostTime = 0;
    scene.add(this.mesh);
  }

  update(delta, others) {
    if (!this.alive) return;

    // Find closest other plane to chase
    let closest = null;
    let minDist = 1e9;
    others.forEach(p => {
      if (p !== this && p.alive) {
        const dist = this.mesh.position.distanceTo(p.mesh.position);
        if (dist < minDist) {
          minDist = dist;
          closest = p;
        }
      }
    });

    // Steering toward closest plane
    if (closest) {
      const desired = closest.mesh.position.clone().sub(this.mesh.position).normalize().multiplyScalar(this.speedLimit);
      const steer = desired.sub(this.velocity);
      steer.clampLength(0, 3.0);
      this.acceleration.copy(steer);
    } else {
      this.acceleration.set((Math.random()-0.5)*0.1, (Math.random()-0.5)*0.05, (Math.random()-0.5)*0.1);
    }

    // Boost logic
    this.boostCooldown -= delta;
    if(this.boostCooldown <= 0){
      this.boosting = true;
      this.boostTime = 1.2;
      this.boostCooldown = 6 + Math.random()*5;
    }
    if(this.boosting){
      this.speedLimit = 7.5;
      this.boostTime -= delta;
      const tailPos = this.mesh.position.clone().add(new THREE.Vector3(-1.5, 0, 0).applyEuler(this.mesh.rotation));
      for(let i=0; i<3; i++){
        const vel = new THREE.Vector3(-Math.random(), (Math.random()-0.5)*0.3, (Math.random()-0.5)*0.3);
        flameParticles.push(new FlameParticle(tailPos, vel));
      }
      if(this.boostTime <= 0){
        this.boosting = false;
        this.speedLimit = 3.0;
      }
    }

    // Update velocity & clamp speed
    this.velocity.add(this.acceleration.multiplyScalar(delta));
    if(this.velocity.length() > this.speedLimit) {
      this.velocity.setLength(this.speedLimit);
    }

    // Update position
    this.mesh.position.add(this.velocity.clone().multiplyScalar(delta));

    // Keep planes within bounds (simple box)
    const bounds = 25;
    ['x','y','z'].forEach(axis => {
      if(this.mesh.position[axis] > bounds) this.velocity[axis] *= -1;
      if(this.mesh.position[axis] < -bounds) this.velocity[axis] *= -1;
    });

    // Orient plane to velocity with banking roll
    if(this.velocity.length() > 0.001){
      this.mesh.lookAt(this.mesh.position.clone().add(this.velocity));
      const bankTarget = -this.velocity.x * 0.5;
      this.mesh.rotation.z += (bankTarget - this.mesh.rotation.z)*5*delta;
    }

    // Shooting bullets logic
    this.shootCooldown -= delta;
    if(this.shootCooldown <= 0 && closest && minDist < 30 && !this.boosting){
      if(Math.random() < 0.2) {
        this.shoot();
        this.shootCooldown = 0.5 + Math.random()*0.7;
      }
    }

    // Launch missiles
    this.missileCooldown -= delta;
    if(this.missileCooldown <= 0 && closest && minDist < 40){
      if(Math.random() < 0.3){
        this.launchMissile(closest);
        this.missileCooldown = 7 + Math.random()*5;
      }
    }

    // Smoke trail if not boosting
    if(!this.boosting && Math.random() < 0.3){
      smokeParticles.push(new SmokeParticle(this.mesh.position.clone()));
    }
  }

  shoot() {
    const forward = new THREE.Vector3(1, 0, 0).applyQuaternion(this.mesh.quaternion);
    const bulletPos = this.mesh.position.clone().add(forward.clone().multiplyScalar(2));
    bullets.push(new Bullet(bulletPos, forward));
  }

  launchMissile(target) {
    const forward = new THREE.Vector3(1, 0, 0).applyQuaternion(this.mesh.quaternion);
    const missilePos = this.mesh.position.clone().add(forward.clone().multiplyScalar(2));
    missiles.push(new Missile(missilePos, target));
  }

  explode() {
    if (!this.alive) return;
    this.alive = false;
    for (let i = 0; i < 50; i++) {
      explosions.push(new Particle(this.mesh.position.clone()));
    }
    scene.remove(this.mesh);
    triggerExplosionFlash(this.mesh.position);
    triggerCameraShake();
    score += 10;
  }
}

// === Globals ===
const planes = [];
const bullets = [];
const missiles = [];
const explosions = [];
const smokeParticles = [];
const flameParticles = [];

let score = 0;
const hud = document.getElementById('hud');

let camAngle = 0;
let shakeDuration = 0;
const shakeIntensity = 0.5;

// Trigger explosion flash light
function triggerExplosionFlash(position) {
  flashLight.position.copy(position);
  flashLight.intensity = 8;
}

// Trigger camera shake
function triggerCameraShake() {
  shakeDuration = 0.5; // seconds
}

// Check collisions (bullets hit planes)
function checkCollisions() {
  bullets.forEach((b, bi) => {
    planes.forEach((p) => {
      if (p.alive && b.mesh.position.distanceTo(p.mesh.position) < 1.5) {
        p.explode();
        scene.remove(b.mesh);
        bullets.splice(bi, 1);
      }
    });
  });
}

// Create multiple planes
for (let i = 0; i < 6; i++) {
  const color = new THREE.Color().setHSL(i / 6, 0.7, 0.5);
  const plane = new AIPlane(color.getHex(), new THREE.Vector3(
    (Math.random() - 0.5) * 40,
    5 + Math.random() * 10,
    (Math.random() - 0.5) * 40
  ));
  planes.push(plane);
}

// === Animation Loop ===
function animate() {
  requestAnimationFrame(animate);

  const delta = Math.min(0.05, renderer.info.render.frame ? (performance.now() - renderer.info.render.frame) / 1000 : 0.016);
  renderer.info.render.frame = performance.now();

  // Update planes
  planes.forEach(p => p.update(delta, planes));

  // Update bullets
  for (let i = bullets.length - 1; i >= 0; i--) {
    if (!bullets[i].update(delta)) bullets.splice(i, 1);
  }

  // Update missiles
  for (let i = missiles.length - 1; i >= 0; i--) {
    if (!missiles[i].update(delta)) missiles.splice(i, 1);
  }

  // Update particles
  for (let i = explosions.length - 1; i >= 0; i--) {
    if (!explosions[i].update(delta)) explosions.splice(i, 1);
  }
  for (let i = smokeParticles.length - 1; i >= 0; i--) {
    if (!smokeParticles[i].update(delta)) smokeParticles.splice(i, 1);
  }
  for (let i = flameParticles.length - 1; i >= 0; i--) {
    if (!flameParticles[i].update(delta)) flameParticles.splice(i, 1);
  }

  // Check collisions
  checkCollisions();

  // Fade explosion flash light
  flashLight.intensity -= delta * 15;
  if (flashLight.intensity < 0) flashLight.intensity = 0;

  // Camera orbit with shake
  camAngle += delta * 0.15;
  const radius = 70;
  let camX = Math.cos(camAngle) * radius;
  let camZ = Math.sin(camAngle) * radius;
  let camY = 30 + Math.sin(camAngle * 2) * 8;

  if (shakeDuration > 0) {
    shakeDuration -= delta;
    const shakeAmount = shakeIntensity;
    camX += (Math.random() - 0.5) * shakeAmount;
    camY += (Math.random() - 0.5) * shakeAmount;
    camZ += (Math.random() - 0.5) * shakeAmount;
  }

  camera.position.set(camX, camY, camZ);
  camera.lookAt(0, 5, 0);

  // Update HUD
  hud.innerHTML = `Score: ${score}`;

  renderer.render(scene, camera);
}

// Resize handler
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();

</script>
</body>
</html>