<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Dynamic 3D Plasma Sphere + Plane</title>
<style>
  body { margin: 0; overflow: hidden; background: black; color: white; }
  canvas { display: block; }
  #debug {
    position: fixed;
    top: 5px; left: 5px;
    font-family: monospace;
    background: rgba(0,0,0,0.7);
    padding: 8px;
    border-radius: 4px;
    max-width: 300px;
    max-height: 150px;
    overflow: auto;
    z-index: 1000;
  }
</style>
</head>
<body>
<div id="debug">Debug console:<br></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

<script>
const debugDiv = document.getElementById('debug');
function logDebug(msg) {
  console.log(msg);
  debugDiv.innerHTML += msg + '<br>';
}

logDebug('Starting dynamic plasma setup...');
if (typeof THREE !== 'undefined') {
  logDebug('Three.js loaded successfully.');
} else {
  logDebug('Error: Three.js failed to load.');
}

// Scene setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.z = 3;

const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  logDebug('Window resized: ' + window.innerWidth + 'x' + window.innerHeight);
});

// Shaders with dynamic vertex displacement & plasma coloring
const vertexShader = `
  varying vec2 vUv;
  uniform float time;

  float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
  }

  void main() {
    vUv = uv;

    float displacement = 0.1 * sin(5.0 * position.x + time) 
                       + 0.05 * sin(7.0 * position.y + time * 1.5) 
                       + 0.03 * rand(uv + time);

    vec3 newPosition = position + normal * displacement;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
  }
`;

const fragmentShader = `
  precision highp float;
  uniform float time;
  varying vec2 vUv;

  void main() {
    float x = vUv.x * 15.0;
    float y = vUv.y * 15.0;
    float intensity = sin(x + time) + sin(y + time*1.2) + sin(x + y + time*1.5);
    intensity = (intensity + 3.0) / 6.0;
    vec3 color = mix(vec3(0.0, 0.2, 0.6), vec3(1.0, 0.6, 0.1), intensity);
    gl_FragColor = vec4(color, 1.0);
  }
`;

let material;
try {
  material = new THREE.ShaderMaterial({
    vertexShader,
    fragmentShader,
    uniforms: { time: { value: 0 } },
    side: THREE.DoubleSide
  });
  logDebug('ShaderMaterial created successfully.');
} catch(e) {
  logDebug('ShaderMaterial creation error: ' + e);
  material = new THREE.MeshBasicMaterial({color: 0xff0000});
}

const sphere = new THREE.Mesh(new THREE.SphereGeometry(1, 64, 64), material);
scene.add(sphere);

const plane = new THREE.Mesh(new THREE.PlaneGeometry(3, 3), material);
plane.position.y = -2.2;
scene.add(plane);

scene.add(new THREE.AxesHelper(2));

logDebug('Starting animation loop.');

function animate(time) {
  requestAnimationFrame(animate);
  material.uniforms.time.value = time * 0.001;
  sphere.rotation.y += 0.005;
  renderer.render(scene, camera);
}

animate();
</script>
</body>
</html>