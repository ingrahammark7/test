<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Fast Aircraft with Plasma and Meltdown</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 5, 15);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(10, 20, 10);
  scene.add(light);

  // Aircraft geometry (cone)
  const aircraftGeometry = new THREE.ConeGeometry(1, 3, 8);
  const aircraftMaterial = new THREE.MeshStandardMaterial({ color: 0x0077ff, transparent: true, opacity: 1 });
  const aircraft = new THREE.Mesh(aircraftGeometry, aircraftMaterial);
  aircraft.rotation.x = Math.PI / 2;
  scene.add(aircraft);

  // Plasma effect: layered transparent spheres around aircraft
  const plasmaGroup = new THREE.Group();
  scene.add(plasmaGroup);

  const plasmaSpheres = [];
  const plasmaCount = 3;
  for(let i=0; i<plasmaCount; i++) {
    const plasmaGeo = new THREE.SphereGeometry(1 + i*0.5, 32, 32);
    const plasmaMat = new THREE.MeshBasicMaterial({
      color: 0x33ccff,
      transparent: true,
      opacity: 0.4 / (i+1),
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    const plasmaSphere = new THREE.Mesh(plasmaGeo, plasmaMat);
    plasmaGroup.add(plasmaSphere);
    plasmaSpheres.push(plasmaSphere);
  }

  // Clouds
  const cloudCountTarget = 100;
  const clouds = [];
  const cloudSpawnRadius = 50;
  const cloudRemoveRadius = 60;

  function createCloud(position) {
    const geometry = new THREE.SphereGeometry(0.5 + Math.random(), 16, 16);
    const material = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.3 + Math.random() * 0.3
    });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.copy(position);
    mesh.userData.velocity = new THREE.Vector3(
      (Math.random() - 0.5) * 0.01,
      (Math.random() - 0.5) * 0.005,
      (Math.random() - 0.5) * 0.01
    );
    scene.add(mesh);
    return mesh;
  }

  for (let i = 0; i < cloudCountTarget; i++) {
    const pos = new THREE.Vector3(
      (Math.random() - 0.5) * cloudSpawnRadius * 2,
      (Math.random() - 0.5) * cloudSpawnRadius,
      (Math.random() - 0.5) * cloudSpawnRadius * 2
    );
    clouds.push(createCloud(pos));
  }

  // Aircraft motion params
  let aircraftAngle = 0;
  let speed = 0.1;
  const maxSpeed = 1.0;
  const acceleration = 0.002;

  // Meltdown control
  let meltingDown = false;
  let meltProgress = 0;

  // Animate loop
  function animate() {
    requestAnimationFrame(animate);

    // Increase speed if not melting down
    if (!meltingDown) {
      speed += acceleration;
      if (speed > maxSpeed) {
        meltingDown = true;
        meltProgress = 0;
      }
    }

    // Update aircraft position - fast circular path
    aircraftAngle += speed;
    aircraft.position.set(Math.cos(aircraftAngle) * 20, 5, Math.sin(aircraftAngle) * 20);
    aircraft.rotation.z = aircraftAngle + Math.PI / 2;

    // Position plasma group at aircraft
    plasmaGroup.position.copy(aircraft.position);

    // Animate plasma spheres (pulse opacity & scale)
    plasmaSpheres.forEach((sphere, idx) => {
      const pulse = Math.sin(Date.now() * 0.005 + idx * 2) * 0.3 + 0.7;
      sphere.material.opacity = 0.4 * pulse * (meltingDown ? (1 - meltProgress) : 1);
      sphere.scale.setScalar(1 + 0.2 * pulse * (meltingDown ? (1 - meltProgress) : 1));
    });

    if (meltingDown) {
      meltProgress += 0.01;
      // Fade out aircraft
      aircraft.material.opacity = 1 - meltProgress;
      if (meltProgress >= 1) {
        // Respawn aircraft and plasma
        meltingDown = false;
        speed = 0.1;
        aircraft.material.opacity = 1;
        aircraftAngle = 0;
        aircraft.position.set(20, 5, 0);
        plasmaGroup.position.copy(aircraft.position);
      }
    }

    // Update clouds
    for (let i = clouds.length - 1; i >= 0; i--) {
      const cloud = clouds[i];
      cloud.position.add(cloud.userData.velocity);
      if (cloud.position.distanceTo(camera.position) > cloudRemoveRadius) {
        scene.remove(cloud);
        clouds.splice(i, 1);
      }
    }
    while (clouds.length < cloudCountTarget) {
      const direction = new THREE.Vector3(
        (Math.random() - 0.5),
        (Math.random() - 0.5) * 0.5,
        (Math.random() - 0.5)
      ).normalize();

      const distance = cloudSpawnRadius * 0.9 + Math.random() * (cloudSpawnRadius * 0.2);
      const spawnPos = camera.position.clone().add(direction.multiplyScalar(distance));
      clouds.push(createCloud(spawnPos));
    }

    // Camera chase
    const desiredPosition = aircraft.position.clone().add(new THREE.Vector3(0, 5, 15));
    camera.position.lerp(desiredPosition, 0.1);
    camera.lookAt(aircraft.position);

    renderer.render(scene, camera);
  }

  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>