<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>3D Dogfight Spectacle Enhanced</title>
<style>
  body, html {
    margin:0; padding:0; overflow:hidden; background:#202040; color:#eee; font-family:sans-serif;
  }
  canvas { display:block; }
  #hud {
    position: absolute; top: 10px; left: 10px; font-size: 18px; color: #fff;
    background: rgba(0,0,0,0.5); padding: 10px; border-radius: 6px;
    user-select: none;
  }
</style>
</head>
<body>

<div id="hud">Score: 0</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>

<script>
// === Basic setup ===
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb); // sky blue

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
scene.add(ambientLight);

const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
dirLight.position.set(10,20,10);
scene.add(dirLight);

// --- Helper: create basic plane model ---
function createPlane(color=0xff0000){
  const group = new THREE.Group();

  const fuselageGeo = new THREE.CylinderGeometry(0.3, 0.4, 3, 8);
  const fuselageMat = new THREE.MeshStandardMaterial({color: color});
  const fuselage = new THREE.Mesh(fuselageGeo, fuselageMat);
  fuselage.rotation.z = Math.PI/2;
  group.add(fuselage);

  const wingGeo = new THREE.BoxGeometry(1.5, 0.1, 0.5);
  const wingMat = new THREE.MeshStandardMaterial({color: color});
  const wing = new THREE.Mesh(wingGeo, wingMat);
  group.add(wing);

  const tailWingGeo = new THREE.BoxGeometry(0.7, 0.1, 0.3);
  const tailWing = new THREE.Mesh(tailWingGeo, wingMat);
  tailWing.position.set(-1.3, 0.3, 0);
  group.add(tailWing);

  return group;
}

// --- Particles for explosion ---
class Particle {
  constructor(position) {
    const geo = new THREE.SphereGeometry(0.05 + Math.random()*0.05, 6, 6);
    const mat = new THREE.MeshBasicMaterial({color: 0xffaa00, transparent:true, opacity:1});
    this.mesh = new THREE.Mesh(geo, mat);
    this.mesh.position.copy(position);
    this.velocity = new THREE.Vector3(
      (Math.random()-0.5)*0.5,
      (Math.random()-0.5)*0.5,
      (Math.random()-0.5)*0.5
    );
    this.life = 1.0;
    scene.add(this.mesh);
  }
  update(delta) {
    this.mesh.position.addScaledVector(this.velocity, delta);
    this.life -= delta*1.5;
    this.mesh.material.opacity = this.life;
    if(this.life <= 0) {
      scene.remove(this.mesh);
      return false;
    }
    return true;
  }
}

const explosions = [];

// --- Smoke trail ---
class SmokeParticle {
  constructor(position) {
    const geo = new THREE.PlaneGeometry(0.3,0.3);
    const tex = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/smoke.png');
    const mat = new THREE.MeshBasicMaterial({map: tex, transparent:true, opacity:0.4, depthWrite:false});
    this.mesh = new THREE.Mesh(geo, mat);
    this.mesh.position.copy(position);
    this.mesh.rotation.x = -Math.PI/2;
    this.life = 2.5;
    scene.add(this.mesh);
  }
  update(delta) {
    this.mesh.position.y += delta*0.3;
    this.life -= delta;
    this.mesh.material.opacity = this.life/2.5 * 0.4;
    if(this.life <= 0) {
      scene.remove(this.mesh);
      return false;
    }
    return true;
  }
}
const smokeParticles = [];

// --- Bullet class with trail ---
class Bullet {
  constructor(position, direction) {
    const geo = new THREE.SphereGeometry(0.05, 8, 8);
    const mat = new THREE.MeshBasicMaterial({color: 0xffff00});
    this.mesh = new THREE.Mesh(geo, mat);
    this.mesh.position.copy(position);
    this.velocity = direction.clone().multiplyScalar(3);
    this.life = 3.5;
    scene.add(this.mesh);
  }
  update(delta) {
    this.mesh.position.addScaledVector(this.velocity, delta*60);
    this.life -= delta;
    if(this.life <= 0) {
      scene.remove(this.mesh);
      return false;
    }
    return true;
  }
}

// --- Plane class with AI movement and shooting ---
class AIPlane {
  constructor(color, startPos) {
    this.mesh = createPlane(color);
    this.mesh.position.copy(startPos);
    this.speed = 0.4 + Math.random()*0.3;
    this.angle = Math.random()*Math.PI*2;
    this.amplitude = 5 + Math.random()*5;
    this.heightBase = startPos.y;
    this.shootCooldown = 0;
    scene.add(this.mesh);
    this.alive = true;
  }
  update(delta) {
    if(!this.alive) return;

    // Circular movement with vertical sine wave for altitude change
    this.angle += this.speed * delta;
    const x = this.amplitude * Math.cos(this.angle);
    const z = this.amplitude * Math.sin(this.angle) - 30;
    const y = this.heightBase + Math.sin(this.angle * 3) * 2;

    // Set position & orientation
    this.mesh.position.set(x, y, z);
    // Look slightly ahead on path
    const nextX = this.amplitude * Math.cos(this.angle + 0.1);
    const nextZ = this.amplitude * Math.sin(this.angle + 0.1) - 30;
    const nextY = this.heightBase + Math.sin((this.angle + 0.1)*3)*2;

    const dir = new THREE.Vector3(nextX - x, nextY - y, nextZ - z).normalize();
    this.mesh.lookAt(this.mesh.position.clone().add(dir));

    // Shoot bullets randomly
    this.shootCooldown -= delta;
    if(this.shootCooldown <= 0) {
      if(Math.random() < 0.1) {
        this.shoot();
        this.shootCooldown = 0.7 + Math.random()*0.5;
      }
    }

    // Add smoke trail
    if(Math.random() < 0.3) {
      smokeParticles.push(new SmokeParticle(this.mesh.position.clone()));
    }
  }
  shoot() {
    const forward = new THREE.Vector3(1,0,0).applyEuler(this.mesh.rotation);
    bullets.push(new Bullet(this.mesh.position.clone(), forward));
  }
  explode() {
    this.alive = false;
    for(let i=0; i<20; i++) {
      explosions.push(new Particle(this.mesh.position.clone()));
    }
    scene.remove(this.mesh);
  }
  respawn() {
    this.alive = true;
    this.angle = Math.random()*Math.PI*2;
    this.mesh.position.set(this.amplitude * Math.cos(this.angle), this.heightBase, this.amplitude * Math.sin(this.angle) - 30);
    scene.add(this.mesh);
  }
}

const planes = [];
for(let i=0; i<6; i++) {
  planes.push(new AIPlane(0x3333ff, new THREE.Vector3(10*(i-2.5), 5 + Math.random()*5, -30)));
}

// Player-free, just spectacle

// --- Bullets array ---
const bullets = [];

// --- HUD ---
const hud = document.getElementById('hud');
let score = 0;

// --- Collision Detection ---
function checkCollisions() {
  bullets.forEach((bullet,i) => {
    planes.forEach(plane => {
      if(plane.alive && bullet.mesh.position.distanceTo(plane.mesh.position) < 0.8) {
        plane.explode();
        scene.remove(bullet.mesh);
        bullets.splice(i,1);
        score += 10;
      }
    });
  });
}

// --- Animate ---
const clock = new THREE.Clock();
let camAngle = 0;

function animate() {
  requestAnimationFrame(animate);

  const delta = clock.getDelta();

  // Update planes
  planes.forEach(p => {
    p.update(delta);
    // Respawn after explosion after 3 sec
    if(!p.alive) {
      if(!p._respawnTimer) p._respawnTimer = 3;
      p._respawnTimer -= delta;
      if(p._respawnTimer <= 0){
        p.respawn();
        p._respawnTimer = null;
      }
    }
  });

  // Update bullets
  bullets.forEach((b,i) => {
    if(!b.update(delta)) bullets.splice(i,1);
  });

  // Update particles
  explosions.forEach((p,i) => {
    if(!p.update(delta)) explosions.splice(i,1);
  });
  smokeParticles.forEach((p,i) => {
    if(!p.update(delta)) smokeParticles.splice(i,1);
  });

  // Check collisions
  checkCollisions();

  // Camera: orbit dynamically around center
  camAngle += delta * 0.2;
  const radius = 40;
  camera.position.set(
    Math.cos(camAngle)*radius,
    15 + Math.sin(camAngle*2)*5,
    Math.sin(camAngle)*radius - 20
  );
  camera.lookAt(0,5,-30);

  // Update HUD
  hud.innerHTML = `Score: ${score}`;

  renderer.render(scene, camera);
}

animate();

// --- Resize ---
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>