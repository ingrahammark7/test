<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Debug Terrain Viewer</title>
<style>
  body { margin: 0; overflow: hidden; }
  #log {
    position: fixed;
    top: 0; left: 0; width: 100%; max-height: 200px;
    overflow-y: scroll;
    background: rgba(0,0,0,0.7);
    color: white;
    font-family: monospace;
    padding: 4px;
    z-index: 100;
  }
  canvas { display: block; }
</style>
</head>
<body>
<div id="log"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
<script>
const logDiv = document.getElementById('log');
function log(msg) { 
    console.log(msg); 
    logDiv.innerHTML += msg + "<br>"; 
    logDiv.scrollTop = logDiv.scrollHeight;
}

// ===== Sample embedded terrain (coarse) =====
const terrainData = {
  "0": {"0": 3.437, "8": 9.242, "16": 4.036},
  "8": {"0": 3.626, "8": 4.936, "16": 12.85},
  "16": {"0": 4.236, "8": 6.946, "16": 3.769}
};

let scene, camera, renderer, terrainMesh;

init();
animate();

function init() {
    try {
        log("Step 1: Terrain loaded (embedded).");

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);

        log("Step 2: Creating sampled grid...");
        const xKeys = Object.keys(terrainData).map(k => parseInt(k));
        const yKeysSet = new Set();
        xKeys.forEach(x => {
            Object.keys(terrainData[x]).forEach(y => yKeysSet.add(parseInt(y)));
        });
        const yKeys = Array.from(yKeysSet);

        const cols = xKeys.length;
        const rows = yKeys.length;
        log(`Grid size: cols=${cols}, rows=${rows}`);

        log("Step 3: Creating PlaneGeometry...");
        const geometry = new THREE.PlaneGeometry(cols*8, rows*8, cols-1, rows-1);
        const verts = geometry.attributes.position.array;

        log("Step 4: Filling vertices with heights...");
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                const xKey = xKeys[j];
                const yKey = yKeys[i];
                let h = terrainData[xKey] && terrainData[xKey][yKey] !== undefined ? terrainData[xKey][yKey] : 0;
                const idx = 3*(i*cols + j);
                verts[idx+2] = h;
            }
        }
        geometry.computeVertexNormals();
        log("Step 5: Geometry ready.");

        const material = new THREE.MeshStandardMaterial({color: 0x228B22, flatShading: true});
        terrainMesh = new THREE.Mesh(geometry, material);
        terrainMesh.rotation.x = -Math.PI/2;
        scene.add(terrainMesh);
        log("Step 6: Mesh added to scene.");

        log("Step 7: Setting up camera...");
        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(cols*4, 50, rows*4 + 50);
        camera.lookAt(cols*4, 0, rows*4);

        log("Step 8: Adding lights...");
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(100, 200, 100);
        scene.add(dirLight);
        scene.add(new THREE.AmbientLight(0x404040));

        log("Step 9: Initializing renderer...");
        renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        log("Step 10: Setting up device orientation...");
        if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', (event) => {
                const beta = event.beta || 0;
                const gamma = event.gamma || 0;

                camera.position.x += gamma * 0.05;
                camera.position.z += beta * 0.05;
                camera.lookAt(cols*4, 0, rows*4);
            }, true);
        }

        log("All steps completed. Ready to render.");

    } catch (err) {
        log("ERROR: " + err.message);
        console.error(err);
    }
}

function animate() {
    requestAnimationFrame(animate);
    if(renderer) renderer.render(scene, camera);
}
</script>
</body>
</html>