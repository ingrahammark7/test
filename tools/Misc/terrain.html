<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>APFSDS Armor Penetration Simulation</title>
<style>body{margin:0;overflow:hidden;background:#000;}</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>

// --- Scene Setup ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(30,20,60);
camera.lookAt(0,5,0);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- Lighting ---
scene.add(new THREE.AmbientLight(0x555555));
const pointLight = new THREE.PointLight(0xffffff,1,200);
pointLight.position.set(0,20,30);
scene.add(pointLight);

// --- Shader Material ---
const blockVertexShader = `
varying vec3 vPos;
void main(){
    vPos = position;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
}
`;
const blockFragmentShader = `
uniform float glow;
varying vec3 vPos;
void main(){
    vec3 color = mix(vec3(0.2,0.2,1.0), vec3(1.0,0.5,0.0), glow);
    gl_FragColor = vec4(color,1.0);
}
`;

// --- Armor Grid ---
const layersCount = 3;
const armor = [];
const armorSize = {x:6, y:4, z:12};
const blockSize = 2;
for(let l=0;l<layersCount;l++){
  armor[l]=[];
  for(let i=0;i<armorSize.x;i++){
    armor[l][i]=[];
    for(let j=0;j<armorSize.y;j++){
      armor[l][i][j]=[];
      for(let k=0;k<armorSize.z;k++){
        const mat = new THREE.ShaderMaterial({
          uniforms:{ glow:{value:0.0} },
          vertexShader:blockVertexShader,
          fragmentShader:blockFragmentShader
        });
        const cube = new THREE.Mesh(new THREE.BoxGeometry(blockSize,blockSize,blockSize), mat);
        cube.position.set((i-armorSize.x/2)*blockSize, (j-armorSize.y/2)*blockSize+5, (k-armorSize.z/2)*blockSize+l*blockSize*armorSize.z);
        scene.add(cube);
        armor[l][i][j][k]={mesh:cube,intact:true,velocity:null,age:0,shrink:0,glowLevel:0,energyReceived:0};
      }
    }
  }
}

// --- Projectile ---
const projectile = new THREE.Mesh(new THREE.BoxGeometry(1.5,1.5,4), new THREE.MeshStandardMaterial({color:0xff0000, emissive:0xff3300}));
projectile.position.set(0,5,-30);
scene.add(projectile);
let projSpeed = 1.5;

// --- Sparks and Debris ---
const sparks = [];
const debris = [];
function createSpark(position){
  const geom = new THREE.SphereGeometry(0.2,4,4);
  const mat = new THREE.MeshStandardMaterial({color:0x00ffff,emissive:0x00ffff});
  const spark = new THREE.Mesh(geom, mat);
  spark.position.copy(position);
  spark.velocity = {x:(Math.random()-0.5)*0.5, y:Math.random()*0.5, z:(Math.random()-0.5)*0.5};
  spark.age = 0;
  scene.add(spark);
  sparks.push(spark);
}
function createDebris(position){
  const geom = new THREE.BoxGeometry(0.3,0.3,0.3);
  const mat = new THREE.MeshStandardMaterial({color:0x999999});
  const d = new THREE.Mesh(geom, mat);
  d.position.copy(position);
  d.velocity = {x:(Math.random()-0.5)*1, y:Math.random()*1, z:(Math.random()-0.5)*1};
  d.age = 0;
  scene.add(d);
  debris.push(d);
}

// --- Contagion Propagation ---
function propagateGlow(){
  for(let l=0;l<layersCount;l++){
    for(let i=0;i<armorSize.x;i++){
      for(let j=0;j<armorSize.y;j++){
        for(let k=0;k<armorSize.z;k++){
          const block = armor[l][i][j][k];
          if(block.glowLevel > 0.3 || block.energyReceived > 0.1){
            const neighbors = [
              [l+1,i,j,k],[l-1,i,j,k],[l,i+1,j,k],[l,i-1,j,k],
              [l,i,j+1,k],[l,i,j-1,k],[l,i,j,k+1],[l,i,j,k-1]
            ];
            neighbors.forEach(([nl,ni,nj,nk])=>{
              const nblock = armor[nl]?.[ni]?.[nj]?.[nk];
              if(nblock && nblock.intact){
                const energyTransfer = block.energyReceived > 0.1 ? block.energyReceived*0.6 : block.glowLevel*0.5;
                nblock.energyReceived = Math.max(nblock.energyReceived, energyTransfer);
                nblock.mesh.material.uniforms.glow.value = Math.max(nblock.mesh.material.uniforms.glow.value, nblock.energyReceived);
                nblock.shrink = Math.max(nblock.shrink, 0.03);
                nblock.glowLevel = Math.max(nblock.glowLevel, nblock.energyReceived);
              }
            });
          }
        }
      }
    }
  }
}

// --- Animation ---
function animate(){
  requestAnimationFrame(animate);

  // Move projectile
  if(projectile.position.z < layersCount*armorSize.z*blockSize){
    projectile.position.z += projSpeed;

    // Collision detection
    for(let l=0;l<layersCount;l++){
      for(let i=0;i<armorSize.x;i++){
        for(let j=0;j<armorSize.y;j++){
          for(let k=0;k<armorSize.z;k++){
            const block = armor[l][i][j][k];
            if(!block.intact) continue;
            const dx = projectile.position.x - block.mesh.position.x;
            const dy = projectile.position.y - block.mesh.position.y;
            const dz = projectile.position.z - block.mesh.position.z;
            if(Math.sqrt(dx*dx+dy*dy+dz*dz) < blockSize){
              block.intact=false;
              block.mesh.material.uniforms.glow.value = 1.0;
              block.velocity = {x:(Math.random()-0.5)*0.5, y:Math.random()*0.5, z:(Math.random()-0.5)*0.5};
              block.age=0;
              block.shrink = 0.1;
              block.glowLevel = 1.0;
              block.energyReceived = 1.0;
              createSpark(block.mesh.position);
              for(let d=0; d<5; d++) createDebris(block.mesh.position);
            }
          }
        }
      }
    }
  }

  // Spread contagion
  propagateGlow();

  // Update blocks
  for(let l=0;l<layersCount;l++){
    for(let i=0;i<armorSize.x;i++){
      for(let j=0;j<armorSize.y;j++){
        for(let k=0;k<armorSize.z;k++){
          const block = armor[l][i][j][k];
          if(block.velocity){
            block.mesh.position.x += block.velocity.x;
            block.mesh.position.y += block.velocity.y;
            block.mesh.position.z += block.velocity.z;
            block.velocity.y -= 0.01;
            block.age+=1;
            block.mesh.material.uniforms.glow.value = Math.max(block.mesh.material.uniforms.glow.value -0.02,0);
            if(block.shrink>0){
              block.mesh.scale.x = Math.max(block.mesh.scale.x - block.shrink,0.1);
              block.mesh.scale.y = Math.max(block.mesh.scale.y - block.shrink,0.1);
              block.mesh.scale.z = Math.max(block.mesh.scale.z - block.shrink,0.1);
              block.shrink *= 0.95;
            }
          }
          if(block.energyReceived > 0.05 && block.intact){
            block.shrink = Math.max(block.shrink, 0.01 + block.energyReceived*0.05);
            block.mesh.material.uniforms.glow.value = Math.max(block.mesh.material.uniforms.glow.value, block.energyReceived);
            block.energyReceived *= 0.95;
          }
        }
      }
    }
  }

  // Update sparks
  for(let i=sparks.length-1;i>=0;i--){
    const s = sparks[i];
    s.position.x += s.velocity.x;
    s.position.y += s.velocity.y;
    s.position.z += s.velocity.z;
    s.velocity.y -= 0.02;
    s.age+=1;
    if(s.age>50){ scene.remove(s); sparks.splice(i,1); }
  }

  // Update debris
  for(let i=debris.length-1;i>=0;i--){
    const d = debris[i];
    d.position.x += d.velocity.x;
    d.position.y += d.velocity.y;
    d.position.z += d.velocity.z;
    d.velocity.y -= 0.01;
    d.age+=1;
    if(d.age>100){ scene.remove(d); debris.splice(i,1); }
  }

  renderer.render(scene,camera);
}
animate();

</script>
</body>
</html>