<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Nucleon Dynamics Demo</title>
<style>
  body { margin:0; overflow:hidden; }
  canvas { display:block; }
</style>
</head>
<body>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';

// === Scene & Renderer ===
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,20,50);
let cameraTarget = new THREE.Vector3(0,0,0);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// === Lights ===
const light = new THREE.DirectionalLight(0xffffff,1);
light.position.set(50,50,50);
scene.add(light);
const ambLight = new THREE.AmbientLight(0x555555);
scene.add(ambLight);

// === Nucleon Class ===
class Nucleon {
    constructor(){
        const geom = new THREE.SphereGeometry(0.5,8,8);
        const mat = new THREE.MeshStandardMaterial({color:0xff4444});
        this.mesh = new THREE.Mesh(geom, mat);
        this.mesh.position.set((Math.random()-0.5)*20, (Math.random()-0.5)*20, (Math.random()-0.5)*20);
        this.velocity = new THREE.Vector3((Math.random()-0.5)*2, (Math.random()-0.5)*2, (Math.random()-0.5)*2);
        this.userData = {energy: Math.random()};
        scene.add(this.mesh);
        this.createSpiral();
        this.createWave();
    }

    createSpiral(){
        const points = [];
        const radius = 0.4;
        const turns = 2;
        const segments = 12;
        for(let i=0;i<=segments;i++){
            const t = i/segments*Math.PI*2*turns;
            points.push(new THREE.Vector3(radius*Math.cos(t), i/segments*0.5, radius*Math.sin(t)));
        }
        const geom = new THREE.BufferGeometry().setFromPoints(points);
        const mat = new THREE.LineBasicMaterial({color:0x00ffff, transparent:true, opacity:0.6});
        this.spiral = new THREE.Line(geom, mat);
        scene.add(this.spiral);
    }

    createWave(){
        const geom = new THREE.RingGeometry(0.1, 0.15, 16);
        const mat = new THREE.MeshBasicMaterial({color:0xff00ff, transparent:true, opacity:0.2, side:THREE.DoubleSide});
        this.wave = new THREE.Mesh(geom, mat);
        scene.add(this.wave);
        this.waveRadius = 0.1;
    }

    update(delta, boxSize){
        // Position update
        this.mesh.position.addScaledVector(this.velocity, delta);
        // Simple containment
        ['x','y','z'].forEach(axis=>{
            if(this.mesh.position[axis] > boxSize) { this.mesh.position[axis]=boxSize; this.velocity[axis]*=-0.8; }
            if(this.mesh.position[axis] < -boxSize) { this.mesh.position[axis]=-boxSize; this.velocity[axis]*=-0.8; }
        });
        // Spiral update
        this.spiral.position.copy(this.mesh.position);
        this.spiral.rotation.y += delta*5*this.userData.energy;
        this.spiral.rotation.x += delta*2;
        // Wave update
        this.wave.position.copy(this.mesh.position);
        this.waveRadius += delta*0.5*this.userData.energy;
        if(this.waveRadius>1) this.waveRadius=0.1;
        this.wave.scale.set(this.waveRadius,this.waveRadius,this.waveRadius);
    }
}

// === Particle Trail ===
class Trail {
    constructor(){
        this.geometry = new THREE.BufferGeometry();
        this.positions = new Float32Array(1000*3);
        this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions,3));
        const mat = new THREE.LineBasicMaterial({color:0xffff00, transparent:true, opacity:0.3});
        this.line = new THREE.Line(this.geometry, mat);
        scene.add(this.line);
        this.index=0;
    }
    emit(pos){
        this.positions[this.index*3] = pos.x;
        this.positions[this.index*3+1] = pos.y;
        this.positions[this.index*3+2] = pos.z;
        this.index = (this.index+1)%1000;
        this.geometry.attributes.position.needsUpdate=true;
    }
}

// === Initialize Nucleons & Trail ===
const nucleons = [];
const trail = new Trail();
for(let i=0;i<100;i++) nucleons.push(new Nucleon());

// === Camera Control ===
let targetX=0, targetZ=0, distance=50, rotationY=0, targetRotationY=0;
window.addEventListener('deviceorientation', e=>{
    targetX = (e.gamma||0)*0.5;
    targetZ = -(e.beta||0)*0.5;
}, true);
let isDragging=false, prevX=0;
window.addEventListener('mousedown', e=>{isDragging=true; prevX=e.clientX;});
window.addEventListener('mouseup', ()=>isDragging=false);
window.addEventListener('mousemove', e=>{
    if(isDragging){ const dx=e.clientX-prevX; targetRotationY+=dx*0.005; prevX=e.clientX; }
});
let touchDistance=0;
window.addEventListener('touchstart', e=>{
    if(e.touches.length===2){
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        touchDistance = Math.sqrt(dx*dx + dy*dy);
    }
});
window.addEventListener('touchmove', e=>{
    if(e.touches.length===1){
        const dx = e.touches[0].clientX - prevX;
        targetRotationY += dx*0.005;
        prevX = e.touches[0].clientX;
    } else if(e.touches.length===2){
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const newDistance = Math.sqrt(dx*dx + dy*dy);
        const delta = newDistance - touchDistance;
        distance -= delta*0.1;
        distance = Math.max(20,Math.min(150,distance));
        touchDistance = newDistance;
    }
});

// === Animation Loop ===
let boxSize = 30;
let lastTime=performance.now();
function animate(){
    requestAnimationFrame(animate);
    const now=performance.now();
    const delta=(now-lastTime)/1000;
    lastTime=now;

    nucleons.forEach(n=>{
        n.update(delta, boxSize);
        trail.emit(n.mesh.position);
    });

    // Camera smooth follow
    rotationY += (targetRotationY - rotationY)*0.05;
    camera.position.x = targetX + Math.sin(rotationY)*distance;
    camera.position.z = targetZ + Math.cos(rotationY)*distance;
    camera.position.y = 20;
    camera.lookAt(cameraTarget);

    renderer.render(scene,camera);
}
animate();

// === Resize ===
window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>