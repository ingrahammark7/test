<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Tank on Terrain — Smooth Movement</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{height:100%;margin:0}
  canvas{display:block}
  #overlay{
    position:fixed; right:8px; top:8px;
    width:320px; background:rgba(0,0,0,0.6);
    color:#fff; font-family:monospace;
    font-size:12px; padding:8px; border-radius:6px;
  }
</style>
</head>
<body>
<div id="overlay">Loading files…</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
<script>
(async function(){
  const overlay = document.getElementById('overlay');

  try{
    const [terrainResp, movesResp] = await Promise.all([
      fetch('f.json'),
      fetch('f2.json')
    ]);
    if(!terrainResp.ok) throw new Error('Failed loading f.json');
    if(!movesResp.ok) throw new Error('Failed loading f2.json');

    const terrainData = await terrainResp.json();
    const movesText = await movesResp.text();
    overlay.innerText = 'Files loaded — building scene...';
    buildScene(terrainData, movesText);
  }catch(err){
    overlay.innerText = 'Error loading files: ' + err;
    console.error(err);
  }

  function buildScene(terrainData, movesText){
    // Terrain keys
    const xKeys = Object.keys(terrainData).map(Number).sort((a,b)=>a-b);
    const zSet = new Set();
    xKeys.forEach(x=>{
      Object.keys(terrainData[String(x)]||{}).forEach(z=>zSet.add(Number(z)));
    });
    const zKeys = Array.from(zSet).sort((a,b)=>a-b);
    const minX=xKeys[0], maxX=xKeys[xKeys.length-1];
    const minZ=zKeys[0], maxZ=zKeys[zKeys.length-1];
    const centerX=(minX+maxX)/2, centerZ=(minZ+maxZ)/2;
    const cols = xKeys.length, rows = zKeys.length;

    // Terrain geometry
    const geom = new THREE.BufferGeometry();
    const pos = new Float32Array(cols*rows*3);
    let pi=0;
    for(let i=0;i<rows;i++){
      for(let j=0;j<cols;j++){
        const worldX = xKeys[j], worldZ = zKeys[i];
        const h = terrainData[String(worldX)]?.[String(worldZ)]||0;
        pos[pi++] = worldX; pos[pi++] = h; pos[pi++] = worldZ;
      }
    }
    geom.setAttribute('position', new THREE.BufferAttribute(pos,3));
    const idxs = [];
    for(let i=0;i<rows-1;i++){
      for(let j=0;j<cols-1;j++){
        const a=i*cols+j, b=a+1, c=a+cols, d=c+1;
        idxs.push(a,c,b,b,c,d);
      }
    }
    geom.setIndex(idxs);
    geom.computeVertexNormals();

    const mat = new THREE.MeshStandardMaterial({color:0x228B22, flatShading:true});
    const terrainMesh = new THREE.Mesh(geom, mat);
    terrainMesh.position.set(-centerX,0,-centerZ);

    // Scene + lights
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);
    scene.add(terrainMesh);
    const dir = new THREE.DirectionalLight(0xffffff,1);
    dir.position.set(centerX+200,400,centerZ+200);
    scene.add(dir);
    scene.add(new THREE.AmbientLight(0x404040));

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio||1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,5000);

    // Parse tank moves
    const rawMoves = movesText.split('|').filter(s=>s.trim());
    const tanks = {};
    rawMoves.forEach(token=>{
      const m = token.trim();
      if(!m) return;
      const match = m.match(/(-?\d+)\s*,\s*(-?\d+)\s*$/);
      if(!match) return;
      const id = m.split(' ')[0], x=Number(match[1]), z=Number(match[2]);
      if(!tanks[id]) tanks[id]={path:[]};
      tanks[id].path.push([x,z]);
    });

    // Helper: Bilinear terrain height
    function getTerrainHeight(x, z) {
      const findNearestIdx = (arr, v) => {
        for (let i = 0; i < arr.length - 1; i++) if (v >= arr[i] && v <= arr[i+1]) return i;
        return arr.length-2;
      };
      const ix = findNearestIdx(xKeys, x), iz = findNearestIdx(zKeys, z);
      const x0=xKeys[ix], x1=xKeys[ix+1], z0=zKeys[iz], z1=zKeys[iz+1];
      const h00=terrainData[x0]?.[z0]||0, h10=terrainData[x1]?.[z0]||0;
      const h01=terrainData[x0]?.[z1]||0, h11=terrainData[x1]?.[z1]||0;
      const tx=(x-x0)/(x1-x0), tz=(z-z0)/(z1-z0);
      return (h00*(1-tx)+h10*tx)*(1-tz) + (h01*(1-tx)+h11*tx)*tz;
    }

    // Create tank meshes and mapped path
    const colors=[0xff0000,0x0000ff,0xffff00,0xff00ff,0x00ffff,0xff8800];
    let colorIdx=0;
    for(const id in tanks){
      const t=tanks[id];
      const geo=new THREE.BoxGeometry(6,4,6);
      const matTank = new THREE.MeshStandardMaterial({color:colors[colorIdx++%colors.length]});
      const mesh = new THREE.Mesh(geo,matTank);
      mesh.position.set(0,2,0);
      scene.add(mesh);
      t.mesh=mesh;

      // Map path to world coordinates
      t.worldPath = t.path.map(([tx,tz])=>{
        const x = tx - centerX;
        const z = tz - centerZ;
        const y = getTerrainHeight(tx, tz) + 2;
        return {x,y,z};
      });
      if(t.worldPath.length) {
        const p0 = t.worldPath[0];
        mesh.position.set(p0.x, p0.y, p0.z);
      }
      t.currentIndex = 0;
    }

    // Initialize camera above first tank
    const firstId = Object.keys(tanks)[0];
    if(firstId){
      const f = tanks[firstId].mesh;
      camera.position.set(f.position.x+60, f.position.y+80, f.position.z+120);
      camera.lookAt(f.position);
    }

    // Clock for delta time
    const clock = new THREE.Clock();
    const moveSpeed = 15; // units per second

    function animate(){
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      for(const id in tanks){
        const t = tanks[id];
        const wp = t.worldPath;
        if(wp.length<2) continue;

        const cur = wp[t.currentIndex];
        const next = wp[Math.min(t.currentIndex+1, wp.length-1)];
        const dir = new THREE.Vector3(next.x-cur.x,0,next.z-cur.z);
        const dist = dir.length();
        dir.normalize();

        const move = moveSpeed*delta;
        if(move >= dist){
          t.currentIndex = Math.min(t.currentIndex+1, wp.length-1);
          t.mesh.position.set(next.x,next.y,next.z);
        } else {
          t.mesh.position.x += dir.x*move;
          t.mesh.position.z += dir.z*move;
          const worldX = t.mesh.position.x+centerX;
          const worldZ = t.mesh.position.z+centerZ;
          t.mesh.position.y = getTerrainHeight(worldX, worldZ)+2;
        }

        // Smooth rotation
        const targetRotation = Math.atan2(dir.x, dir.z);
        t.mesh.rotation.y = THREE.MathUtils.lerp(t.mesh.rotation.y, targetRotation, 0.1);
      }

      // Camera follow
      if(firstId){
        const f = tanks[firstId].mesh;
        const desired = new THREE.Vector3(f.position.x+60,f.position.y+80,f.position.z+120);
        camera.position.lerp(desired,0.1);
        camera.lookAt(f.position);
      }

      renderer.render(scene,camera);
    }
    animate();

    window.addEventListener('resize',()=>{
      renderer.setSize(window.innerWidth,window.innerHeight);
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
    });
    overlay.style.display='none';
  }
})();
</script>
</body>
</html>