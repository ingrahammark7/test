<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Tank on Terrain — Smooth Movement + Rotation + Tilt + Camera Spring + Paths</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html, body { height: 100%; margin: 0; overflow: hidden; }
  canvas { display: block; }
  #overlay {
    position: fixed; right: 8px; top: 8px;
    width: 320px; background: rgba(0,0,0,0.6);
    color: #fff; font-family: monospace;
    font-size: 12px; padding: 8px; border-radius: 6px;
    z-index: 20;
  }
  #controls {
    position: fixed; left: 8px; top: 8px;
    background: rgba(0,0,0,0.6);
    color: #fff;
    padding: 6px;
    border-radius: 6px;
    font-family: monospace;
    font-size: 12px;
    z-index: 20;
  }
  #controls input { vertical-align: middle; }
</style>
</head>
<body>
<div id="controls">
  Speed: <input type="range" id="speedSlider" min="0.1" max="10" step="0.1" value="1">
  <span id="speedVal">1</span>
  &nbsp; | &nbsp;
  Rotation smooth: <input id="rotSmooth" type="range" min="0.01" max="1" step="0.01" value="0.12">
</div>
<div id="overlay">Loading files…</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
<script>
(async function(){
  const overlay = document.getElementById('overlay');

  try {
    const [terrainResp, movesResp] = await Promise.all([
      fetch('f.json'),
      fetch('f2.json')
    ]);
    if(!terrainResp.ok) throw new Error('Failed loading f.json');
    if(!movesResp.ok) throw new Error('Failed loading f2.json');

    const terrainData = await terrainResp.json();
    const movesText = await movesResp.text();
    overlay.innerText = 'Files loaded — building scene...';
    buildScene(terrainData, movesText);
  } catch(err) {
    overlay.innerText = 'Error loading files: ' + err;
    console.error(err);
  }

  function buildScene(terrainData, movesText){
    // --- Build grid keys + helpers ---
    const xKeys = Object.keys(terrainData).map(Number).sort((a,b)=>a-b);
    const zSet = new Set();
    xKeys.forEach(x => {
      Object.keys(terrainData[String(x)]||{}).forEach(z => zSet.add(Number(z)));
    });
    const zKeys = Array.from(zSet).sort((a,b)=>a-b);

    const minX = xKeys[0], maxX = xKeys[xKeys.length-1];
    const minZ = zKeys[0], maxZ = zKeys[zKeys.length-1];
    const centerX = (minX + maxX) / 2;
    const centerZ = (minZ + maxZ) / 2;
    const cols = xKeys.length, rows = zKeys.length;

    function findNearest(sorted, v){
      let lo=0, hi=sorted.length-1;
      if(v<=sorted[0]) return sorted[0];
      if(v>=sorted[hi]) return sorted[hi];
      while(lo<=hi){
        const mid = Math.floor((lo+hi)/2);
        if(sorted[mid] === v) return v;
        if(sorted[mid] < v) lo = mid+1; else hi = mid-1;
      }
      const a = sorted[Math.max(0, lo-1)], b = sorted[Math.min(sorted.length-1, lo)];
      return (Math.abs(a-v) <= Math.abs(b-v)) ? a : b;
    }

    // quick height sampling function (uses grid keys) - OPTION B
    function sampleHeightAtWorld(xWorld, zWorld){
      // xWorld,zWorld in original world coords (NOT center-shifted)
      const nx = findNearest(xKeys, xWorld);
      const nz = findNearest(zKeys, zWorld);
      return terrainData[String(nx)]?.[String(nz)] || 0;
    }

    // For slope/tilt: sample four neighbouring heights around current position
    function computeNormalFast(xWorld, zWorld){
      // find nearest grid indices
      const nx = findNearest(xKeys, xWorld);
      const nz = findNearest(zKeys, zWorld);

      // pick neighbor offsets in index space (±1 index if available)
      const ix = xKeys.indexOf(nx);
      const iz = zKeys.indexOf(nz);
      const ixm = Math.max(0, ix-1), ixp = Math.min(xKeys.length-1, ix+1);
      const izm = Math.max(0, iz-1), izp = Math.min(zKeys.length-1, iz+1);

      // coords
      const x_m = xKeys[ixm], x_p = xKeys[ixp];
      const z_m = zKeys[izm], z_p = zKeys[izp];

      // heights
      const h_xm = terrainData[String(x_m)]?.[String(nz)] || 0;
      const h_xp = terrainData[String(x_p)]?.[String(nz)] || 0;
      const h_zm = terrainData[String(nx)]?.[String(z_m)] || 0;
      const h_zp = terrainData[String(nx)]?.[String(z_p)] || 0;

      // compute partial derivatives
      const dx = (h_xp - h_xm) / (x_p - x_m || 1);
      const dz = (h_zp - h_zm) / (z_p - z_m || 1);

      // normal approximation: n = (-dx, 1, -dz) then normalize
      const nxn = -dx, nyn = 1, nzn = -dz;
      const len = Math.sqrt(nxn*nxn + nyn*nyn + nzn*nzn) || 1;
      return new THREE.Vector3(nxn/len, nyn/len, nzn/len);
    }

    // --- Terrain geometry (same as before) ---
    const geom = new THREE.BufferGeometry();
    const pos = new Float32Array(cols*rows*3);
    let pi=0;
    for(let i=0;i<rows;i++){
      for(let j=0;j<cols;j++){
        const worldX = xKeys[j], worldZ = zKeys[i];
        const h = terrainData[String(worldX)]?.[String(worldZ)]||0;
        pos[pi++] = worldX; pos[pi++] = h; pos[pi++] = worldZ;
      }
    }
    geom.setAttribute('position', new THREE.BufferAttribute(pos,3));
    const idxs = [];
    for(let i=0;i<rows-1;i++){
      for(let j=0;j<cols-1;j++){
        const a=i*cols+j, b=a+1, c=a+cols, d=c+1;
        idxs.push(a,c,b,b,c,d);
      }
    }
    geom.setIndex(idxs);
    geom.computeVertexNormals();

    const mat = new THREE.MeshStandardMaterial({color:0x228B22, flatShading:true});
    const terrainMesh = new THREE.Mesh(geom, mat);
    terrainMesh.position.set(-centerX,0,-centerZ);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);
    scene.add(terrainMesh);
    const dir = new THREE.DirectionalLight(0xffffff,1);
    dir.position.set(centerX+200,400,centerZ+200);
    scene.add(dir);
    scene.add(new THREE.AmbientLight(0x404040));

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio||1);
    renderer.setSize(window.innerWidth,window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,5000);

    // Parse tank moves (f2.json content)
    const rawMoves = movesText.split('|').filter(s=>s.trim());
    const tanks = {};
    rawMoves.forEach(token=>{
      const m = token.trim();
      if(!m) return;
      const match = m.match(/(-?\d+)\s*,\s*(-?\d+)\s*$/);
      if(!match) return;
      const id = m.split(' ')[0], x = Number(match[1]), z = Number(match[2]);
      if(!tanks[id]) tanks[id] = { path: [] };
      tanks[id].path.push([x,z]);
    });

    function makePathLine(worldPathPoints, color=0x000000){
      const pts = [];
      for(const p of worldPathPoints){
        pts.push(new THREE.Vector3(p.x, p.y-1, p.z)); // slightly below tank center
      }
      const g = new THREE.BufferGeometry().setFromPoints(pts);
      const mat = new THREE.LineBasicMaterial({linewidth: 2, color});
      const line = new THREE.Line(g, mat);
      return line;
    }

    // Create tanks, compute worldPath (center-shifted coordinates)
    const colors = [0xff0000,0x0000ff,0xffff00,0xff00ff,0x00ffff,0xff8800];
    let colorIdx = 0;
    for(const id in tanks){
      const t = tanks[id];
      const geo = new THREE.BoxGeometry(6,4,6);
      const matTank = new THREE.MeshStandardMaterial({color: colors[colorIdx++ % colors.length]});
      const mesh = new THREE.Mesh(geo, matTank);
      mesh.castShadow = true;
      mesh.position.set(0,2,0);
      scene.add(mesh);
      t.mesh = mesh;

      t.worldPath = t.path.map(([tx,tz])=>{
        const nx = findNearest(xKeys, tx), nz = findNearest(zKeys, tz);
        const h = terrainData[String(nx)]?.[String(nz)] || 0;
        return { tx:nx, nz:nz, x:nx-centerX, y:h+2, z:nz-centerZ };
      });

      // add a path preview line (use same color but darker)
      const line = makePathLine(t.worldPath, 0x000000 ^ (colors[(colorIdx-1) % colors.length] & 0x333333));
      scene.add(line);
      t.pathLine = line;

      if(t.worldPath.length){
        const p0 = t.worldPath[0];
        mesh.position.set(p0.x, p0.y, p0.z);
      }
      t.currentIndex = 0;
      t.progress = 0;
    }

    // initial camera target
    const firstId = Object.keys(tanks)[0];
    let camPos = new THREE.Vector3();
    let camVel = new THREE.Vector3();
    if(firstId){
      const f = tanks[firstId].mesh;
      camPos.set(f.position.x+60, f.position.y+80, f.position.z+120);
      camera.position.copy(camPos);
      camera.lookAt(f.position);
    }

    // UI
    let speed = 1;
    const speedSlider = document.getElementById('speedSlider');
    const speedVal = document.getElementById('speedVal');
    speedSlider.addEventListener('input', ()=>{
      speed = parseFloat(speedSlider.value);
      speedVal.innerText = speed.toFixed(1);
    });
    const rotSmoothInput = document.getElementById('rotSmooth');

    // Frame-rate independent animation
    let lastTime = performance.now();
    function animate(){
      requestAnimationFrame(animate);
      const now = performance.now();
      const dt = Math.min(50, now - lastTime) / 1000; // clamp dt for stability (s)
      lastTime = now;

      // convert dt to 60FPS baseline multiplier (preserves previous delta behavior)
      const delta60 = dt / (1/60);

      // --- Movement & rotation & tilt ---
      for(const id in tanks){
        const t = tanks[id];
        const wp = t.worldPath;
        if(wp.length < 2) continue;

        // Precompute segment lengths
        if(!t._len){
          t._len = [];
          for(let i=0;i<wp.length-1;i++){
            const dx = wp[i+1].x - wp[i].x;
            const dy = wp[i+1].y - wp[i].y;
            const dz = wp[i+1].z - wp[i].z;
            t._len[i] = Math.sqrt(dx*dx + dy*dy + dz*dz);
            // avoid zero-length
            if(t._len[i] === 0) t._len[i] = 0.0001;
          }
        }

        let remaining = speed * delta60; // movement units per frame (distance units)
        while(remaining > 0 && t.currentIndex < wp.length - 1){
          const segLen = t._len[t.currentIndex];
          const distLeft = segLen * (1 - t.progress);
          if(remaining >= distLeft){
            remaining -= distLeft;
            t.currentIndex++;
            t.progress = 0;
          } else {
            t.progress += remaining / segLen;
            remaining = 0;
          }
        }

        // positions
        const cur = wp[t.currentIndex];
        const nxt = wp[Math.min(t.currentIndex + 1, wp.length - 1)];
        const px = THREE.MathUtils.lerp(cur.x, nxt.x, t.progress);
        const py = THREE.MathUtils.lerp(cur.y, nxt.y, t.progress);
        const pz = THREE.MathUtils.lerp(cur.z, nxt.z, t.progress);
        t.mesh.position.set(px, py, pz);

        // compute forward direction (world coords) - small epsilon fallback
        const dirX = (nxt.x - cur.x) || 0.0001;
        const dirZ = (nxt.z - cur.z) || 0.0001;
        const forward = new THREE.Vector3(dirX, 0, dirZ).normalize();

        // desired yaw (rotation around Y) - note three's +Z forward, +X right
        const desiredYaw = Math.atan2(forward.x, forward.z); // swap to get heading

        // compute normal from nearby heights using Option B (fast)
        // We need to convert to original world coords (undo center shift)
        const worldX = px + centerX;
        const worldZ = pz + centerZ;
        const normal = computeNormalFast(worldX, worldZ);

        // build desired quaternion from normal + yaw:
        // We want the tank's local Y axis to align with 'normal' and face desiredYaw.
        // Build a basis: z' = forward flattened and rotated to lie tangent plane.
        // Simpler approach: construct a lookAt matrix using a target ahead projected onto tangent plane.

        // Create a target point ahead in world coords (small lookahead)
        const lookAheadDist = 1.5;
        const aheadX = worldX + forward.x * lookAheadDist;
        const aheadZ = worldZ + forward.z * lookAheadDist;
        // sample ahead height to approximate looking direction on terrain
        const aheadH = sampleHeightAtWorld(aheadX, aheadZ) + 2; // tank height offset
        const ahead = new THREE.Vector3(aheadX - centerX, aheadH, aheadZ - centerZ);

        // current tank world position in shifted coords
        const centerPos = new THREE.Vector3(px, py, pz);

        // compute tangent-forward vector (ahead - pos) and make it orthogonal to normal
        const tangentFwd = ahead.clone().sub(centerPos);
        // project tangentFwd onto plane orthogonal to normal
        const proj = normal.clone().multiplyScalar(tangentFwd.dot(normal));
        tangentFwd.sub(proj).normalize();

        // compute right vector
        const right = new THREE.Vector3().crossVectors(tangentFwd, normal).normalize();

        // create rotation matrix columns: right, normal (up), -tangentFwd (forward)
        // three uses column-major with elements mapping to basis vectors
        const m = new THREE.Matrix4();
        m.makeBasis(right, normal.clone().normalize(), tangentFwd.clone().negate());

        const desiredQuat = new THREE.Quaternion().setFromRotationMatrix(m);

        // apply a yaw correction so tank faces forward direction exactly on the tangent plane
        // (optional: blend yaw separately)
        // Smoothly slerp current rotation toward desired rotation
        const rotSmooth = parseFloat(rotSmoothInput.value) || 0.12; // 0.01..1
        t.mesh.quaternion.slerp(desiredQuat, Math.min(1, rotSmooth * delta60));

        // small tilt override: if normal is near vertical, ensure tank stays upright stable
        // (handled by desiredQuat already)
      }

      // --- Camera spring follow (position + velocity) ---
      if(firstId){
        const f = tanks[firstId].mesh;

        // desired camera position relative to the tank (offset in world/shifted coords)
        const desired = new THREE.Vector3(f.position.x + 60, f.position.y + 80, f.position.z + 120);

        // spring parameters
        const k = 60;            // stiffness
        const damping = 12;     // damping
        // convert to mass-spring: a = (k * (target - x) - damping * v) * dt
        // scale to make stable for our dt (dt in seconds)
        const dtSec = dt;
        const displacement = desired.clone().sub(camPos);
        // acceleration:
        const acc = displacement.clone().multiplyScalar(k).sub(camVel.clone().multiplyScalar(damping));
        acc.multiplyScalar(dtSec); // scale by dt
        camVel.add(acc);
        // integrate position
        camPos.add(camVel.clone().multiplyScalar(dtSec));

        camera.position.copy(camPos);
        // look at the followed tank smoothly by interpolating lookAt target too
        const lookTarget = f.position.clone();
        camera.lookAt(lookTarget);
      }

      renderer.render(scene, camera);
    }

    animate();

    // handle resize
    window.addEventListener('resize', ()=>{
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });

    overlay.style.display = 'none';
  }
})();
</script>
</body>
</html>