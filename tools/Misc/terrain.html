<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Balloon + Beamed Electric Animation</title>
    <style>
      body { margin: 0; overflow: hidden; }
      canvas { display: block; }
    </style>
  </head>
  <body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script>
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x101020);

      // Camera
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(10, 5, 10);
      camera.lookAt(0, 0, 0);

      // Renderer
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(10, 20, 10);
      scene.add(directionalLight);

      // Ground plane
      const groundGeom = new THREE.PlaneGeometry(50, 50);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x202020 });
      const ground = new THREE.Mesh(groundGeom, groundMat);
      ground.rotation.x = -Math.PI / 2;
      scene.add(ground);

      // Balloon
      const balloonGeom = new THREE.SphereGeometry(1.5, 32, 32);
      const balloonMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
      const balloon = new THREE.Mesh(balloonGeom, balloonMat);
      balloon.position.y = 10;
      scene.add(balloon);

      // Gondola / payload
      const gondolaGeom = new THREE.BoxGeometry(1, 0.5, 1);
      const gondolaMat = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
      const gondola = new THREE.Mesh(gondolaGeom, gondolaMat);
      gondola.position.y = 8;
      scene.add(gondola);

      // Ground lasers (cylinders)
      const laserCount = 5;
      const lasers = [];
      for (let i = 0; i < laserCount; i++) {
        const laserGeom = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
        const laserMat = new THREE.MeshStandardMaterial({ color: 0x00ffff });
        const laser = new THREE.Mesh(laserGeom, laserMat);
        const angle = (i / laserCount) * Math.PI * 2;
        laser.position.set(5 * Math.cos(angle), 0.5, 5 * Math.sin(angle));
        laser.rotation.z = Math.PI / 2;
        lasers.push(laser);
        scene.add(laser);
      }

      // Laser beams (lines)
      const beams = [];
      for (let i = 0; i < laserCount; i++) {
        const beamMat = new THREE.LineBasicMaterial({ color: 0x00ffff });
        const points = [ new THREE.Vector3(), new THREE.Vector3() ];
        const beamGeom = new THREE.BufferGeometry().setFromPoints(points);
        const beam = new THREE.Line(beamGeom, beamMat);
        beams.push(beam);
        scene.add(beam);
      }

      // Animate
      let clock = new THREE.Clock();
      function animate() {
        requestAnimationFrame(animate);

        const t = clock.getElapsedTime();

        // Gondola oscillates slightly
        gondola.position.x = Math.sin(t) * 0.5;
        gondola.position.z = Math.cos(t) * 0.5;

        // Update beams to point from lasers to gondola
        for (let i = 0; i < laserCount; i++) {
          const positions = beams[i].geometry.attributes.position.array;
          const laserPos = lasers[i].position;
          positions[0] = laserPos.x;
          positions[1] = laserPos.y + 0.5; // top of cylinder
          positions[2] = laserPos.z;
          positions[3] = gondola.position.x;
          positions[4] = gondola.position.y + 0.25;
          positions[5] = gondola.position.z;
          beams[i].geometry.attributes.position.needsUpdate = true;
        }

        // Balloon slowly rotates
        balloon.rotation.y += 0.002;

        // Camera slowly orbits
        const radius = 15;
        camera.position.x = radius * Math.cos(t * 0.1);
        camera.position.z = radius * Math.sin(t * 0.1);
        camera.lookAt(0, 8, 0);

        renderer.render(scene, camera);
      }

      animate();

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>