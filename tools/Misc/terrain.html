<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Full Interactive Terrain Scene</title>
<style>body{margin:0;overflow:hidden;}canvas{display:block;}</style>
</head>
<body>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';

// === Scene & Renderer ===
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 500);
camera.position.set(0,50,80);
let cameraTarget = new THREE.Vector3(0,0,0);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// === Terrain ===
const size = 80, segments = 80;
const terrainGeom = new THREE.PlaneGeometry(size,size,segments,segments);
terrainGeom.rotateX(-Math.PI/2);
terrainGeom.setAttribute('color', new THREE.BufferAttribute(new Float32Array(terrainGeom.attributes.position.count*3),3));
const terrainMat = new THREE.MeshStandardMaterial({vertexColors:true, wireframe:false});
const terrain = new THREE.Mesh(terrainGeom, terrainMat);
scene.add(terrain);

// === Water ===
const waterGeom = new THREE.PlaneGeometry(size,size,segments,segments);
waterGeom.rotateX(-Math.PI/2);
const renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
const waterMat = new THREE.MeshBasicMaterial({map: renderTarget.texture, transparent:true, opacity:0.7});
const water = new THREE.Mesh(waterGeom, waterMat);
water.position.y = 0.1;
scene.add(water);

// === Sky (clouds) ===
const skyGeom = new THREE.SphereGeometry(250, 32, 32);
const skyMat = new THREE.MeshBasicMaterial({color:0x87ceeb, side:THREE.BackSide});
const sky = new THREE.Mesh(skyGeom, skyMat);
scene.add(sky);

// Moving cloud texture (simple procedural via noise-like function)
const cloudGeom = new THREE.PlaneGeometry(500,500,1,1);
const cloudMat = new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.3});
const cloudMesh = new THREE.Mesh(cloudGeom, cloudMat);
cloudMesh.rotation.x = -Math.PI/2;
cloudMesh.position.y = 80;
scene.add(cloudMesh);

// === Lights ===
const light = new THREE.DirectionalLight(0xffffff,1);
light.position.set(50,50,50);
scene.add(light);

// === Offsets ===
const terrainOffsets = Array.from({length:terrainGeom.attributes.position.count}, ()=>Math.random()*2*Math.PI);
const waterOffsets = Array.from({length:waterGeom.attributes.position.count}, ()=>Math.random()*2*Math.PI);

// === Height to color ===
function heightToColor(h){
    if(h<-1) return new THREE.Color(0x004400);
    if(h<1)  return new THREE.Color(0x228B22);
    if(h<3)  return new THREE.Color(0x8B4513);
    return new THREE.Color(0xFFFFFF);
}

// === Camera control ===
let targetX=0, targetZ=0, distance=80;
let rotationY=0, targetRotationY=0;

// === Reflection Camera ===
const reflectCamera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 500);

// === Animation Loop ===
let time=0;
function animate(){
    requestAnimationFrame(animate);
    time += 0.02;

    // Terrain update
    const pos = terrainGeom.attributes.position.array;
    const colors = terrainGeom.attributes.color.array;
    for(let i=0;i<pos.length;i+=3){
        const x = pos[i], z = pos[i+2], o = terrainOffsets[i/3];
        const y = Math.sin(x*0.2 + time + o)*2
                + Math.cos(z*0.15 + time*1.3 + o)*1.5
                + Math.sin((x+z)*0.1 + time*0.7 + o)*1;
        pos[i+1] = y;
        const c = heightToColor(y);
        colors[i]=c.r; colors[i+1]=c.g; colors[i+2]=c.b;
    }
    terrainGeom.attributes.position.needsUpdate=true;
    terrainGeom.attributes.color.needsUpdate=true;

    // Water waves
    const wpos = waterGeom.attributes.position.array;
    for(let i=0;i<wpos.length;i+=3){
        const x = wpos[i], z = wpos[i+2], o = waterOffsets[i/3];
        wpos[i+1] = Math.sin(x*0.3 + time*1.2 + o)*0.3 + Math.cos(z*0.25 + time*1.5 + o)*0.3;
    }
    waterGeom.attributes.position.needsUpdate=true;

    // Clouds drift
    cloudMesh.position.x = Math.sin(time*0.05)*50;
    cloudMesh.position.z = Math.cos(time*0.03)*50;

    // Camera smooth rotation & distance
    rotationY += (targetRotationY - rotationY)*0.05;
    camera.position.x = targetX + Math.sin(rotationY)*distance;
    camera.position.z = targetZ + Math.cos(rotationY)*distance;

    // Camera target smoothly lerps to center
    cameraTarget.lerp(new THREE.Vector3(0,0,0),0.02);
    camera.lookAt(cameraTarget);

    // Reflection camera
    reflectCamera.position.copy(camera.position);
    reflectCamera.position.y *= -1;
    reflectCamera.up.set(0,-1,0);
    reflectCamera.lookAt(new THREE.Vector3(cameraTarget.x, -cameraTarget.y, cameraTarget.z));

    renderer.setRenderTarget(renderTarget);
    renderer.render(scene, reflectCamera);
    renderer.setRenderTarget(null);

    // Render main scene
    renderer.render(scene, camera);
}
animate();

// === Device Orientation ===
window.addEventListener('deviceorientation', e=>{
    const gamma = e.gamma||0, beta = e.beta||0;
    targetX = gamma*0.5;
    targetZ = -beta*0.5;
}, true);

// === Mouse drag rotation ===
let isDragging=false, prevX=0;
window.addEventListener('mousedown', e=>{ isDragging=true; prevX=e.clientX; });
window.addEventListener('mouseup', ()=>isDragging=false);
window.addEventListener('mousemove', e=>{
    if(isDragging){ 
        const dx = e.clientX-prevX; 
        targetRotationY += dx*0.005; 
        prevX = e.clientX;
    }
});

// === Touch gestures ===
let touchDistance=0;
window.addEventListener('touchstart', e=>{
    if(e.touches.length === 2){
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        touchDistance = Math.sqrt(dx*dx + dy*dy);
    }
}, false);
window.addEventListener('touchmove', e=>{
    if(e.touches.length===1){
        const dx = e.touches[0].clientX - prevX;
        targetRotationY += dx*0.005;
        prevX = e.touches[0].clientX;
    } else if(e.touches.length===2){
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const newDistance = Math.sqrt(dx*dx + dy*dy);
        const delta = newDistance - touchDistance;
        distance -= delta*0.1;
        distance = Math.max(20,Math.min(150,distance));
        touchDistance = newDistance;
    }
}, false);

// === Resize ===
window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    reflectCamera.aspect = window.innerWidth/window.innerHeight;
    reflectCamera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>