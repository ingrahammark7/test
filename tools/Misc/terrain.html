<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Full Atomic Simulation</title>
<style>body{margin:0;overflow:hidden;}canvas{display:block;}</style>
</head>
<body>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';

// === Scene & Camera ===
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,20,50);
let cameraTarget = new THREE.Vector3(0,0,0);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// === Lights ===
scene.add(new THREE.DirectionalLight(0xffffff,1).position.set(50,50,50));
scene.add(new THREE.AmbientLight(0x555555));

// === Nucleon Class ===
class Nucleon {
    constructor(){
        const geom = new THREE.SphereGeometry(0.5,8,8);
        const mat = new THREE.MeshStandardMaterial({color:0xff4444});
        this.mesh = new THREE.Mesh(geom, mat);
        this.mesh.position.set((Math.random()-0.5)*20, (Math.random()-0.5)*20, (Math.random()-0.5)*20);
        this.velocity = new THREE.Vector3((Math.random()-0.5)*2,(Math.random()-0.5)*2,(Math.random()-0.5)*2);
        this.energy = Math.random();
        this.cluster = null;

        // Trail
        const trailGeom = new THREE.BufferGeometry();
        const positions = new Float32Array(50*3);
        trailGeom.setAttribute('position', new THREE.BufferAttribute(positions,3));
        const trailMat = new THREE.LineBasicMaterial({color:0xffff44, transparent:true, opacity:0.6});
        this.trail = new THREE.Line(trailGeom, trailMat);
        scene.add(this.mesh);
        scene.add(this.trail);
    }
    update(delta, boxSize){
        if(!this.cluster){
            this.mesh.position.addScaledVector(this.velocity, delta);
            ['x','y','z'].forEach(axis=>{
                if(this.mesh.position[axis]>boxSize){ this.mesh.position[axis]=boxSize; this.velocity[axis]*=-0.8; }
                if(this.mesh.position[axis]<-boxSize){ this.mesh.position[axis]=-boxSize; this.velocity[axis]*=-0.8; }
            });
        } else {
            this.mesh.position.copy(this.cluster.center);
        }
        // Trail update
        const positions = this.trail.geometry.attributes.position.array;
        positions.copyWithin(0,3);
        positions[positions.length-3] = this.mesh.position.x;
        positions[positions.length-2] = this.mesh.position.y;
        positions[positions.length-1] = this.mesh.position.z;
        this.trail.geometry.attributes.position.needsUpdate = true;

        // Spin for visual energy
        const angle = performance.now()*0.001*this.energy*5;
        this.mesh.rotation.x = angle;
        this.mesh.rotation.y = angle*0.7;
    }
}

// === Atom Class ===
class Atom {
    constructor(nucleons){
        this.nucleons = nucleons;
        this.center = new THREE.Vector3();
        nucleons.forEach(n=>{ n.cluster=this; });
        this.updateCenter();

        this.mesh = new THREE.Mesh(
            new THREE.SphereGeometry(this.nucleons.length*0.6,16,16),
            new THREE.MeshBasicMaterial({color:0x44ff44, transparent:true, opacity:0.3})
        );
        scene.add(this.mesh);

        // Wave propagation
        this.waveGeom = new THREE.SphereGeometry(this.nucleons.length*0.6,8,8);
        this.waveMat = new THREE.MeshBasicMaterial({color:0x00ffff, transparent:true, opacity:0.1});
        this.waveMesh = new THREE.Mesh(this.waveGeom, this.waveMat);
        this.waveScale = 1;
        scene.add(this.waveMesh);
    }
    update(){
        this.center.set(0,0,0);
        this.nucleons.forEach(n=>this.center.add(n.mesh.position));
        this.center.divideScalar(this.nucleons.length);
        this.mesh.position.copy(this.center);

        const avgEnergy = this.nucleons.reduce((a,b)=>a+b.energy,0)/this.nucleons.length;
        this.mesh.material.opacity = 0.2+0.3*avgEnergy;
        this.mesh.scale.setScalar(1+0.3*avgEnergy);

        // Wave propagation
        this.waveScale += 0.2;
        this.waveMesh.scale.setScalar(this.waveScale);
        this.waveMesh.position.copy(this.center);
        this.waveMat.opacity = Math.max(0, 0.2 - (this.waveScale-1)*0.05);
        if(this.waveMat.opacity<=0){ this.waveScale=1; }
    }
}

// === Electron Class ===
class Electron {
    constructor(){
        const geom = new THREE.SphereGeometry(0.2,6,6);
        const mat = new THREE.MeshBasicMaterial({color:0x4444ff});
        this.mesh = new THREE.Mesh(geom, mat);
        this.mesh.position.set((Math.random()-0.5)*20, (Math.random()-0.5)*20, (Math.random()-0.5)*20);
        this.velocity = new THREE.Vector3((Math.random()-0.5)*4,(Math.random()-0.5)*4,(Math.random()-0.5)*4);
        scene.add(this.mesh);
    }
    update(delta, boxSize){
        this.mesh.position.addScaledVector(this.velocity, delta);
        ['x','y','z'].forEach(axis=>{
            if(this.mesh.position[axis]>boxSize){ this.mesh.position[axis]=boxSize; this.velocity[axis]*=-1; }
            if(this.mesh.position[axis]<-boxSize){ this.mesh.position[axis]=-boxSize; this.velocity[axis]*=-1; }
        });
    }
}

// === Setup particles ===
const nucleons = Array.from({length:100},()=>new Nucleon());
const electrons = Array.from({length:20},()=>new Electron());
const atoms = [];

// === Detect Atom Formation ===
function detectAtoms(){
    const threshold = 2.0;
    nucleons.forEach(n1=>{
        if(n1.cluster) return;
        nucleons.forEach(n2=>{
            if(n1===n2 || n2.cluster) return;
            if(n1.mesh.position.distanceTo(n2.mesh.position)<threshold){
                atoms.push(new Atom([n1,n2]));
            }
        });
    });
}

// === Electron Collisions ===
function electronCollisions(){
    const energyTransfer = 2.0;
    electrons.forEach(e=>{
        nucleons.forEach(n=>{
            if(e.mesh.position.distanceTo(n.mesh.position)<0.5){
                const push = e.velocity.clone().multiplyScalar(energyTransfer);
                if(!n.cluster) n.velocity.add(push);
                nucleons.forEach(nn=>{
                    if(nn!==n && nn.mesh.position.distanceTo(n.mesh.position)<1.5){
                        nn.velocity.add(push.clone().multiplyScalar(0.5));
                    }
                });
            }
        });
    });
}

// === Camera Focus ===
let focusTimer = 0;
let focusAtom = null;
function updateCameraFocus(delta){
    focusTimer -= delta;
    if(focusTimer <=0){
        focusTimer = 2 + Math.random()*3;
        if(atoms.length>0) focusAtom = atoms[Math.floor(Math.random()*atoms.length)];
    }
    if(focusAtom){
        cameraTarget.lerp(focusAtom.center, 0.02);
    } else {
        cameraTarget.lerp(new THREE.Vector3(0,0,0),0.02);
    }
}

// === Camera Controls ===
let targetX=0, targetZ=0, distance=50, rotationY=0, targetRotationY=0;
window.addEventListener('deviceorientation', e=>{
    targetX = (e.gamma||0)*0.5;
    targetZ = -(e.beta||0)*0.5;
}, true);
let isDragging=false, prevX=0;
window.addEventListener('mousedown', e=>{isDragging=true; prevX=e.clientX;});
window.addEventListener('mouseup', ()=>isDragging=false);
window.addEventListener('mousemove', e=>{
    if(isDragging){ const dx=e.clientX-prevX; targetRotationY+=dx*0.005; prevX=e.clientX; }
});

// === Touch gestures ===
let touchDistance=0;
window.addEventListener('touchstart', e=>{
    if(e.touches.length === 2){
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        touchDistance = Math.sqrt(dx*dx + dy*dy);
    }
}, false);
window.addEventListener('touchmove', e=>{
    if(e.touches.length===1){
        const dx = e.touches[0].clientX - prevX;
        targetRotationY += dx*0.005;
        prevX = e.touches[0].clientX;
    } else if(e.touches.length===2){
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const newDistance = Math.sqrt(dx*dx + dy*dy);
        const delta = newDistance - touchDistance;
        distance -= delta*0.1;
        distance = Math.max(20,Math.min(200,distance));
        touchDistance = newDistance;
    }
}, false);

// === Animation Loop ===
let lastTime = performance.now();
const boxSize = 30;
function animate(){
    requestAnimationFrame(animate);
    const now = performance.now();
    const delta = (now-lastTime)/1000;
    lastTime = now;

    nucleons.forEach(n=>n.update(delta, boxSize));
    electrons.forEach(e=>e.update(delta, boxSize));
    atoms.forEach(a=>a.update());

    detectAtoms();
    electronCollisions();
    updateCameraFocus(delta);

    // Smooth camera rotation & position
    rotationY += (targetRotationY - rotationY)*0.05;
    camera.position.x = targetX + Math.sin(rotationY)*distance;
    camera.position.z = targetZ + Math.cos(rotationY)*distance;
    camera.position.y = 20;
    camera.lookAt(cameraTarget);

    renderer.render(scene,camera);
}

animate();

// === Window Resize ===
window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>