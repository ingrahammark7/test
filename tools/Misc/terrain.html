<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Tank on Terrain — Smooth Movement + Shots</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html, body { height: 100%; margin: 0; overflow: hidden; }
  canvas { display: block; }
  #overlay {
    position: fixed; right: 8px; top: 8px;
    width: 320px; background: rgba(0,0,0,0.6);
    color: #fff; font-family: monospace;
    font-size: 12px; padding: 8px; border-radius: 6px;
    z-index: 20;
  }
  #controls {
    position: fixed; left: 8px; top: 8px;
    background: rgba(0,0,0,0.6);
    color: #fff;
    padding: 6px;
    border-radius: 6px;
    font-family: monospace;
    font-size: 12px;
    z-index: 20;
  }
  #controls input { vertical-align: middle; }
</style>
</head>
<body>
<div id="controls">
  Speed: <input type="range" id="speedSlider" min="0.1" max="10" step="0.1" value="1">
  <span id="speedVal">1</span>
  &nbsp; | &nbsp;
  Rotation smooth: <input id="rotSmooth" type="range" min="0.01" max="1" step="0.01" value="0.12">
  &nbsp; | &nbsp;
  Tilt blend: <input id="tiltBlend" type="range" min="0" max="1" step="0.01" value="0.5">
  <span id="tiltVal">0.50</span>
</div>
<div id="overlay">Loading files…</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
<script>
(async function(){
  const overlay = document.getElementById('overlay');

  try {
    const [terrainResp, movesResp, shotsResp] = await Promise.all([
      fetch('f.json'),
      fetch('f2.json'),
      fetch('f3.json')
    ]);
    if(!terrainResp.ok) throw new Error('Failed loading f.json');
    if(!movesResp.ok) throw new Error('Failed loading f2.json');
    if(!shotsResp.ok) throw new Error('Failed loading f3.json');

    const terrainData = await terrainResp.json();
    const movesText = await movesResp.text();
    const shotsText = await shotsResp.text();
    overlay.innerText = 'Files loaded — building scene...';
    buildScene(terrainData, movesText, shotsText);
  } catch(err) {
    overlay.innerText = 'Error loading files: ' + err;
    console.error(err);
  }

  function buildScene(terrainData, movesText, shotsText){
    const DEFAULT_TILT_BLEND = 0.5;

    // Terrain keys
    const xKeys = Object.keys(terrainData).map(Number).sort((a,b)=>a-b);
    const zSet = new Set();
    xKeys.forEach(x => {
      Object.keys(terrainData[String(x)]||{}).forEach(z => zSet.add(Number(z)));
    });
    const zKeys = Array.from(zSet).sort((a,b)=>a-b);
    const minX = xKeys[0], maxX = xKeys[xKeys.length-1];
    const minZ = zKeys[0], maxZ = zKeys[zKeys.length-1];
    const centerX = (minX + maxX)/2;
    const centerZ = (minZ + maxZ)/2;
    const terrainWidth = maxX - minX;
    const terrainDepth = maxZ - minZ;

    function findNearestIndex(sorted, v){
      let lo=0, hi=sorted.length-1;
      if(v<=sorted[0]) return 0;
      if(v>=sorted[hi]) return hi;
      while(lo<=hi){
        const mid=(lo+hi)>>1;
        if(sorted[mid]===v) return mid;
        if(sorted[mid]<v) lo=mid+1; else hi=mid-1;
      }
      const a=Math.max(0,lo-1), b=Math.min(sorted.length-1,lo);
      return Math.abs(sorted[a]-v)<=Math.abs(sorted[b]-v)?a:b;
    }

    function heightAtIndex(ix, iz){
      const x=xKeys[ix], z=zKeys[iz];
      return terrainData[String(x)]?.[String(z)]||0;
    }

    // Terrain geometry
    const cols=xKeys.length, rows=zKeys.length;
    const geom = new THREE.BufferGeometry();
    const pos = new Float32Array(cols*rows*3);
    let pi=0;
    for(let i=0;i<rows;i++){
      for(let j=0;j<cols;j++){
        const worldX = xKeys[j], worldZ=zKeys[i];
        const h = terrainData[String(worldX)]?.[String(worldZ)]||0;
        pos[pi++] = worldX; pos[pi++] = h; pos[pi++] = worldZ;
      }
    }
    geom.setAttribute('position', new THREE.BufferAttribute(pos,3));
    const idxs=[];
    for(let i=0;i<rows-1;i++){
      for(let j=0;j<cols-1;j++){
        const a=i*cols+j, b=a+1, c=a+cols, d=c+1;
        idxs.push(a,c,b,b,c,d);
      }
    }
    geom.setIndex(idxs);
    geom.computeVertexNormals();
    const mat=new THREE.MeshStandardMaterial({color:0x228B22, flatShading:true});
    const terrainMesh=new THREE.Mesh(geom, mat);
    terrainMesh.position.set(-centerX,0,-centerZ);

    const scene=new THREE.Scene();
    scene.background=new THREE.Color(0x87ceeb);
    scene.add(terrainMesh);
    const dir=new THREE.DirectionalLight(0xffffff,1);
    dir.position.set(centerX+200,400,centerZ+200);
    scene.add(dir);
    scene.add(new THREE.AmbientLight(0x404040));

    const renderer=new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio||1);
    renderer.setSize(window.innerWidth,window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const camera=new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,5000);

    // Parse tanks
    const rawMoves = movesText.split('|').filter(s=>s.trim());
    const tanks = {};
    rawMoves.forEach(token=>{
      const m = token.trim();
      const match=m.match(/(-?\d+)\s*,\s*(-?\d+)\s*$/);
      if(!match) return;
      const id = m.split(' ')[0], x=Number(match[1]), z=Number(match[2]);
      if(!tanks[id]) tanks[id]={path:[]};
      tanks[id].path.push([x,z]);
    });

    const colors=[0xff0000,0x0000ff,0xffff00,0xff00ff,0x00ffff,0xff8800];
    let colorIdx=0;
    for(const id in tanks){
      const t=tanks[id];
      const geo=new THREE.BoxGeometry(6,4,6);
      const matTank = new THREE.MeshStandardMaterial({color:colors[colorIdx++%colors.length]});
      const mesh=new THREE.Mesh(geo,matTank);
      const firstWp=t.path[0];
      mesh.position.set(firstWp[0]-centerX, heightAtIndex(findNearestIndex(xKeys,firstWp[0]),findNearestIndex(zKeys,firstWp[1]))+2, firstWp[1]-centerZ);
      scene.add(mesh);
      t.mesh=mesh;
      t.currentIndex=0;
      t.progress=0;
    }

    // Parse shots
    const shotsRaw = shotsText.split('|').filter(s=>s.trim());
    shotsRaw.forEach(s=>{
      const nums = s.split(',').map(Number);
      if(nums.length!==4) return;
      const [x1,z1,x2,z2] = nums;
      const p1 = new THREE.Vector3(x1-centerX,heightAtIndex(findNearestIndex(xKeys,x1),findNearestIndex(zKeys,z1))+1,z1-centerZ);
      const p2 = new THREE.Vector3(x2-centerX,heightAtIndex(findNearestIndex(xKeys,x2),findNearestIndex(zKeys,z2))+1,z2-centerZ);
      const geom = new THREE.BufferGeometry().setFromPoints([p1,p2]);
      const mat = new THREE.LineBasicMaterial({color:0xffffff});
      scene.add(new THREE.Line(geom,mat));
    });

    // Auto-zoom: camera distance based on terrain size
    const diag = Math.sqrt(terrainWidth*terrainWidth + terrainDepth*terrainDepth);
    const cameraHeight = diag * 0.6; // adjust factor for good view
    const cameraOffset = new THREE.Vector3(0, cameraHeight, cameraHeight);
    const camPos = new THREE.Vector3().copy(cameraOffset);
    const camVel = new THREE.Vector3();
    camera.position.copy(camPos);
    camera.lookAt(new THREE.Vector3(0,0,0));

    // UI
    let speed=1;
    document.getElementById('speedSlider').addEventListener('input', e=>{
      speed=parseFloat(e.target.value);
      document.getElementById('speedVal').innerText=speed.toFixed(1);
    });
    const rotSmoothInput = document.getElementById('rotSmooth');
    const tiltBlendInput = document.getElementById('tiltBlend');
    const tiltValSpan = document.getElementById('tiltVal');
    tiltBlendInput.addEventListener('input', ()=>{tiltValSpan.innerText=parseFloat(tiltBlendInput.value).toFixed(2);});

    function animate(){
      requestAnimationFrame(animate);
      const dt = 1/60;

      for(const id in tanks){
        const t=tanks[id];
        if(!t.path||t.path.length<2) continue;
        let rem = speed*dt*60;
        while(rem>0 && t.currentIndex<t.path.length-1){
          const cur = t.path[t.currentIndex], nxt = t.path[t.currentIndex+1];
          const dx = nxt[0]-cur[0], dz=nxt[1]-cur[1];
          const segLen = Math.hypot(dx,dz)||0.001;
          const left = segLen*(1-t.progress);
          if(rem>=left){ rem-=left; t.currentIndex++; t.progress=0;}
          else {t.progress+=rem/segLen; rem=0;}
        }
        const cur = t.path[t.currentIndex], nxt = t.path[Math.min(t.currentIndex+1,t.path.length-1)];
        const px = THREE.MathUtils.lerp(cur[0],nxt[0],t.progress)-centerX;
        const pz = THREE.MathUtils.lerp(cur[1],nxt[1],t.progress)-centerZ;
        const py = heightAtIndex(findNearestIndex(xKeys,px+centerX),findNearestIndex(zKeys,pz+centerZ))+2;
        t.mesh.position.set(px,py,pz);
      }

      renderer.render(scene,camera);
    }
    animate();

    window.addEventListener('resize',()=>{
      renderer.setSize(window.innerWidth,window.innerHeight);
      camera.aspect=window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
    });

    overlay.style.display='none';
  }
})();
</script>
</body>
</html>