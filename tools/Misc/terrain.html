<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Atomic Slidey-Gooey Simulation with Waves</title>
<style>body{margin:0;overflow:hidden;}canvas{display:block;}</style>
</head>
<body>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';

// === Scene & Renderer ===
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 500);
camera.position.set(0,50,80);
let cameraTarget = new THREE.Vector3(0,0,0);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// === Lights ===
const light = new THREE.DirectionalLight(0xffffff,1.2);
light.position.set(50,50,50);
scene.add(light);
scene.add(new THREE.AmbientLight(0x404040,0.5));

// === Atom parameters ===
const NUM_ATOMS = 100;
const BOX_SIZE = 50;
const atomGeom = new THREE.SphereGeometry(0.5,6,6);
const atoms = [];
const trails = [];

for(let i=0;i<NUM_ATOMS;i++){
    const atomMat = new THREE.MeshStandardMaterial({color:0xffaa00, transparent:true, opacity:0.8});
    const mesh = new THREE.Mesh(atomGeom, atomMat);
    mesh.position.set(
        (Math.random()-0.5)*BOX_SIZE,
        (Math.random()-0.5)*BOX_SIZE,
        (Math.random()-0.5)*BOX_SIZE
    );
    mesh.userData = {
        velocity: new THREE.Vector3(
            (Math.random()-0.5)*0.5,
            (Math.random()-0.5)*0.5,
            (Math.random()-0.5)*0.5
        ),
        strong: 1,
        em: 1,
        ionized: false
    };
    scene.add(mesh);
    atoms.push(mesh);

    // Trail setup
    const trailGeom = new THREE.BufferGeometry().setFromPoints([mesh.position.clone()]);
    const trailMat = new THREE.LineBasicMaterial({color:0xffaa00, transparent:true, opacity:0.2});
    const line = new THREE.Line(trailGeom, trailMat);
    scene.add(line);
    trails.push({mesh,line,points:[mesh.position.clone()]});
}

// === Contagion parameters ===
const CONTAGION_DISTANCE = 2.0;

// === Wave parameters (pseudo Perlin using sin/cos) ===
function waveForce(pos,time){
    return new THREE.Vector3(
        Math.sin(pos.x*0.2 + time*0.5)*0.05,
        Math.cos(pos.y*0.15 + time*0.7)*0.05,
        Math.sin((pos.x+pos.z)*0.1 + time*0.3)*0.05
    );
}

// === Animation Loop ===
let time=0;
function animate(){
    requestAnimationFrame(animate);
    time += 0.02;

    // Atom physics
    for(let i=0;i<NUM_ATOMS;i++){
        const a = atoms[i];
        let force = new THREE.Vector3();

        // EM repulsion and spin/spiral motion
        for(let j=0;j<NUM_ATOMS;j++){
            if(i===j) continue;
            const b = atoms[j];
            const dir = new THREE.Vector3().subVectors(a.position,b.position);
            const dist = dir.length();
            if(dist<0.01) continue;
            dir.normalize();
            let emForce = (a.userData.em*b.userData.em)/(dist*dist);

            // Contagion: ionized neighbor
            if(b.userData.ionized && dist<CONTAGION_DISTANCE){
                a.userData.strong *= 0.98;
                a.userData.ionized = true;
                emForce *= 1.5;
                a.material.color.set(0xff4444);
            }

            // Spin/spiral perturbation
            const spin = new THREE.Vector3(-dir.z,0,dir.x).multiplyScalar(0.05);
            force.add(dir.multiplyScalar(emForce)).add(spin);
        }

        // Strong force pulls back to box center
        ['x','y','z'].forEach(axis=>{
            const margin = BOX_SIZE/2;
            if(a.position[axis]>margin) force[axis]-=(a.position[axis]-margin)*0.05*a.userData.strong;
            if(a.position[axis]<-margin) force[axis]-=(a.position[axis]+margin)*0.05*a.userData.strong;
        });

        // Add pseudo-wave propagation
        force.add(waveForce(a.position,time));

        a.userData.velocity.add(force.multiplyScalar(0.01));
        a.position.add(a.userData.velocity);

        // Update trails (fade older points)
        const trail = trails[i];
        trail.points.push(a.position.clone());
        if(trail.points.length>30) trail.points.shift();
        trail.line.geometry.setFromPoints(trail.points);
        trail.line.material.opacity = 0.2 + 0.3*(a.userData.ionized?1:0);
    }

    // Camera subtle movement
    camera.position.set(0,50,80);
    camera.lookAt(cameraTarget);

    renderer.render(scene, camera);
}
animate();

// === Accelerometer control ===
window.addEventListener('deviceorientation', e=>{
    const tiltX = (e.gamma||0)/90;
    const tiltZ = (e.beta||0)/180;
    camera.position.x = tiltX*10;
    camera.position.z = 80 + tiltZ*10;
    camera.lookAt(cameraTarget);
}, true);

// === Resize ===
window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>