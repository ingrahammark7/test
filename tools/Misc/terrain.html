<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Maximal Three.js Soviet Air Combat Simulator</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; font-family: monospace; color: white; }
  #ui {
    position: absolute; top: 10px; left: 10px; width: 350px;
    background: rgba(0,0,0,0.7); padding: 10px; border-radius: 8px;
    font-size: 14px; line-height: 1.3;
    user-select: none;
  }
  #fps {
    position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7);
    padding: 5px 8px; border-radius: 5px; font-family: monospace; font-size: 12px;
  }
</style>
</head>
<body>
<div id="ui">
  <b>Mission Briefing:</b><br>
  Soviet intercept mission, 1980.<br>
  Enemy bombers & fighters inbound.<br>
  Protect ground targets & survive SAM fire.<br><br>
  <b>Camera Focus:</b> <span id="focusText">Waiting for engagements...</span><br>
  <b>Active Sorties:</b> <span id="activeSorties">0</span><br>
  <b>Weapons Fired:</b> <span id="weaponsFired">0</span><br>
  <b>Enemies Remaining:</b> <span id="enemiesRemaining">0</span><br>
  <b>Ground Targets Remaining:</b> <span id="groundRemaining">0</span>
</div>
<div id="fps">FPS: 0</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>

<script>
// ==== GLOBALS ====

const clock = new THREE.Clock();

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x001020);

const camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 0.1, 1500);
camera.position.set(0, 100, 200);

const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const ui = {
  focusText: document.getElementById('focusText'),
  activeSorties: document.getElementById('activeSorties'),
  weaponsFired: document.getElementById('weaponsFired'),
  enemiesRemaining: document.getElementById('enemiesRemaining'),
  groundRemaining: document.getElementById('groundRemaining'),
  fps: document.getElementById('fps'),
};

// ==== LIGHTS ====

const hemiLight = new THREE.HemisphereLight(0xb0c4de, 0x202040, 1.0);
hemiLight.position.set(0, 200, 0);
scene.add(hemiLight);

const dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(100, 250, 100);
dirLight.castShadow = true;
scene.add(dirLight);

// ==== TERRAIN ====

const terrainGeo = new THREE.PlaneGeometry(1000, 1000, 100, 100);
terrainGeo.rotateX(-Math.PI / 2);

// Simple heightmap: gentle hills and valleys
for (let i=0; i<terrainGeo.attributes.position.count; i++) {
  const y = Math.sin(i*0.1)*5 + Math.cos(i*0.3)*3;
  terrainGeo.attributes.position.setY(i, y);
}
terrainGeo.computeVertexNormals();

const terrainMat = new THREE.MeshStandardMaterial({color: 0x228833, flatShading: false});
const terrain = new THREE.Mesh(terrainGeo, terrainMat);
terrain.receiveShadow = true;
scene.add(terrain);

// ==== UTILS ====

function degToRad(deg) { return deg * Math.PI / 180; }
function radToDeg(rad) { return rad * 180 / Math.PI; }
function clamp(val, min, max) { return Math.min(max, Math.max(min, val)); }
function angleDiff(a,b) {
  let d = a - b;
  while(d > 180) d -= 360;
  while(d < -180) d += 360;
  return d;
}
function lerp(a,b,t) { return a + (b - a)*t; }

// ==== AIRCRAFT BASE CLASS ====

class Aircraft {
  constructor(name, pos, headingDeg, speedKph, color=0xffffff) {
    this.name = name;
    this.position = pos.clone();
    this.heading = headingDeg; // degrees, 0 east
    this.speed = speedKph;
    this.alive = true;
    this.engaged = false;
    this.lastEngagedTime = 0;
    this.fuel = 10000; // kg
    this.weaponsFired = 0;
    this.evasive = false;
    this.evasiveTimer = 0;
    this.rcs = 1; // Radar cross section for detection
    this.isEnemy = false;

    this.mesh = this.createMesh(color);
    this.mesh.position.copy(this.position);
    scene.add(this.mesh);

    this.radar = {
      maxRangeKm: 50,
      baseDetectProb: 0.8,
      jamming: 0.0,
    };
  }

  createMesh(color) {
    const geometry = new THREE.ConeGeometry(1, 4, 8);
    const material = new THREE.MeshStandardMaterial({color});
    const mesh = new THREE.Mesh(geometry, material);
    mesh.castShadow = true;
    mesh.rotation.x = Math.PI / 2;
    return mesh;
  }

  update(delta, time) {
    if (!this.alive) return;

    if (this.fuel <= 0) {
      this.speed = 0;
      this.alive = false;
      console.log(`${this.name} out of fuel and lost`);
      return;
    }

    let burnRate = this.evasive ? 60 : 40;
    this.fuel -= burnRate * delta;
    if (this.fuel < 0) this.fuel = 0;

    let rad = degToRad(this.heading);
    let dist = (this.speed * delta) / 3600;
    this.position.x += Math.cos(rad) * dist;
    this.position.z += Math.sin(rad) * dist;

    this.mesh.position.copy(this.position);
    this.mesh.rotation.y = -rad;

    if (this.evasive) {
      this.evasiveTimer -= delta;
      if (this.evasiveTimer <= 0) this.evasive = false;
    }
  }

  distanceTo(other) {
    return this.position.distanceTo(other.position);
  }

  detectTarget(target) {
    if (!target.alive) return false;
    const dist = this.distanceTo(target);
    if (dist > this.radar.maxRangeKm) return false;

    let detectProb = this.radar.baseDetectProb * (1 - dist / this.radar.maxRangeKm);
    detectProb *= (target.rcs / 5.0);
    detectProb *= (1 - this.radar.jamming);
    detectProb = clamp(detectProb, 0, 1);

    return Math.random() < detectProb;
  }

  receiveGCICommand(target) {
    if (Math.random() < 0.1) {
      console.log(`${this.name} GCI command disrupted by ECM`);
      return false;
    }
    this.heading = radToDeg(Math.atan2(target.position.z - this.position.z, target.position.x - this.position.x));
    return true;
  }

  launchWeapons(target) { return false; }

  takeHit() {
    this.alive = false;
    console.log(`${this.name} destroyed!`);
  }
}

// ==== MiG-25 (Missiles + Evasive) ====

class MiG25 extends Aircraft {
  constructor(name, pos, heading) {
    super(name, pos, heading, 1500, 0x0044cc);
    this.maxFireRangeKm = 20;
    this.currentMissile = null;
    this.fuel = 18000;
  }

  createMesh() {
    const group = new THREE.Group();

    const body = new THREE.CylinderGeometry(0.25, 0.25, 3, 10);
    const mat = new THREE.MeshStandardMaterial({color: 0x0044cc});
    const fuselage = new THREE.Mesh(body, mat);
    fuselage.rotation.z = Math.PI / 2;
    group.add(fuselage);

    const wingGeom = new THREE.BoxGeometry(2.5, 0.1, 0.6);
    const wing = new THREE.Mesh(wingGeom, mat);
    group.add(wing);

    group.castShadow = true;
    return group;
  }

  update(delta, time) {
    super.update(delta, time);

    if (this.currentMissile && this.currentMissile.alive) {
      this.currentMissile.update(delta);
      if (!this.currentMissile.alive) this.currentMissile = null;
    }
  }

  launchWeapons(target) {
    if (!target.alive) return false;
    if (this.currentMissile && this.currentMissile.alive) return false;

    const dist = this.distanceTo(target);
    if (dist > this.maxFireRangeKm) return false;

    this.weaponsFired++;
    this.fuel -= 500;

    this.currentMissile = new Missile(this, target);
    console.log(`${this.name} launched missile at ${target.name}`);
    this.evasive = true;
    this.evasiveTimer = 5;

    return true;
  }
}

// ==== Missile ====

class Missile {
  constructor(launcher, target) {
    this.launcher = launcher;
    this.target = target;
    this.position = launcher.position.clone();
    this.speed = 3000; // km/h
    this.heading = launcher.heading;
    this.alive = true;

    this.mesh = this.createMesh();
    scene.add(this.mesh);
  }

  createMesh() {
    const geom = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 6);
    const mat = new THREE.MeshStandardMaterial({color: 0xffaa00});
    const mesh = new THREE.Mesh(geom, mat);
    mesh.rotation.z = Math.PI / 2;
    mesh.castShadow = true;
    return mesh;
  }

  update(delta) {
    if (!this.alive || !this.target.alive) {
      this.alive = false;
      scene.remove(this.mesh);
      return;
    }

    const desiredHeading = radToDeg(Math.atan2(this.target.position.z - this.position.z, this.target.position.x - this.position.x));
    let diff = angleDiff(desiredHeading, this.heading);
    const maxTurn = 20 * delta;
    if (Math.abs(diff) > maxTurn) diff = maxTurn * Math.sign(diff);
    this.heading = (this.heading + diff + 360) % 360;

    const rad = degToRad(this.heading);
    const dist = (this.speed * delta) / 3600;
    this.position.x += Math.cos(rad) * dist;
    this.position.z += Math.sin(rad) * dist;

    this.mesh.position.copy(this.position);
    this.mesh.rotation.y = -rad;

    if (this.position.distanceTo(this.target.position) < 0.2) {
      if (Math.random() < 0.8) {
        console.log(`Missile hit! ${this.target.name} destroyed.`);
        this.target.takeHit();
      } else {
        console.log(`Missile missed ${this.target.name}.`);
      }
      this.alive = false;
      scene.remove(this.mesh);
    }
  }
}

// ==== MiG-23 (Guns + GCI) ====

class MiG23 extends Aircraft {
  constructor(name, pos, heading) {
    super(name, pos, heading, 1200, 0x003399);
    this.gunRangeKm = 2;
    this.gunCooldown = 0;
  }

  createMesh() {
    const group = new THREE.Group();

    const body = new THREE.CylinderGeometry(0.2, 0.2, 2.5, 8);
    const mat = new THREE.MeshStandardMaterial({color: 0x003399});
    const fuselage = new THREE.Mesh(body, mat);
    fuselage.rotation.z = Math.PI / 2;
    group.add(fuselage);

    const wingGeom = new THREE.BoxGeometry(1.5, 0.1, 0.5);
    const wing = new THREE.Mesh(wingGeom, mat);
    group.add(wing);

    group.castShadow = true;
    return group;
  }

  update(delta, time) {
    super.update(delta, time);
    if (this.gunCooldown > 0) this.gunCooldown -= delta;
  }

  launchWeapons(target) {
    if (!target.alive) return false;
    const dist = this.distanceTo(target);
    if (dist > this.gunRangeKm) return false;
    if (this.gunCooldown > 0) return false;

    this.weaponsFired++;
    this.gunCooldown = 1; // 1 sec cooldown
    this.fuel -= 100;

    if (Math.random() < 0.7) {
      console.log(`${this.name} gun hit! ${target.name} damaged.`);
      target.takeHit();
    } else {
      console.log(`${this.name} gun missed ${target.name}.`);
    }
    return true;
  }
}

// ==== SAM Site (Ground Target) ====

class SAMSite {
  constructor(pos) {
    this.position = pos.clone();
    this.alive = true;
    this.cooldown = 0;
    this.mesh = this.createMesh();
    scene.add(this.mesh);
  }

  createMesh() {
    const geometry = new THREE.BoxGeometry(3, 1.5, 3);
    const material = new THREE.MeshStandardMaterial({color: 0x880000});
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.copy(this.position);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    return mesh;
  }

  update(delta, aircraftList) {
    if (!this.alive) return;
    if (this.cooldown > 0) {
      this.cooldown -= delta;
      return;
    }

    // Find closest enemy aircraft
    let targets = aircraftList.filter(a => a.alive && !a.isEnemy);
    if (targets.length === 0) return;

    targets.sort((a,b) => this.position.distanceTo(a.position) - this.position.distanceTo(b.position));
    let target = targets[0];

    const dist = this.position.distanceTo(target.position);
    if (dist < 10) {
      this.cooldown = 5; // 5 sec reload
      // 50% hit chance
      if (Math.random() < 0.5) {
        console.log(`SAM site hit ${target.name}!`);
        target.takeHit();
      } else {
        console.log(`SAM site missed ${target.name}.`);
      }
    }
  }
}

// ==== SIMULATION SETUP ====

const aircraftList = [];
const samSites = [];

function spawnAircraft() {
  // Soviet side (player)
  aircraftList.push(new MiG25("MiG-25 #1", new THREE.Vector3(-30,5,-30), 45));
  aircraftList.push(new MiG23("MiG-23 #1", new THREE.Vector3(-40,5,-20), 50));
  aircraftList[0].isEnemy = false;
  aircraftList[1].isEnemy = false;

  // Enemy side
  aircraftList.push(new MiG23("Flogger #1", new THREE.Vector3(30,5,30), 225));
  aircraftList.push(new MiG23("Flogger #2", new THREE.Vector3(40,5,40), 230));
  aircraftList[2].isEnemy = true;
  aircraftList[3].isEnemy = true;

  // Ground SAMs
  samSites.push(new SAMSite(new THREE.Vector3(0,0,0)));
  samSites.push(new SAMSite(new THREE.Vector3(20,0,20)));
}

spawnAircraft();

// ==== ENGAGEMENT LOGIC ====

function updateEngagements(time) {
  aircraftList.forEach(a => a.engaged = false);
  // Mark engaged if within 5 km enemy range
  for (const a of aircraftList) {
    if (!a.alive) continue;
    for (const t of aircraftList) {
      if (!t.alive || a.isEnemy === t.isEnemy) continue;
      const dist = a.position.distanceTo(t.position);
      if (dist < 5) {
        a.engaged = true;
        a.lastEngagedTime = time;
        t.engaged = true;
        t.lastEngagedTime = time;
      }
    }
  }
}

// ==== CAMERA FOCUS LOGIC ====

let currentFocus = null;  // { attacker, target }
let focusCooldown = 0;    // seconds
const focusCooldownTime = 3; // hold time

function updateCameraFocus(time, delta) {
  if (focusCooldown > 0) focusCooldown -= delta;

  let keepFocus = false;
  if (currentFocus) {
    const { attacker, target } = currentFocus;
    if (
      attacker.alive &&
      target.alive &&
      attacker.engaged &&
      target.engaged
    ) keepFocus = true;
  }

  if (!keepFocus && focusCooldown <= 0) {
    // Pick most recently engaged attacker with a target
    let engaged = aircraftList.filter(a => a.engaged && a.alive);
    if (engaged.length > 0) {
      engaged.sort((a,b) => b.lastEngagedTime - a.lastEngagedTime);
      const attacker = engaged[0];
      const enemies = aircraftList.filter(a => a.isEnemy !== attacker.isEnemy && a.alive);
      if (enemies.length) {
        enemies.sort((a,b) => attacker.position.distanceTo(a.position) - attacker.position.distanceTo(b.position));
        currentFocus = { attacker, target: enemies[0] };
        focusCooldown = focusCooldownTime;
        ui.focusText.textContent = `${attacker.name} â†’ ${enemies[0].name}`;
      } else {
        currentFocus = null;
        ui.focusText.textContent = 'Waiting for engagements...';
      }
    } else {
      currentFocus = null;
      ui.focusText.textContent = 'Waiting for engagements...';
    }
  }

  if (currentFocus) {
    // Smoothly position camera between attacker and target, with some elevation and offset
    const { attacker, target } = currentFocus;
    const midpoint = new THREE.Vector3().addVectors(attacker.position, target.position).multiplyScalar(0.5);
    const offset = new THREE.Vector3(0, 50, 100); // elevated and behind view

    // Desired camera position
    const desiredPos = midpoint.clone().add(offset);

    // Smooth lerp camera position and lookAt
    camera.position.lerp(desiredPos, 0.05);
    camera.lookAt(midpoint);
  } else {
    // Default camera position and look at center terrain
    const defaultPos = new THREE.Vector3(0, 100, 200);
    camera.position.lerp(defaultPos, 0.02);
    camera.lookAt(new THREE.Vector3(0, 0, 0));
  }
}

// ==== SIMULATION TICK ====

let totalWeaponsFired = 0;

function animate() {
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  const time = clock.elapsedTime;

  // Update aircraft
  aircraftList.forEach(ac => {
    if (!ac.alive) return;

    // Simple AI logic:
    // Detect enemies, choose closest detected enemy, face and fire if possible
    const enemies = aircraftList.filter(e => e.alive && e.isEnemy !== ac.isEnemy);
    let detectedEnemies = enemies.filter(e => ac.detectTarget(e));
    if (detectedEnemies.length) {
      detectedEnemies.sort((a,b) => ac.distanceTo(a) - ac.distanceTo(b));
      const target = detectedEnemies[0];
      ac.receiveGCICommand(target);
      if (ac.launchWeapons(target)) totalWeaponsFired++;
    }

    ac.update(delta, time);
  });

  // Update SAMs
  samSites.forEach(sam => sam.update(delta, aircraftList));

  // Update engagements (for camera)
  updateEngagements(time);

  // Update camera focus and position
  updateCameraFocus(time, delta);

  // Update UI
  ui.activeSorties.textContent = aircraftList.filter(a => !a.isEnemy && a.alive).length;
  ui.enemiesRemaining.textContent = aircraftList.filter(a => a.isEnemy && a.alive).length;
  ui.groundRemaining.textContent = samSites.filter(s => s.alive).length;
  ui.weaponsFired.textContent = totalWeaponsFired;

  // Render
  renderer.render(scene, camera);

  // FPS display
  const fps = (1 / delta).toFixed(1);
  ui.fps.textContent = `FPS: ${fps}`;
}

// Responsive resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();
</script>
</body>
</html>