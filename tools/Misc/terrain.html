<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Babylon Tank on Terrain</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>

<style>
html, body { width:100%; height:100%; margin:0; overflow:hidden; }
canvas { width:100%; height:100%; display:block; }
#overlay { position:absolute; top:8px; right:8px; background:rgba(0,0,0,0.6); color:white; padding:6px; font-family:monospace; }
#controls { position:absolute; top:8px; left:8px; background:rgba(0,0,0,0.6); color:white; padding:6px; font-family:monospace; }
#controls input { vertical-align: middle; }
</style>
</head>

<body>

<canvas id="renderCanvas"></canvas>
<div id="overlay">Loading…</div>

<div id="controls">
  Speed: <input type="range" id="speedSlider" min="0.1" max="10" step="0.1" value="1">
  <span id="speedVal">1</span>

  &nbsp; | &nbsp;

  Rotation smooth:
  <input id="rotSmooth" type="range" min="0.01" max="1" step="0.01" value="0.12">

  &nbsp; | &nbsp;

  Tilt blend:
  <input id="tiltBlend" type="range" min="0" max="1" step="0.01" value="0.5">
  <span id="tiltVal">0.50</span>
</div>

<script>
(async function(){
const overlay = document.getElementById('overlay');

try {
  const [terrainResp, movesResp, shotsResp] = await Promise.all([
    fetch('f.json'),
    fetch('f2.json'),
    fetch('f3.json')
  ]);

  if(!terrainResp.ok) throw new Error('Failed loading f.json');
  if(!movesResp.ok) throw new Error('Failed loading f2.json');
  if(!shotsResp.ok) throw new Error('Failed loading f3.json');

  const terrainData = await terrainResp.json();
  const movesText = await movesResp.text();
  const shotsText = await shotsResp.text();

  overlay.innerText = 'Files loaded — building scene...';

  buildScene(terrainData, movesText, shotsText);

} catch(err) {
  overlay.innerText = 'Error loading files: ' + err;
  console.error(err);
}

function buildScene(terrainData, movesText, shotsText){
  const canvas = document.getElementById('renderCanvas');
  const engine = new BABYLON.Engine(canvas,true);
  const scene = new BABYLON.Scene(engine);
  scene.clearColor = new BABYLON.Color3(0.529,0.808,0.922);

  // camera
  const camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(0,50,-100), scene);
  camera.setTarget(BABYLON.Vector3.Zero());
  camera.attachControl(canvas,true);

  let camPos = new BABYLON.Vector3();
  let camVel = new BABYLON.Vector3();

  new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene);
  const dirLight = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-1,-2,-1), scene);
  dirLight.position = new BABYLON.Vector3(50,200,50);

  // Terrain keys
  const xKeys = Object.keys(terrainData).map(Number).sort((a,b)=>a-b);
  const zSet = new Set();
  xKeys.forEach(x => Object.keys(terrainData[x]).forEach(z => zSet.add(Number(z))));
  const zKeys = Array.from(zSet).sort((a,b)=>a-b);

  const minX = xKeys[0], maxX = xKeys[xKeys.length-1];
  const minZ = zKeys[0], maxZ = zKeys[zKeys.length-1];
  const centerX = (minX+maxX)/2;
  const centerZ = (minZ+maxZ)/2;

  function heightAt(ix,iz){ return terrainData[xKeys[ix]]?.[zKeys[iz]] || 0; }

  function findNearestIndex(sorted, value){
    let lo=0, hi=sorted.length-1;
    if(value <= sorted[0]) return 0;
    if(value >= sorted[hi]) return hi;
    while(lo<=hi){
      const mid=(lo+hi)>>1;
      if(sorted[mid]===value) return mid;
      if(sorted[mid] < value) lo=mid+1;
      else hi=mid-1;
    }
    const a = Math.max(0,lo-1),
          b = Math.min(sorted.length-1,lo);
    return Math.abs(sorted[a]-value) <= Math.abs(sorted[b]-value) ? a : b;
  }

  // Create terrain mesh
  const rows = zKeys.length;
  const cols = xKeys.length;
  const positions = [];

  for(let zi=0; zi<rows; zi++){
    for(let xi=0; xi<cols; xi++){
      const x = xKeys[xi] - centerX;
      const z = zKeys[zi] - centerZ;
      const y = terrainData[xKeys[xi]][zKeys[zi]];
      positions.push(x,y,z);
    }
  }

  const indices = [];
  for(let zi=0; zi<rows-1; zi++){
    for(let xi=0; xi<cols-1; xi++){
      const a = zi*cols+xi;
      const b = a+1;
      const c = a+cols;
      const d = c+1;
      indices.push(a,c,b, b,c,d);
    }
  }

  const terrain = new BABYLON.Mesh("terrain",scene);
  const vertexData = new BABYLON.VertexData();
  vertexData.positions = positions;
  vertexData.indices = indices;
  vertexData.applyToMesh(terrain,true);
  terrain.convertToFlatShadedMesh();

  const terrainMat = new BABYLON.StandardMaterial("terrainMat",scene);
  terrainMat.diffuseColor = new BABYLON.Color3(0.133,0.545,0.133);
  terrain.material = terrainMat;

  // Parse tank paths
  const rawMoves = movesText.split('|').filter(s => s.trim());
  const tanks = {};

  rawMoves.forEach(t=>{
    const match = t.match(/(-?\d+)\s*,\s*(-?\d+)$/);
    if(!match) return;
    const id = t.split(' ')[0];
    const x = Number(match[1]);
    const z = Number(match[2]);
    if(!tanks[id]) tanks[id] = { path: [] };
    tanks[id].path.push([x,z]);
  });

  const colors = [
    BABYLON.Color3.Red(),
    BABYLON.Color3.Blue(),
    BABYLON.Color3.Yellow(),
    BABYLON.Color3.Purple()
  ];

  let colorIdx = 0;

  for(const id in tanks){
    const t = tanks[id];

    const mesh = BABYLON.MeshBuilder.CreateBox(id,
      {width:6, height:4, depth:6},
      scene
    );

    mesh.material = new BABYLON.StandardMaterial("mat"+id,scene);
    mesh.material.diffuseColor = colors[colorIdx++ % colors.length];

    t.mesh = mesh;

    // convert path to world coords
    t.worldPath = t.path.map(([px,pz])=>{
      const ix = findNearestIndex(xKeys,px);
      const iz = findNearestIndex(zKeys,pz);
      const h  = heightAt(ix,iz);

      return {
        x: xKeys[ix] - centerX,
        y: h + 2,
        z: zKeys[iz] - centerZ,
        ix, iz
      };
    });

    t.currentIndex = 0;
    t.progress = 0;
    t._tmp = {
      forward: new BABYLON.Vector3(),
      tangentFwd: new BABYLON.Vector3(),
      right: new BABYLON.Vector3(),
      normal: new BABYLON.Vector3()
    };

    if(t.worldPath.length){
      mesh.position.set(
        t.worldPath[0].x,
        t.worldPath[0].y,
        t.worldPath[0].z
      );
    }
  }

  // Shots
  const shotsList = shotsText.split('|').filter(s=>s.trim());
  shotsList.forEach(s=>{
    const nums = s.split(',').map(Number);
    if(nums.length !== 4) return;
    const [x1,z1,x2,z2] = nums;

    const i1 = findNearestIndex(xKeys,x1);
    const k1 = findNearestIndex(zKeys,z1);
    const i2 = findNearestIndex(xKeys,x2);
    const k2 = findNearestIndex(zKeys,z2);

    const p1 = new BABYLON.Vector3(
      xKeys[i1]-centerX,
      heightAt(i1,k1) + 1,
      zKeys[k1]-centerZ
    );
    const p2 = new BABYLON.Vector3(
      xKeys[i2]-centerX,
      heightAt(i2,k2) + 1,
      zKeys[k2]-centerZ
    );

    BABYLON.MeshBuilder.CreateLines("shot",{points:[p1,p2]},scene);
  });

  // UI sliders
  let speed = 1;
  const speedSlider = document.getElementById('speedSlider');
  const speedVal = document.getElementById('speedVal');

  speedSlider.addEventListener('input',()=>{
    speed = parseFloat(speedSlider.value);
    speedVal.textContent = speed.toFixed(1);
  });

  const rotSmoothInput = document.getElementById('rotSmooth');
  const tiltBlendInput = document.getElementById('tiltBlend');
  const tiltValSpan = document.getElementById('tiltVal');

  tiltBlendInput.addEventListener('input',()=>{
    tiltValSpan.textContent = parseFloat(tiltBlendInput.value).toFixed(2);
  });

  // compute local terrain normal
  function computeNormalStencil(ix,iz,out){
    const ixm = Math.max(0, ix-1),
          ixp = Math.min(cols-1, ix+1),
          izm = Math.max(0, iz-1),
          izp = Math.min(rows-1, iz+1);

    const hL = heightAt(ixm,iz);
    const hR = heightAt(ixp,iz);
    const hD = heightAt(ix,izm);
    const hU = heightAt(ix,izp);

    const dx = (xKeys[ixp] - xKeys[ixm]) || 1;
    const dz = (zKeys[izp] - zKeys[izm]) || 1;

    const nx = -(hR - hL) / dx;
    const ny = 2;
    const nz = -(hU - hD) / dz;

    const len = Math.sqrt(nx*nx + ny*ny + nz*nz) || 1;
    out.set(nx/len, ny/len, nz/len);

    return out;
  }

  let lastTime = performance.now();
  const firstTankId = Object.keys(tanks)[0];

  if(firstTankId){
    const m = tanks[firstTankId].mesh;
    camPos.set(m.position.x+60, m.position.y+80, m.position.z+120);
    camera.position.copyFrom(camPos);
    camera.setTarget(m.position);
  }

  // main animation loop
  engine.runRenderLoop(()=>{
    const now = performance.now();
    let dt = (now - lastTime)/1000;
    if(dt <= 0) dt = 1/60;
    dt = Math.min(dt, 0.05);
    lastTime = now;

    const delta60 = dt/(1/60);

    // move tanks
    for(const id in tanks){
      const t = tanks[id];
      const path = t.worldPath;
      if(!path || path.length < 2) continue;

      // compute segment lengths on first run
      if(!t._segLen){
        t._segLen = [];
        for(let i=0; i<path.length-1; i++){
          t._segLen[i] = BABYLON.Vector3.Distance(path[i], path[i+1]) || 0.0001;
        }
      }

      let remaining = speed * delta60;

      while(remaining > 0 && t.currentIndex < path.length-1){
        const segLen = t._segLen[t.currentIndex];
        const distLeft = segLen * (1 - t.progress);
        if(remaining >= distLeft){
          remaining -= distLeft;
          t.currentIndex++;
          t.progress = 0;
        } else {
          t.progress += remaining / segLen;
          remaining = 0;
        }
      }

      const cur = path[t.currentIndex];
      const nxt = path[Math.min(t.currentIndex+1, path.length-1)];

      // linear position along segment
      t.mesh.position.copyFrom(
        BABYLON.Vector3.Lerp(cur, nxt, t.progress)
      );

      // orientation
      const dx = nxt.x - cur.x;
      const dz = nxt.z - cur.z;

      const tmp = t._tmp;
      tmp.forward.set(dx||0.0001, 0, dz||0.0001).normalize();
      computeNormalStencil(cur.ix,cur.iz,tmp.normal);

      // tangent = projected forward vector
      const dot = BABYLON.Vector3.Dot(tmp.forward,tmp.normal);
      tmp.tangentFwd.copyFrom(tmp.forward).subtract(tmp.normal.scale(dot)).normalize();
      tmp.right.copyFrom(BABYLON.Vector3.Cross(tmp.tangentFwd,tmp.normal)).normalize();

      // build rotation matrix
      const M = BABYLON.Matrix.FromValues(
        tmp.right.x,   tmp.right.y,   tmp.right.z,   0,
        tmp.normal.x,  tmp.normal.y,  tmp.normal.z,  0,
        -tmp.tangentFwd.x,-tmp.tangentFwd.y,-tmp.tangentFwd.z,0,
        0,0,0,1
      );

      const desiredQuat = BABYLON.Quaternion.FromRotationMatrix(M);

      // flat yaw only
      const yaw = Math.atan2(tmp.forward.x, tmp.forward.z);
      const yawQuat = BABYLON.Quaternion.RotationAxis(BABYLON.Axis.Y, yaw);

      const tiltBlend = parseFloat(tiltBlendInput.value) || 0.5;
      const blended = BABYLON.Quaternion.Slerp(yawQuat, desiredQuat, tiltBlend);

      const smooth = parseFloat(rotSmoothInput.value) || 0.12;
      const factor = Math.min(1, smooth * delta60);

      if(t.mesh.rotationQuaternion){
        t.mesh.rotationQuaternion = BABYLON.Quaternion.Slerp(
          t.mesh.rotationQuaternion,
          blended,
          factor
        );
      } else {
        t.mesh.rotationQuaternion = blended;
      }
    }

    // camera follows first tank
    if(firstTankId){
      const m = tanks[firstTankId].mesh;
      const desired = new BABYLON.Vector3(
        m.position.x+60,
        m.position.y+80,
        m.position.z+120
      );

      const k = 60;
      const d = 12;

      const displacement = desired.subtract(camPos);
      const accel = displacement.scale(k).subtract(camVel.scale(d)).scale(dt);

      camVel.addInPlace(accel);
      camPos.addInPlace(camVel.scale(dt));

      camera.position.copyFrom(camPos);
      camera.setTarget(m.position);
    }

    scene.render();
  });

  window.addEventListener('resize', ()=>engine.resize());
  overlay.style.display = 'none';
}
})();
</script>

</body>
</html>