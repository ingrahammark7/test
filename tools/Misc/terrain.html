<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Babylon Tank Terrain — Auto-Fit v8</title>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

<style>
  html, body {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
    touch-action: none;
    background: #000;
  }
  #renderCanvas {
    width: 100vw;
    height: 100vh;
    display: block;
  }
  #overlay, #controls {
    position: absolute; z-index: 30;
    background: rgba(0,0,0,0.55);
    font-family: monospace;
    color: white;
    padding: 6px 10px;
    border-radius: 8px;
    user-select: none;
  }
  #overlay { right: 8px; top: 8px; width: 320px; }
  #controls { left: 8px; top: 8px; width: 260px; }
</style>
</head>

<body>
<div id="controls">
  Speed:
  <input type="range" id="speedSlider" min="0.1" max="10" step="0.1" value="1">
  <span id="speedVal">1</span><br>

  Rotation smooth:
  <input type="range" id="rotSmooth" min="0.01" max="1" step="0.01" value="0.12"><br>

  Tilt blend:
  <input type="range" id="tiltBlend" min="0" max="1" step="0.01" value="0.50">
  <span id="tiltVal">0.50</span>
</div>

<div id="overlay">Loading…</div>
<canvas id="renderCanvas"></canvas>

<script>
(async function() {

  // Bump this to force Chrome to reload files
  const VER = "8";

  const canvas = document.getElementById("renderCanvas");
  const overlay = document.getElementById("overlay");
  const engine = new BABYLON.Engine(canvas, true, {
    preserveDrawingBuffer: true,
    stencil: true
  });

  //---------------------------------------------------------
  // Load all files with no caching
  //---------------------------------------------------------
  try {
    const [terrainResp, movesResp, shotsResp] = await Promise.all([
      fetch("f.json?v=" + VER),
      fetch("f2.json?v=" + VER),
      fetch("f3.json?v=" + VER)
    ]);

    const terrainData = await terrainResp.json();
    const movesText   = await movesResp.text();
    const shotsText   = await shotsResp.text();

    overlay.textContent = "Building scene…";

    buildScene(terrainData, movesText, shotsText);

  } catch (e) {
    overlay.textContent = "Load error: " + e;
    console.error(e);
  }

  //---------------------------------------------------------
  // Build Scene
  //---------------------------------------------------------
  function buildScene(terrainData, movesText, shotsText) {

    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.55, 0.80, 0.92);
    scene.useRightHandedSystem = true;  // EXACT match to Three.js paths

    //---------------------------------------------------------
    // Compute grid bounds
    //---------------------------------------------------------
    const xs = Object.keys(terrainData).map(Number).sort((a,b)=>a-b);
    const zs = [...new Set(xs.flatMap(x=>Object.keys(terrainData[x]).map(Number)))].sort((a,b)=>a-b);

    const minX = xs[0],  maxX = xs.at(-1);
    const minZ = zs[0],  maxZ = zs.at(-1);

    const centerX = (minX + maxX) / 2;
    const centerZ = (minZ + maxZ) / 2;

    const sizeX = maxX - minX;
    const sizeZ = maxZ - minZ;
    const maxSize = Math.max(sizeX, sizeZ);

    //---------------------------------------------------------
    // Camera tuned to match Three.js "orbit" feel
    //---------------------------------------------------------
    const camera = new BABYLON.ArcRotateCamera(
      "cam",
      -Math.PI / 2.3,          // rotate to match Three.js orientation
      Math.PI / 3.2,           // elevated slightly
      maxSize * 1.25,          // zoom to fit terrain exactly
      new BABYLON.Vector3(0, 0, 0),
      scene
    );
    camera.attachControl(canvas, true);
    camera.lowerRadiusLimit = maxSize * 0.3;
    camera.upperRadiusLimit = maxSize * 3.0;

    new BABYLON.HemisphericLight("h", new BABYLON.Vector3(0,1,0), scene);
    const sun = new BABYLON.DirectionalLight("d", new BABYLON.Vector3(-0.4,-1,-0.6), scene);
    sun.intensity = 1.0;

    //---------------------------------------------------------
    // Build terrain mesh from height map
    //---------------------------------------------------------
    const positions = [];
    const indices = [];

    const xCount = xs.length;
    const zCount = zs.length;

    for (let zi = 0; zi < zCount; zi++) {
      for (let xi = 0; xi < xCount; xi++) {
        const x = xs[xi] - centerX;
        const z = zs[zi] - centerZ;
        const y = terrainData[xs[xi]][zs[zi]] || 0;
        positions.push(x, y, z);
      }
    }

    for (let zi=0; zi < zCount-1; zi++) {
      for (let xi=0; xi < xCount-1; xi++) {
        const a = zi*xCount + xi;
        const b = a+1;
        const c = a + xCount;
        const d = c+1;
        indices.push(a,c,b, b,c,d);
      }
    }

    const terrain = new BABYLON.Mesh("terrain", scene);
    const vd = new BABYLON.VertexData();
    vd.positions = positions;
    vd.indices = indices;
    vd.applyToMesh(terrain);

    terrain.material = new BABYLON.StandardMaterial("tmat", scene);
    terrain.material.diffuseColor = new BABYLON.Color3(0.16,0.52,0.16);

    //---------------------------------------------------------
    // Height lookup = nearest grid (same as your Three.js version)
    //---------------------------------------------------------
    function heightAt(x, z) {
      let best = Infinity;
      let hx = 0, hz = 0;
      for (let i=0; i < xs.length; i++) {
        for (let j=0; j < zs.length; j++) {
          const dx = (xs[i]-centerX)-x;
          const dz = (zs[j]-centerZ)-z;
          const d = dx*dx + dz*dz;
          if (d < best) {
            best = d;
            hx = xs[i];
            hz = zs[j];
          }
        }
      }
      return terrainData[hx][hz] || 0;
    }

    //---------------------------------------------------------
    // Parse tank paths from f2.json (same syntax as Three.js)
    //---------------------------------------------------------
    const tanks = {};
    movesText.split("|").filter(s => s.trim()).forEach(line => {
      const m = line.match(/(\S+).*?(-?\d+),(-?\d+)$/);
      if (!m) return;
      const id = m[1];
      const x = Number(m[2]) - centerX;
      const z = Number(m[3]) - centerZ;
      if (!tanks[id]) tanks[id] = { path: [] };
      tanks[id].path.push(new BABYLON.Vector3(x,0,z));
    });

    //---------------------------------------------------------
    // Tank colors (fixed set)
    //---------------------------------------------------------
    const COLORS = [
      new BABYLON.Color3(1,0,0),
      new BABYLON.Color3(0,0.6,1),
      new BABYLON.Color3(1,1,0),
      new BABYLON.Color3(1,0,1),
      new BABYLON.Color3(0,1,1),
    ];

    //---------------------------------------------------------
    // Build tank meshes
    //---------------------------------------------------------
    let cIndex = 0;

    for (const id in tanks) {
      const tank = tanks[id];

      const mesh = BABYLON.MeshBuilder.CreateBox("tank"+id, {size:6}, scene);
      const mat = new BABYLON.StandardMaterial("m"+id, scene);
      mat.diffuseColor = COLORS[cIndex++ % COLORS.length];
      mesh.material = mat;

      const p0 = tank.path[0];
      mesh.position.set(p0.x, heightAt(p0.x,p0.z)+2, p0.z);

      tank.mesh = mesh;
      tank.index = 0;
      tank.progress = 0;
      tank.cooldown = Math.random()*2 + 0.5;
    }

    //---------------------------------------------------------
    // Static shot lines from f3.json
    //---------------------------------------------------------
    shotsText.split("|").filter(s=>s.trim()).forEach(line=>{
      const p = line.split(",").map(Number);
      if (p.length !== 4) return;
      const [x1,z1,x2,z2] = p;

      const a = new BABYLON.Vector3(x1-centerX, heightAt(x1-centerX,z1-centerZ)+1, z1-centerZ);
      const b = new BABYLON.Vector3(x2-centerX, heightAt(x2-centerX,z2-centerZ)+1, z2-centerZ);

      BABYLON.MeshBuilder.CreateLines("f3", {points:[a,b]}, scene)
        .color = new BABYLON.Color3(1,1,1);
    });

    //---------------------------------------------------------
    // Dynamic shot effects
    //---------------------------------------------------------
    const dynShots = [];
    function fireShot(from, to) {
      const a = from.mesh.position.clone();
      const b = to.mesh.position.clone();
      const line = BABYLON.MeshBuilder.CreateLines("shot",{points:[a,b]},scene);
      line.color = new BABYLON.Color3(1,1,1);
      dynShots.push({mesh:line, life:0.15});
    }

    //---------------------------------------------------------
    // UI hooks
    //---------------------------------------------------------
    let speed = 1;
    document.getElementById("speedSlider").oninput = e=>{
      speed = parseFloat(e.target.value);
      document.getElementById("speedVal").textContent = speed.toFixed(1);
    };
    document.getElementById("tiltBlend").oninput = e=>{
      document.getElementById("tiltVal").textContent = parseFloat(e.target.value).toFixed(2);
    };

    //---------------------------------------------------------
    // Update loop (identical pacing to Three.js version)
    //---------------------------------------------------------
    scene.onBeforeRenderObservable.add(() => {

      const dt = engine.getDeltaTime() / 1000;
      const dt60 = dt / (1/60);

      for (const id in tanks) {
        const t = tanks[id];

        if (t.path.length < 2) continue;

        let remain = speed * dt60;

        while (remain>0 && t.index < t.path.length-1) {
          const A = t.path[t.index];
          const B = t.path[t.index+1];
          const seg = BABYLON.Vector3.Distance(A,B);
          const left = seg*(1 - t.progress);

          if (remain >= left) {
            remain -= left;
            t.index++;
            t.progress = 0;
          } else {
            t.progress += remain / seg;
            remain = 0;
          }
        }

        const A = t.path[t.index];
        const B = t.path[Math.min(t.index+1, t.path.length-1)];
        const p = BABYLON.Vector3.Lerp(A,B,t.progress);

        t.mesh.position.set(p.x, heightAt(p.x,p.z)+2, p.z);

        // Shooting
        t.cooldown -= dt;
        if (t.cooldown <= 0) {
          let best=null, bestDist=9999;
          for (const oid in tanks) {
            if (oid===id) continue;
            const d = BABYLON.Vector3.Distance(
              t.mesh.position, tanks[oid].mesh.position
            );
            if (d < 55 && d < bestDist) {
              bestDist = d;
              best = tanks[oid];
            }
          }
          if (best) fireShot(t,best);
          t.cooldown = Math.random()*2 + 0.5;
        }
      }

      // Fade dynamic shots
      for (let i=dynShots.length-1; i>=0; i--) {
        dynShots[i].life -= dt;
        if (dynShots[i].life <= 0) {
          dynShots[i].mesh.dispose();
          dynShots.splice(i,1);
        }
      }

    });

    overlay.style.display = "none";
    engine.runRenderLoop(() => scene.render());
  }

  window.addEventListener("resize", () => engine.resize());

})();
</script>
</body>
</html>