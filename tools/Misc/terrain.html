<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Animated LCG-Seeded Fractal Perlin Terrain</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87ceeb; }
        canvas { display: block; }
    </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
/* --- LCG Generator --- */
class LCG {
    constructor(seed = 12345) {
        this.m = 2 ** 32;
        this.a = 1664525;
        this.c = 1013904223;
        this.state = seed;
    }
    next() {
        this.state = (this.a * this.state + this.c) % this.m;
        return this.state / this.m;
    }
}

/* --- Gradient Table --- */
const size = 256;
const lcg = new LCG(42); // Change seed for different terrain
const gradients = new Array(size).fill(0).map(() => lcg.next() * 2 - 1);
gradients.push(...gradients); // duplicate for wrap-around

/* --- Perlin Noise Functions --- */
function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
function lerp(a, b, t) { return a + t * (b - a); }
function grad(hash, x, y) { const g = gradients[hash % 256]; return g * x + g * y; }

function perlin2D(x, y) {
    const x0 = Math.floor(x), x1 = x0 + 1;
    const y0 = Math.floor(y), y1 = y0 + 1;
    const xf = x - x0, yf = y - y0;

    const h00 = (x0 + y0) % 256;
    const h01 = (x0 + y1) % 256;
    const h10 = (x1 + y0) % 256;
    const h11 = (x1 + y1) % 256;

    const d00 = grad(h00, xf, yf);
    const d10 = grad(h10, xf - 1, yf);
    const d01 = grad(h01, xf, yf - 1);
    const d11 = grad(h11, xf - 1, yf - 1);

    const u = fade(xf), v = fade(yf);
    const nx0 = lerp(d00, d10, u);
    const nx1 = lerp(d01, d11, u);
    return lerp(nx0, nx1, v);
}

/* --- Fractal / Multi-Octave Perlin --- */
function fractalPerlin2D(x, y, octaves = 5, persistence = 0.5, lacunarity = 2.0) {
    let total = 0, amplitude = 1, frequency = 1, maxValue = 0;
    for (let i = 0; i < octaves; i++) {
        total += perlin2D(x * frequency, y * frequency) * amplitude;
        maxValue += amplitude;
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    return total / maxValue;
}

/* --- Three.js Setup --- */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 500);
camera.position.set(0, 60, 100);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* --- Terrain Geometry --- */
const planeSize = 100;
const segments = 100;
const geometry = new THREE.PlaneGeometry(planeSize, planeSize, segments, segments);
geometry.rotateX(-Math.PI/2);

// Vertex coloring placeholder
const colors = new Float32Array(geometry.attributes.position.count * 3);

/* --- Material & Mesh --- */
const material = new THREE.MeshStandardMaterial({vertexColors:true, flatShading:true});
const terrain = new THREE.Mesh(geometry, material);
scene.add(terrain);

/* --- Lights --- */
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(50, 100, 50);
scene.add(light);
scene.add(new THREE.AmbientLight(0xffffff, 0.4));

/* --- Animation / Breathing Effect --- */
let time = 0;

function animate() {
    requestAnimationFrame(animate);
    time += 0.005; // slow breathing speed

    for (let i = 0; i < geometry.attributes.position.count; i++) {
        const x = geometry.attributes.position.getX(i) / 20;
        const z = geometry.attributes.position.getZ(i) / 20;
        const y = fractalPerlin2D(x + time, z + time, 5, 0.5, 2) * 15;
        geometry.attributes.position.setY(i, y);

        // Color by height
        if (y < 2) { colors[i*3] = 0; colors[i*3+1] = 0.3; colors[i*3+2] = 0; }      // grass
        else if (y < 8) { colors[i*3] = 0.5; colors[i*3+1] = 0.4; colors[i*3+2] = 0.2; } // dirt/rock
        else { colors[i*3] = 1; colors[i*3+1] = 1; colors[i*3+2] = 1; }              // snow
    }

    geometry.attributes.position.needsUpdate = true;
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    geometry.computeVertexNormals();

    renderer.render(scene, camera);
}

/* --- Start Animation --- */
animate();

/* --- Responsive Resize --- */
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>