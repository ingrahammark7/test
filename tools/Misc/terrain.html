<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Fine-Tuning Hierarchy Animation</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

<script>
  // Scene and camera
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);
  const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(30, 20, 40);
  camera.lookAt(0, 10, 0);

  // Renderer
  const renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Layers and colors
  const layers = [
    {name: "Fundamental constants", color: 0x2ca02c, fragility: 1},
    {name: "Chemistry & reactions", color: 0x98df8a, fragility: 2},
    {name: "Stellar physics", color: 0xffbb78, fragility: 5},
    {name: "Stellar arrangement", color: 0xff7f0e, fragility: 8},
    {name: "Planetary habitability", color: 0xd62728, fragility: 9},
    {name: "Cosmological features", color: 0x9467bd, fragility: 10}
  ];

  const boxes = [];
  const spacing = 4;

  // Create boxes
  layers.forEach((layer, i) => {
    const geometry = new THREE.BoxGeometry(6, layer.fragility*2, 6);
    const material = new THREE.MeshStandardMaterial({
      color: layer.color,
      emissive: layer.color,
      emissiveIntensity: 0.2
    });
    const box = new THREE.Mesh(geometry, material);
    box.position.y = layer.fragility + i*spacing;
    boxes.push(box);
    scene.add(box);
  });

  // Floating arrow with gradient color
  const arrowGeometry = new THREE.ConeGeometry(1, 3, 32);
  const arrowMaterial = new THREE.MeshStandardMaterial({color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.5});
  const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
  arrow.rotation.x = Math.PI; // point upward
  scene.add(arrow);

  // Lights
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
  scene.add(ambientLight);
  const pointLight = new THREE.PointLight(0xffffff, 1);
  pointLight.position.set(50, 50, 50);
  scene.add(pointLight);

  // Device tilt variables
  let tiltX = 0, tiltY = 0;
  window.addEventListener('deviceorientation', (event) => {
    tiltX = event.gamma ? event.gamma * 0.01 : 0; // left-right tilt
    tiltY = event.beta ? event.beta * 0.01 : 0;   // front-back tilt
  }, true);

  // Animation
  let clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);
    const time = clock.getElapsedTime();

    // Scene tilt controlled by phone orientation
    scene.rotation.x = tiltY + Math.sin(time*0.05)*0.05; // subtle auto tilt
    scene.rotation.y = tiltX + Math.sin(time*0.1)*0.1;

    // Pulsing effect for layers
    boxes.forEach((box, i) => {
      box.material.emissiveIntensity = 0.2 + 0.3 * Math.sin(time * (0.5 + i*0.2));
    });

    // Move arrow upward repeatedly
    const arrowHeight = (time % 20); // loops 0->20
    arrow.position.y = arrowHeight;

    // Arrow color gradient from green → red → purple
    const t = arrowHeight / 20;
    arrow.material.color.setRGB(
      Math.min(1, t*2),             // red
      Math.max(0, 1 - t*2),         // green
      t                           // blue
    );
    arrow.material.emissive.set(arrow.material.color);

    renderer.render(scene, camera);
  }

  animate();

  // Handle resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>