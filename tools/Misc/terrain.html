<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Cube + Torus Fields + Electrons</title>
<style>
  body { margin:0; overflow:hidden; background:#101020; }
  canvas { display:block; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

const centerX = canvas.width/2;
const centerY = canvas.height/2;
const scale = 200; // perspective scale
const distance = 5; // camera distance

// Utility: 3D rotation
function rotateX(p, angle){ 
  const cos = Math.cos(angle), sin = Math.sin(angle);
  return {x: p.x, y: p.y*cos - p.z*sin, z: p.y*sin + p.z*cos};
}
function rotateY(p, angle){
  const cos = Math.cos(angle), sin = Math.sin(angle);
  return {x: p.x*cos + p.z*sin, y: p.y, z: -p.x*sin + p.z*cos};
}
function rotateZ(p, angle){
  const cos = Math.cos(angle), sin = Math.sin(angle);
  return {x: p.x*cos - p.y*sin, y: p.x*sin + p.y*cos, z: p.z};
}

// Perspective projection
function project(p){
  return {
    x: centerX + (p.x / (p.z + distance)) * scale,
    y: centerY - (p.y / (p.z + distance)) * scale
  };
}

// Cube vertices
const cubeSize = 1.5;
const cubeVertices = [];
for(let dx=-1; dx<=1; dx+=2){
  for(let dy=-1; dy<=1; dy+=2){
    for(let dz=-1; dz<=1; dz+=2){
      cubeVertices.push({x:dx*cubeSize, y:dy*cubeSize, z:dz*cubeSize});
    }
  }
}
const cubeEdges = [
  [0,1],[0,2],[0,4],[1,3],[1,5],[2,3],[2,6],[3,7],
  [4,5],[4,6],[5,7],[6,7]
];

// Torus definition (parametric)
function generateTorus(R,r,stepsU,stepsV){
  const verts = [];
  for(let i=0;i<stepsU;i++){
    const u = i/stepsU * 2*Math.PI;
    for(let j=0;j<stepsV;j++){
      const v = j/stepsV * 2*Math.PI;
      const x = (R + r*Math.cos(v)) * Math.cos(u);
      const y = (R + r*Math.cos(v)) * Math.sin(u);
      const z = r * Math.sin(v);
      verts.push({x,y,z});
    }
  }
  return verts;
}

// Create two toruses
const torus1 = generateTorus(2,0.3,20,10);
const torus2 = generateTorus(2.2,0.2,20,10);

// Electrons moving along torus paths
const electrons = [];
const electronCount = 30;
for(let i=0;i<electronCount;i++){
  electrons.push({
    u: Math.random()*2*Math.PI,
    v: Math.random()*2*Math.PI,
    r: Math.random()<0.5?0.3:0.2, // radius depending on torus
    speedU: 0.01+Math.random()*0.02,
    speedV: 0.01+Math.random()*0.02,
    R: Math.random()<0.5?2:2.2
  });
}

let t=0;
function animate(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  t += 0.01;

  // Rotate cube vertices
  const rotatedCube = cubeVertices.map(v=>{
    let p = rotateX(v, t*0.5);
    p = rotateY(p, t*0.3);
    p = rotateZ(p, t*0.2);
    return p;
  });

  // Draw cube edges
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 2;
  cubeEdges.forEach(e=>{
    const p1 = project(rotatedCube[e[0]]);
    const p2 = project(rotatedCube[e[1]]);
    ctx.beginPath();
    ctx.moveTo(p1.x,p1.y);
    ctx.lineTo(p2.x,p2.y);
    ctx.stroke();
  });

  // Draw toruses as wireframe
  function drawTorus(torus,color){
    ctx.strokeStyle = color;
    for(let i=0;i<torus.length;i++){
      const p1 = rotateX(torus[i], t*0.3);
      const p2 = rotateY(p1, t*0.2);
      const proj = project(p2);
      ctx.beginPath();
      ctx.arc(proj.x, proj.y, 1,0,2*Math.PI);
      ctx.fillStyle=color;
      ctx.fill();
    }
  }
  drawTorus(torus1,'#00ffff');
  drawTorus(torus2,'#ff00ff');

  // Draw electrons moving along torus
  electrons.forEach(e=>{
    e.u += e.speedU;
    e.v += e.speedV;
    const x = (e.R + e.r*Math.cos(e.v))*Math.cos(e.u);
    const y = (e.R + e.r*Math.cos(e.v))*Math.sin(e.u);
    const z = e.r*Math.sin(e.v);
    let p = rotateX({x,y,z}, t*0.3);
    p = rotateY(p, t*0.2);
    const proj = project(p);
    ctx.beginPath();
    ctx.arc(proj.x,proj.y,3,0,2*Math.PI);
    ctx.fillStyle = '#ffff00';
    ctx.fill();
  });

  requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>