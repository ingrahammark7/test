<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Tank on Terrain — Smooth Movement</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{height:100%;margin:0}
  canvas{display:block}
  #overlay{
    position:fixed; right:8px; top:8px;
    width:320px; background:rgba(0,0,0,0.6);
    color:#fff; font-family:monospace;
    font-size:12px; padding:8px; border-radius:6px;
  }
</style>
</head>
<body>
<div id="overlay">Loading files…</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
<script>
(async function(){
  const overlay = document.getElementById('overlay');

  try{
    const [terrainResp, movesResp] = await Promise.all([
      fetch('f.json'),
      fetch('f2.json')
    ]);
    if(!terrainResp.ok) throw new Error('Failed loading f.json');
    if(!movesResp.ok) throw new Error('Failed loading f2.json');

    const terrainData = await terrainResp.json();
    const movesText = await movesResp.text();
    overlay.innerText = 'Files loaded — building scene...';
    buildScene(terrainData, movesText);
  }catch(err){
    overlay.innerText = 'Error loading files: ' + err;
    console.error(err);
  }

  function buildScene(terrainData, movesText){
    // Terrain keys
    const xKeys = Object.keys(terrainData).map(Number).sort((a,b)=>a-b);
    const zSet = new Set();
    xKeys.forEach(x=>{
      Object.keys(terrainData[String(x)]||{}).forEach(z=>zSet.add(Number(z)));
    });
    const zKeys = Array.from(zSet).sort((a,b)=>a-b);
    const minX=xKeys[0], maxX=xKeys[xKeys.length-1];
    const minZ=zKeys[0], maxZ=zKeys[zKeys.length-1];
    const centerX=(minX+maxX)/2, centerZ=(minZ+maxZ)/2;
    const cols = xKeys.length, rows = zKeys.length;

    // Terrain geometry
    const geom = new THREE.BufferGeometry();
    const pos = new Float32Array(cols*rows*3);
    let pi=0;
    for(let i=0;i<rows;i++){
      for(let j=0;j<cols;j++){
        const worldX = xKeys[j], worldZ = zKeys[i];
        const h = terrainData[String(worldX)]?.[String(worldZ)]||0;
        pos[pi++] = worldX; pos[pi++] = h; pos[pi++] = worldZ;
      }
    }
    geom.setAttribute('position', new THREE.BufferAttribute(pos,3));
    const idxs = [];
    for(let i=0;i<rows-1;i++){
      for(let j=0;j<cols-1;j++){
        const a=i*cols+j, b=a+1, c=a+cols, d=c+1;
        idxs.push(a,c,b,b,c,d);
      }
    }
    geom.setIndex(idxs);
    geom.computeVertexNormals();

    const mat = new THREE.MeshStandardMaterial({color:0x228B22, flatShading:true});
    const terrainMesh = new THREE.Mesh(geom, mat);
    terrainMesh.position.set(-centerX,0,-centerZ);

    // Scene + lights
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);
    scene.add(terrainMesh);
    const dir = new THREE.DirectionalLight(0xffffff,1);
    dir.position.set(centerX+200,400,centerZ+200);
    scene.add(dir);
    scene.add(new THREE.AmbientLight(0x404040));

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio||1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,5000);

    // Parse tank moves
    const rawMoves = movesText.split('|').filter(s=>s.trim());
    const tanks = {};
    rawMoves.forEach(token=>{
      const m = token.trim();
      if(!m) return;
      const match = m.match(/(-?\d+)\s*,\s*(-?\d+)\s*$/);
      if(!match) return;
      const id = m.split(' ')[0], x=Number(match[1]), z=Number(match[2]);
      if(!tanks[id]) tanks[id]={path:[]};
      tanks[id].path.push([x,z]);
    });

    // helper: nearest terrain key
    function findNearest(sorted,v){
      let lo=0,hi=sorted.length-1;
      if(v<=sorted[0]) return sorted[0];
      if(v>=sorted[hi]) return sorted[hi];
      while(lo<=hi){
        const mid=Math.floor((lo+hi)/2);
        if(sorted[mid]===v) return v;
        if(sorted[mid]<v) lo=mid+1; else hi=mid-1;
      }
      const a=sorted[Math.max(0,lo-1)], b=sorted[Math.min(sorted.length-1,lo)];
      return (Math.abs(a-v)<=Math.abs(b-v))?a:b;
    }

    // Create tank meshes and mapped path
    const colors=[0xff0000,0x0000ff,0xffff00,0xff00ff,0x00ffff,0xff8800];
    let colorIdx=0;
    for(const id in tanks){
      const t=tanks[id];
      const geo=new THREE.BoxGeometry(6,4,6);
      const matTank = new THREE.MeshStandardMaterial({color:colors[colorIdx++%colors.length]});
      const mesh = new THREE.Mesh(geo,matTank);
      mesh.position.set(0,2,0);
      scene.add(mesh);
      t.mesh=mesh;

      // Map path to terrain world positions
      t.worldPath = t.path.map(([tx,tz])=>{
        const nx=findNearest(xKeys,tx), nz=findNearest(zKeys,tz);
        const h = terrainData[String(nx)]?.[String(nz)]||0;
        return {tx,tz,x:nx-centerX,y:h+2,z:nz-centerZ};
      });
      // Start tank at first point
      if(t.worldPath.length) {
        const p0 = t.worldPath[0];
        mesh.position.set(p0.x,p0.y,p0.z);
      }
      t.currentIndex=0;
      t.progress=0;
    }

    // Initialize camera above first tank
    const firstId = Object.keys(tanks)[0];
    if(firstId){
      const f = tanks[firstId].mesh;
      camera.position.set(f.position.x+60, f.position.y+80, f.position.z+120);
      camera.lookAt(f.position);
    }

    // Animation
    const speed = 1; // 0 < speed <= 1, fraction per frame
    function animate(){
      requestAnimationFrame(animate);
      for(const id in tanks){
        const t = tanks[id];
        const wp = t.worldPath;
        if(!wp.length) continue;
        const idx = t.currentIndex;
        const nextIdx = Math.min(idx+1,wp.length-1);
        const cur = wp[idx], next = wp[nextIdx];
        // increment progress
        t.progress += speed;
        if(t.progress>=1){ 
          t.progress=0; 
          t.currentIndex = nextIdx; 
        }
        const px = THREE.MathUtils.lerp(cur.x,next.x,t.progress);
        const py = THREE.MathUtils.lerp(cur.y,next.y,t.progress);
        const pz = THREE.MathUtils.lerp(cur.z,next.z,t.progress);
        t.mesh.position.set(px,py,pz);
      }

      // Camera follow first tank smoothly
      if(firstId){
        const f = tanks[firstId].mesh;
        const desired = new THREE.Vector3(f.position.x+60,f.position.y+80,f.position.z+120);
        camera.position.lerp(desired,0.1);
        camera.lookAt(f.position);
      }

      renderer.render(scene,camera);
    }
    animate();

    // Resize
    window.addEventListener('resize',()=>{
      renderer.setSize(window.innerWidth,window.innerHeight);
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
    });
    overlay.style.display='none';
  }
})();
</script>
</body>
</html>