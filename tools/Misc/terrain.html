<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Tank on Terrain - Flask Load</title>
<style>
body { margin:0; overflow:hidden; }
#log { position:fixed; bottom:0; left:0; width:100%; max-height:150px; overflow-y:scroll; background: rgba(0,0,0,0.7); color:white; font-family:monospace; font-size:12px; padding:4px; }
</style>
</head>
<body>
<div id="log"></div>
<script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
<script>
const logDiv = document.getElementById('log');
function log(msg){ console.log(msg); logDiv.innerHTML+=msg+"<br>"; logDiv.scrollTop=logDiv.scrollHeight; }

let terrainData, tanks = {}, tankToFollow = null;
let scene, camera, renderer, terrainMeshes = [];

// ---------- INIT ----------
init();
loadFiles();
animate();

function init(){
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 5000);
    camera.position.set(0,200,200);

    const dirLight = new THREE.DirectionalLight(0xffffff,1);
    dirLight.position.set(200,400,200);
    scene.add(dirLight);
    scene.add(new THREE.AmbientLight(0x404040));

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
}

// ---------- LOAD FILES ----------
function loadFiles(){
    fetch('f.json').then(r=>r.json()).then(data=>{
        terrainData = data;
        log("Terrain loaded");
        rebuildTerrain();
    }).catch(e=>log("Error loading terrain: "+e));

    fetch('f2.json').then(r=>r.text()).then(text=>{
        parseTanks(text);
        log("Tank moves loaded");
    }).catch(e=>log("Error loading tanks: "+e));
}

// ---------- PARSE TANKS ----------
function parseTanks(raw){
    const moves = raw.split("|").filter(s=>s.trim());
    moves.forEach(m=>{
        try{
            const parts = m.trim().split(" ");
            const id = parts[0];
            const coords = parts[parts.length-1].replace(/"/g,'').split(",");
            const x = parseFloat(coords[0]);
            const y = parseFloat(coords[1]);
            if(!tanks[id]) tanks[id]={path:[],step:0};
            tanks[id].path.push([x,y]);
        }catch(e){ console.warn("Skipping invalid move", m, e); }
    });
    tankToFollow = Object.keys(tanks)[0];

    const colors = [0xff0000,0x0000ff,0xffff00,0xff00ff];
    let idx=0;
    for(let id in tanks){
        const t = tanks[id];
        const geo = new THREE.BoxGeometry(8,12,8);
        const mat = new THREE.MeshStandardMaterial({color:colors[idx % colors.length]});
        const mesh = new THREE.Mesh(geo, mat);

        // Add coordinate label
        const canvas = document.createElement('canvas'); canvas.width=128; canvas.height=32;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle='white'; ctx.font='24px Arial'; ctx.fillText('0,0',0,24);
        const tex = new THREE.CanvasTexture(canvas);
        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map:tex,transparent:true}));
        sprite.scale.set(20,5,1);
        sprite.position.set(0,12,0);
        mesh.add(sprite);
        t.coordLabel={canvas,ctx,tex,sprite};

        scene.add(mesh);
        t.mesh = mesh;
        idx++;
    }
}

// ---------- BUILD TERRAIN ----------
function rebuildTerrain(){
    if(!terrainData) return;
    terrainMeshes.forEach(m=>{ scene.remove(m); m.geometry.dispose(); m.material.dispose(); });
    terrainMeshes=[];

    const xKeys = Object.keys(terrainData).map(Number).sort((a,b)=>a-b);
    const ySet = new Set();
    xKeys.forEach(x=>Object.keys(terrainData[x]).forEach(y=>ySet.add(Number(y))));
    const yKeys = Array.from(ySet).sort((a,b)=>a-b);

    let startX=0;
    const CHUNK_SIZE=64;
    function buildChunk(){
        if(startX>=xKeys.length) return;
        const endX=Math.min(startX+CHUNK_SIZE,xKeys.length);
        const cols = endX-startX;
        const rows = yKeys.length;
        const geo = new THREE.PlaneGeometry(cols*8, rows*8, cols-1, rows-1);
        const verts = geo.attributes.position.array;
        for(let i=0;i<rows;i++){
            for(let j=0;j<cols;j++){
                const x = xKeys[startX+j];
                const y = yKeys[i];
                verts[3*(i*cols+j)+2] = terrainData[x][y] || 0;
            }
        }
        geo.computeVertexNormals();
        const mat = new THREE.MeshStandardMaterial({color:0x228B22, flatShading:true});
        const mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.x = -Math.PI/2;
        mesh.position.x = startX*8 - xKeys[xKeys.length-1]/2;
        mesh.position.z = -yKeys[yKeys.length-1]/2;
        terrainMeshes.push(mesh);
        scene.add(mesh);
        startX+=CHUNK_SIZE;
        setTimeout(buildChunk,10);
    }
    buildChunk();
}

// ---------- ANIMATE ----------
function animate(){
    requestAnimationFrame(animate);
    if(!terrainData) return;

    const maxX = Math.max(...Object.keys(terrainData));
    const maxY = Math.max(...Object.values(terrainData).map(col=>Math.max(...Object.keys(col))));

    for(let id in tanks){
        const t = tanks[id];
        if(t.mesh && t.step < t.path.length){
            const [x,y] = t.path[t.step];
            const z = terrainData[Math.floor(x)]?.[Math.floor(y)] || 0;
            t.mesh.position.set(x - maxX/2, z+6, y - maxY/2);

            const text = `${Math.round(x)},${Math.round(y)}`;
            const ctx = t.coordLabel.ctx;
            ctx.clearRect(0,0,128,32);
            ctx.fillText(text,0,24);
            t.coordLabel.tex.needsUpdate = true;

            t.step++;
        }
    }

    // Camera follows first tank
    if(tankToFollow && tanks[tankToFollow]){
        const t = tanks[tankToFollow].mesh;
        camera.position.set(t.position.x+150, t.position.y+120, t.position.z+150);
        camera.lookAt(t.position);
    }

    renderer.render(scene,camera);
}

window.addEventListener('resize',()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>