<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Nucleon Atom Chain Reaction</title>
<style>body{margin:0;overflow:hidden;}canvas{display:block;}</style>
</head>
<body>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,20,50);
let cameraTarget = new THREE.Vector3(0,0,0);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const light = new THREE.DirectionalLight(0xffffff,1);
light.position.set(50,50,50);
scene.add(light);
scene.add(new THREE.AmbientLight(0x555555));

class Nucleon {
    constructor(){
        const geom = new THREE.SphereGeometry(0.5,8,8);
        const mat = new THREE.MeshStandardMaterial({color:0xff4444});
        this.mesh = new THREE.Mesh(geom, mat);
        this.mesh.position.set((Math.random()-0.5)*20, (Math.random()-0.5)*20, (Math.random()-0.5)*20);
        this.velocity = new THREE.Vector3((Math.random()-0.5)*2, (Math.random()-0.5)*2, (Math.random()-0.5)*2);
        this.energy = Math.random();
        this.cluster = null;
        scene.add(this.mesh);
    }
    update(delta, boxSize){
        if(!this.cluster){
            this.mesh.position.addScaledVector(this.velocity, delta);
            ['x','y','z'].forEach(axis=>{
                if(this.mesh.position[axis]>boxSize){ this.mesh.position[axis]=boxSize; this.velocity[axis]*=-0.8; }
                if(this.mesh.position[axis]<-boxSize){ this.mesh.position[axis]=-boxSize; this.velocity[axis]*=-0.8; }
            });
        } else {
            this.mesh.position.copy(this.cluster.center);
        }
    }
}

class Atom {
    constructor(nucleons){
        this.nucleons = nucleons;
        this.center = new THREE.Vector3();
        nucleons.forEach(n=>{ n.cluster=this; });
        this.updateCenter();
        this.mesh = new THREE.Mesh(
            new THREE.SphereGeometry(this.nucleons.length*0.6,16,16),
            new THREE.MeshBasicMaterial({color:0x44ff44, transparent:true, opacity:0.3})
        );
        this.mesh.position.copy(this.center);
        scene.add(this.mesh);
    }
    update(){
        this.center.set(0,0,0);
        this.nucleons.forEach(n=>this.center.add(n.mesh.position));
        this.center.divideScalar(this.nucleons.length);
        this.mesh.position.copy(this.center);
    }
}

// --- Electron class ---
class Electron {
    constructor(){
        const geom = new THREE.SphereGeometry(0.2,6,6);
        const mat = new THREE.MeshBasicMaterial({color:0x4444ff});
        this.mesh = new THREE.Mesh(geom, mat);
        this.mesh.position.set((Math.random()-0.5)*20, (Math.random()-0.5)*20, (Math.random()-0.5)*20);
        this.velocity = new THREE.Vector3((Math.random()-0.5)*4,(Math.random()-0.5)*4,(Math.random()-0.5)*4);
        scene.add(this.mesh);
    }
    update(delta, boxSize){
        this.mesh.position.addScaledVector(this.velocity, delta);
        ['x','y','z'].forEach(axis=>{
            if(this.mesh.position[axis]>boxSize){ this.mesh.position[axis]=boxSize; this.velocity[axis]*=-1; }
            if(this.mesh.position[axis]<-boxSize){ this.mesh.position[axis]=-boxSize; this.velocity[axis]*=-1; }
        });
    }
}

// --- Initialize Nucleons & Electrons ---
const nucleons = [];
for(let i=0;i<100;i++) nucleons.push(new Nucleon());
const electrons = [];
for(let i=0;i<20;i++) electrons.push(new Electron());
const atoms = [];

// --- Atom Detection ---
function detectAtoms(){
    const threshold = 2.0;
    nucleons.forEach(n1=>{
        if(n1.cluster) return;
        nucleons.forEach(n2=>{
            if(n1===n2 || n2.cluster) return;
            if(n1.mesh.position.distanceTo(n2.mesh.position)<threshold){
                atoms.push(new Atom([n1,n2]));
            }
        });
    });
}

// --- Electron Interaction ---
function electronCollisions(){
    const energyTransfer=2.0;
    electrons.forEach(e=>{
        nucleons.forEach(n=>{
            if(e.mesh.position.distanceTo(n.mesh.position)<0.5){
                const push = e.velocity.clone().multiplyScalar(energyTransfer);
                if(!n.cluster) n.velocity.add(push);
                // propagate energy to nearby nucleons
                nucleons.forEach(nn=>{
                    if(nn!==n && nn.mesh.position.distanceTo(n.mesh.position)<1.5){
                        nn.velocity.add(push.clone().multiplyScalar(0.5));
                    }
                });
            }
        });
    });
}

// --- Camera Control ---
let targetX=0, targetZ=0, distance=50, rotationY=0, targetRotationY=0;
window.addEventListener('deviceorientation', e=>{
    targetX = (e.gamma||0)*0.5;
    targetZ = -(e.beta||0)*0.5;
}, true);
let isDragging=false, prevX=0;
window.addEventListener('mousedown', e=>{isDragging=true; prevX=e.clientX;});
window.addEventListener('mouseup', ()=>isDragging=false);
window.addEventListener('mousemove', e=>{
    if(isDragging){ const dx=e.clientX-prevX; targetRotationY+=dx*0.005; prevX=e.clientX; }
});

// --- Animation Loop ---
let boxSize = 30;
let lastTime=performance.now();
function animate(){
    requestAnimationFrame(animate);
    const now = performance.now();
    const delta = (now-lastTime)/1000;
    lastTime = now;

    nucleons.forEach(n=>n.update(delta, boxSize));
    electrons.forEach(e=>e.update(delta, boxSize));
    atoms.forEach(a=>a.update());

    detectAtoms();
    electronCollisions();

    rotationY += (targetRotationY - rotationY)*0.05;
    camera.position.x = targetX + Math.sin(rotationY)*distance;
    camera.position.z = targetZ + Math.cos(rotationY)*distance;
    camera.position.y = 20;
    camera.lookAt(cameraTarget);

    renderer.render(scene,camera);
}
animate();

// --- Resize ---
window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>