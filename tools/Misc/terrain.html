<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Rod Magnetization Simulation</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.158/build/three.min.js"></script>
<script>
let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
let renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Rod parameters
const rodLength = 10; // in arbitrary units
const rodWidth = 0.5;
const rodDepth = 0.5;
const Nx = 20, Ny = 4, Nz = 4; // discretization
let dt = 0.01;

// Create rod mesh
let rodGeom = new THREE.BoxGeometry(rodWidth, rodDepth, rodLength);
let rodMat = new THREE.MeshBasicMaterial({color: 0xaaaaaa, wireframe: true});
let rodMesh = new THREE.Mesh(rodGeom, rodMat);
scene.add(rodMesh);
rodMesh.position.z = rodLength/2;

// Camera position
camera.position.set(5,5,15);
camera.lookAt(0,0,rodLength/2);

// B-field grid
let Bz = [];
for(let i=0;i<Nx;i++){
    Bz[i] = [];
    for(let j=0;j<Ny;j++){
        Bz[i][j] = [];
        for(let k=0;k<Nz;k++){
            Bz[i][j][k] = 0;
        }
    }
}

// Simulation parameters
const B0 = 1; // base field
const alpha_growth = 0.05;
const spike_chance = 0.02;
const spike_amplitude = 0.05;
const omega = 20; // oscillation frequency
let frame = 0;

// Visualization: create small cubes for B-field
let cubes = [];
const cubeSize = rodLength/Nz * 0.8;
for(let i=0;i<Nx;i++){
    cubes[i]=[];
    for(let j=0;j<Ny;j++){
        cubes[i][j]=[];
        for(let k=0;k<Nz;k++){
            let geom = new THREE.BoxGeometry(cubeSize,cubeSize,cubeSize);
            let mat = new THREE.MeshBasicMaterial({color:0x0000ff});
            let mesh = new THREE.Mesh(geom, mat);
            mesh.position.set(
                (i-Nx/2)*cubeSize,
                (j-Ny/2)*cubeSize,
                (k-Nz/2)*cubeSize + rodLength/2
            );
            scene.add(mesh);
            cubes[i][j][k] = mesh;
        }
    }
}

// Simulation loop
function animate(){
    requestAnimationFrame(animate);
    frame++;

    let E_total = 0;
    let E_max = 0;

    for(let i=0;i<Nx;i++){
        for(let j=0;j<Ny;j++){
            for(let k=0;k<Nz;k++){
                // Random spike
                if(Math.random()<spike_chance){
                    Bz[i][j][k] += spike_amplitude;
                }

                // Oscillation
                Bz[i][j][k] += spike_amplitude * Math.sin(omega*frame*dt);

                // Feedback growth
                Bz[i][j][k] += alpha_growth * Math.pow(Bz[i][j][k]/B0,2) * dt;

                // Cap at unphysical extremes
                if(Bz[i][j][k]>10) Bz[i][j][k]=10;

                // Update color based on B-field
                let colorVal = Math.min(Bz[i][j][k]/10,1);
                cubes[i][j][k].material.color.setRGB(colorVal,0,1-colorVal);

                // Track energy
                let e = 0.5*Bz[i][j][k]*Bz[i][j][k];
                E_total += e;
                if(e>E_max) E_max = e;
            }
        }
    }

    // Rotate rod slightly for visualization
    rodMesh.rotation.y += 0.002;

    renderer.render(scene, camera);
}

animate();
</script>
</body>
</html>