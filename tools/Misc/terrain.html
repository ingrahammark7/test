<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Atomic Slidey-Gooey Simulation</title>
<style>body{margin:0;overflow:hidden;}canvas{display:block;}</style>
</head>
<body>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';

// === Scene & Renderer ===
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 500);
camera.position.set(0,50,80);
let cameraTarget = new THREE.Vector3(0,0,0);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// === Lights ===
const light = new THREE.DirectionalLight(0xffffff,1.2);
light.position.set(50,50,50);
scene.add(light);
scene.add(new THREE.AmbientLight(0x404040,0.5));

// === Atom parameters ===
const NUM_ATOMS = 100;
const BOX_SIZE = 50;
const atomGeom = new THREE.SphereGeometry(0.5,6,6);
const atomMat = new THREE.MeshStandardMaterial({color:0xffaa00, transparent:true, opacity:0.8});
const atoms = [];

for(let i=0;i<NUM_ATOMS;i++){
    const mesh = new THREE.Mesh(atomGeom, atomMat.clone());
    mesh.position.set(
        (Math.random()-0.5)*BOX_SIZE,
        (Math.random()-0.5)*BOX_SIZE,
        (Math.random()-0.5)*BOX_SIZE
    );
    mesh.userData = {
        velocity: new THREE.Vector3(
            (Math.random()-0.5)*0.5,
            (Math.random()-0.5)*0.5,
            (Math.random()-0.5)*0.5
        ),
        strong: 1,   // strong force remaining
        em: 1        // EM influence
    };
    scene.add(mesh);
    atoms.push(mesh);
}

// === Trails ===
const trailMaterial = new THREE.LineBasicMaterial({color:0xffaa00, transparent:true, opacity:0.2});
const trails = atoms.map(a=>{
    const trailGeom = new THREE.BufferGeometry().setFromPoints([a.position.clone()]);
    const line = new THREE.Line(trailGeom, trailMaterial.clone());
    scene.add(line);
    return line;
});

// === Camera control ===
let targetX=0, targetZ=0, distance=80;
let rotationY=0, targetRotationY=0;

// === Animation Loop ===
function animate(){
    requestAnimationFrame(animate);

    // Atom physics: simple EM vs strong force sliding
    for(let i=0;i<NUM_ATOMS;i++){
        const a = atoms[i];
        // EM repulsion from other atoms
        let force = new THREE.Vector3();
        for(let j=0;j<NUM_ATOMS;j++){
            if(i===j) continue;
            const b = atoms[j];
            const dir = new THREE.Vector3().subVectors(a.position,b.position);
            const dist = dir.length();
            if(dist<0.01) continue;
            dir.normalize();
            const emForce = (a.userData.em*b.userData.em)/(dist*dist);
            force.add(dir.multiplyScalar(emForce));
        }

        // Strong force: pulls back to origin if outside box
        ['x','y','z'].forEach(axis=>{
            if(a.position[axis]>BOX_SIZE/2) force[axis]-=(a.position[axis]-BOX_SIZE/2)*0.1;
            if(a.position[axis]<-BOX_SIZE/2) force[axis]-=(a.position[axis]+BOX_SIZE/2)*0.1;
        });

        // Velocity update
        a.userData.velocity.add(force.multiplyScalar(0.01));
        a.position.add(a.userData.velocity);

        // Trails update
        const line = trails[i];
        const points = line.geometry.attributes.position.array;
        for(let k=0;k<points.length-3;k+=3){
            points[k]=points[k+3];
            points[k+1]=points[k+4];
            points[k+2]=points[k+5];
        }
        points[points.length-3]=a.position.x;
        points[points.length-2]=a.position.y;
        points[points.length-1]=a.position.z;
        line.geometry.attributes.position.needsUpdate=true;
    }

    // Camera smooth rotation & distance
    rotationY += (targetRotationY - rotationY)*0.05;
    camera.position.x = targetX + Math.sin(rotationY)*distance;
    camera.position.z = targetZ + Math.cos(rotationY)*distance;
    camera.position.y = 50;
    camera.lookAt(cameraTarget);

    renderer.render(scene, camera);
}
animate();

// === Mouse drag rotation ===
let isDragging=false, prevX=0;
window.addEventListener('mousedown', e=>{ isDragging=true; prevX=e.clientX; });
window.addEventListener('mouseup', ()=>isDragging=false);
window.addEventListener('mousemove', e=>{
    if(isDragging){ 
        const dx = e.clientX-prevX; 
        targetRotationY += dx*0.005; 
        prevX = e.clientX;
    }
});

// === Touch gestures ===
let touchDistance=0;
window.addEventListener('touchstart', e=>{
    if(e.touches.length === 2){
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        touchDistance = Math.sqrt(dx*dx + dy*dy);
    }
}, false);
window.addEventListener('touchmove', e=>{
    if(e.touches.length===1){
        const dx = e.touches[0].clientX - prevX;
        targetRotationY += dx*0.005;
        prevX = e.touches[0].clientX;
    } else if(e.touches.length===2){
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const newDistance = Math.sqrt(dx*dx + dy*dy);
        const delta = newDistance - touchDistance;
        distance -= delta*0.1;
        distance = Math.max(20,150);
        touchDistance = newDistance;
    }
}, false);

// === Resize ===
window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>