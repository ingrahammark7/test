<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Nucleon Chain Reaction Full</title>
<style>body{margin:0;overflow:hidden;}canvas{display:block;}</style>
</head>
<body>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';

// === Scene & Camera ===
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,30,50);
let cameraTarget = new THREE.Vector3(0,0,0);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// === Lights ===
const dirLight = new THREE.DirectionalLight(0xffffff,1);
dirLight.position.set(50,50,50);
scene.add(dirLight);
scene.add(new THREE.AmbientLight(0x555555));

// === Helper functions ===
function randomVec(scale=1){ return new THREE.Vector3((Math.random()-0.5)*scale,(Math.random()-0.5)*scale,(Math.random()-0.5)*scale); }
function lerpColor(c1,c2,t){ return new THREE.Color(c1.r+(c2.r-c1.r)*t, c1.g+(c2.g-c1.g)*t, c1.b+(c2.b-c1.b)*t); }

// === Nucleon Class ===
class Nucleon{
    constructor(){
        this.mesh = new THREE.Mesh(new THREE.SphereGeometry(0.5,8,8), new THREE.MeshStandardMaterial({color:0xff4444}));
        this.mesh.position.copy(randomVec(20));
        this.velocity = randomVec(2);
        this.energy = Math.random();
        this.cluster = null;

        // trail
        const trailGeom = new THREE.BufferGeometry();
        const positions = new Float32Array(50*3);
        trailGeom.setAttribute('position', new THREE.BufferAttribute(positions,3));
        this.trail = new THREE.Line(trailGeom,new THREE.LineBasicMaterial({color:0xffff44,transparent:true,opacity:0.6}));
        scene.add(this.mesh); scene.add(this.trail);
    }
    update(delta,boxSize,waves){
        if(!this.cluster){
            this.mesh.position.addScaledVector(this.velocity,delta);
            ['x','y','z'].forEach(a=>{
                if(this.mesh.position[a]>boxSize){this.mesh.position[a]=boxSize; this.velocity[a]*=-0.8;}
                if(this.mesh.position[a]<-boxSize){this.mesh.position[a]=-boxSize; this.velocity[a]*=-0.8;}
            });
            waves.forEach(w=>{
                const dist=this.mesh.position.distanceTo(w.center);
                const force = Math.exp(-dist*w.decay)*w.amplitude;
                const dir = this.mesh.position.clone().sub(w.center).normalize();
                this.velocity.addScaledVector(dir,force*delta);
            });
        } else this.mesh.position.copy(this.cluster.center);

        // trail update
        const posArr = this.trail.geometry.attributes.position.array;
        posArr.copyWithin(0,3);
        posArr[posArr.length-3]=this.mesh.position.x;
        posArr[posArr.length-2]=this.mesh.position.y;
        posArr[posArr.length-1]=this.mesh.position.z;
        this.trail.geometry.attributes.position.needsUpdate=true;

        // spin spiral visualization
        const angle = performance.now()*0.001*this.energy*5;
        this.mesh.rotation.x=angle; this.mesh.rotation.y=angle*0.7;

        // color gradient by energy
        const low=new THREE.Color(0xff4444), high=new THREE.Color(0xffdd44);
        this.mesh.material.color = lerpColor(low,high,this.energy);
    }
}

// === Electron Class ===
class Electron{
    constructor(){
        this.mesh=new THREE.Mesh(new THREE.SphereGeometry(0.2,6,6), new THREE.MeshBasicMaterial({color:0x4444ff}));
        this.mesh.position.copy(randomVec(20));
        this.velocity = randomVec(4);
        scene.add(this.mesh);
    }
    update(delta,boxSize){
        this.mesh.position.addScaledVector(this.velocity,delta);
        ['x','y','z'].forEach(a=>{
            if(this.mesh.position[a]>boxSize){this.mesh.position[a]=boxSize; this.velocity[a]*=-1;}
            if(this.mesh.position[a]<-boxSize){this.mesh.position[a]=-boxSize; this.velocity[a]*=-1;}
        });
    }
}

// === Atom Class ===
class Atom{
    constructor(nucleons){
        this.nucleons=nucleons;
        this.center=new THREE.Vector3();
        nucleons.forEach(n=>{n.cluster=this;});
        this.updateCenter();

        this.mesh=new THREE.Mesh(new THREE.SphereGeometry(this.nucleons.length*0.6,16,16),
            new THREE.MeshBasicMaterial({color:0x44ff44,transparent:true,opacity:0.3}));
        scene.add(this.mesh);

        this.waveScale=1;
        this.waveMesh=new THREE.Mesh(new THREE.SphereGeometry(this.nucleons.length*0.6,8,8),
            new THREE.MeshBasicMaterial({color:0x00ffff,transparent:true,opacity:0.1}));
        scene.add(this.waveMesh);
    }
    update(){
        this.center.set(0,0,0);
        this.nucleons.forEach(n=>this.center.add(n.mesh.position));
        this.center.divideScalar(this.nucleons.length);
        this.mesh.position.copy(this.center);

        const avgEnergy = this.nucleons.reduce((a,b)=>a+b.energy,0)/this.nucleons.length;
        this.mesh.material.opacity = 0.2+0.3*avgEnergy;
        this.mesh.scale.setScalar(1+0.3*avgEnergy);

        this.waveScale += 0.2;
        this.waveMesh.scale.setScalar(this.waveScale);
        this.waveMesh.position.copy(this.center);
        this.waveMesh.material.opacity = Math.max(0,0.2-(this.waveScale-1)*0.05);
        if(this.waveMesh.material.opacity<=0) this.waveScale=1;
    }
}

// === Initialize systems ===
const nucleons=[], electrons=[], atoms=[], waves=[];
for(let i=0;i<100;i++) nucleons.push(new Nucleon());
for(let i=0;i<20;i++) electrons.push(new Electron());
let boxSize=30;

// === Atom detection & electron collisions ===
function detectAtoms(){
    const threshold=2.0;
    nucleons.forEach(n1=>{
        if(n1.cluster) return;
        nucleons.forEach(n2=>{
            if(n1===n2 || n2.cluster) return;
            if(n1.mesh.position.distanceTo(n2.mesh.position)<threshold){
                const a=new Atom([n1,n2]);
                atoms.push(a);
                waves.push({center:a.center.clone(),amplitude:0.5,decay:0.5});
            }
        });
    });
}

function electronCollisions(){
    const energyTransfer=2.0;
    electrons.forEach(e=>{
        nucleons.forEach(n=>{
            if(e.mesh.position.distanceTo(n.mesh.position)<0.5){
                const push=e.velocity.clone().multiplyScalar(energyTransfer);
                if(!n.cluster)n.velocity.add(push);
                nucleons.forEach(nn=>{
                    if(nn!==n && nn.mesh.position.distanceTo(n.mesh.position)<1.5) nn.velocity.add(push.clone().multiplyScalar(0.5));
                });
            }
        });
    });
}

// === Camera focus & controls ===
let focusTimer=0, focusAtom=null;
function updateCameraFocus(delta){
    focusTimer-=delta;
    if(focusTimer<=0){ focusTimer=2+Math.random()*3; if(atoms.length>0) focusAtom=atoms[Math.floor(Math.random()*atoms.length)]; }
    if(focusAtom) cameraTarget.lerp(focusAtom.center,0.02);
    else cameraTarget.lerp(new THREE.Vector3(0,0,0),0.02);
}

let targetX=0,targetZ=0,distance=50,rotationY=0,targetRotationY=0;
window.addEventListener('deviceorientation', e=>{
    targetX=(e.gamma||0)*0.5; targetZ=-(e.beta||0)*0.5;
}, true);
let isDragging=false,prevX=0;
window.addEventListener('mousedown', e=>{isDragging=true; prevX=e.clientX;});
window.addEventListener('mouseup',()=>isDragging=false);
window.addEventListener('mousemove', e=>{if(isDragging){const dx=e.clientX-prevX; targetRotationY+=dx*0.005; prevX=e.clientX;}});

// === Animation ===
let lastTime=performance.now();
function animate(){
    requestAnimationFrame(animate);
    const now = performance.now();
    const delta = (now - lastTime) / 1000;
    lastTime = now;

    // Update nucleons, electrons, and atoms
    nucleons.forEach(n => n.update(delta, boxSize, waves));
    electrons.forEach(e => e.update(delta, boxSize));
    atoms.forEach(a => a.update());

    // Detect new atoms and electron collisions
    detectAtoms();
    electronCollisions();
    updateCameraFocus(delta);

    // Smooth camera rotation & position
    rotationY += (targetRotationY - rotationY) * 0.05;
    camera.position.x = targetX + Math.sin(rotationY) * distance;
    camera.position.z = targetZ + Math.cos(rotationY) * distance;
    camera.position.y = 20;
    camera.lookAt(cameraTarget);

    // Render scene
    renderer.render(scene, camera);

    // Optional: adaptively remove old waves for performance
    for (let i = waves.length - 1; i >= 0; i--) {
        waves[i].amplitude *= 0.98;
        if (waves[i].amplitude < 0.01) waves.splice(i, 1);
    }
}

// Start animation
animate();

// === Resize handler ===
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>