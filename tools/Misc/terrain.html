<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Atomic Slide Simulation</title>
<style>
  body { margin: 0; background: #111; overflow: hidden; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>
let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(5,5,10);
camera.lookAt(0,0,0);

let renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Adaptive cube
let cubeSize = Math.max(window.innerWidth, window.innerHeight)/50;
let geometryCube = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
let materialCube = new THREE.MeshBasicMaterial({color:0x4444ff, wireframe:true});
let cube = new THREE.Mesh(geometryCube, materialCube);
scene.add(cube);

// Nucleons
let nucleons=[], velocities=[], trails=[];
const nucleonRadius = 0.1;
const nucleonCountInit = 100;

function initNucleons(count){
    nucleons.forEach(n => scene.remove(n));
    trails.forEach(t => scene.remove(t));
    nucleons=[]; velocities=[]; trails=[];
    for(let i=0;i<count;i++){
        let geometry = new THREE.SphereGeometry(nucleonRadius,16,16);
        let material = new THREE.MeshBasicMaterial({color:0xff4444});
        let sphere = new THREE.Mesh(geometry, material);
        sphere.position.set((Math.random()-0.5)*cubeSize,(Math.random()-0.5)*cubeSize,(Math.random()-0.5)*cubeSize);
        scene.add(sphere);
        nucleons.push(sphere);
        velocities.push(new THREE.Vector3((Math.random()-0.5)*0.05,(Math.random()-0.5)*0.05,(Math.random()-0.5)*0.05));

        // Trails
        let trailGeo = new THREE.BufferGeometry();
        let positions = new Float32Array(300*3);
        trailGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        let trailMat = new THREE.LineBasicMaterial({color:0xffff00, transparent:true, opacity:0.5});
        let trailLine = new THREE.Line(trailGeo, trailMat);
        scene.add(trailLine);
        trails.push({line: trailLine, positions, index:0});
    }
}

initNucleons(nucleonCountInit);

// Physics constants
const EM_STRENGTH = 0.0005;
const STRONG_RANGE = 0.5;
const STRONG_STRENGTH = 0.002;

// Animate loop
function animate(){
    requestAnimationFrame(animate);

    for(let i=0;i<nucleons.length;i++){
        let ni = nucleons[i];
        let vi = velocities[i];

        for(let j=0;j<nucleons.length;j++){
            if(i===j) continue;
            let nj = nucleons[j];
            let dVec = new THREE.Vector3().subVectors(ni.position, nj.position);
            let dist = dVec.length();
            if(dist===0) continue;

            let angle = Math.sin(Date.now()*0.005 + i+j)*0.1;
            let spiral = new THREE.Vector3(dVec.y, -dVec.x, dVec.z).normalize().multiplyScalar(angle);

            let emForce = dVec.clone().multiplyScalar(EM_STRENGTH/(dist*dist)).add(spiral);
            vi.add(emForce);

            if(dist<STRONG_RANGE){
                let strongForce = dVec.clone().multiplyScalar(-STRONG_STRENGTH/(dist*dist)).add(spiral);
                vi.add(strongForce);
            }
        }

        ni.position.add(vi);

        ["x","y","z"].forEach(a=>{
            if(Math.abs(ni.position[a])>cubeSize/2-nucleonRadius){
                vi[a]*=-0.8;
                ni.position[a]=Math.sign(ni.position[a])*(cubeSize/2-nucleonRadius);
            }
        });

        // Trails
        let t = trails[i];
        t.positions.copyWithin(3,0,t.positions.length-3);
        t.positions[0]=ni.position.x;
        t.positions[1]=ni.position.y;
        t.positions[2]=ni.position.z;
        t.line.geometry.attributes.position.needsUpdate = true;
    }

    renderer.render(scene,camera);
}

animate();

// Accelerometer / device orientation
window.addEventListener('deviceorientation', e=>{
    let beta = e.beta || 0;   // front-back tilt [-180,180]
    let gamma = e.gamma || 0; // left-right tilt [-90,90]

    camera.rotation.x = THREE.MathUtils.degToRad(beta-90);
    camera.rotation.y = THREE.MathUtils.degToRad(gamma);
});

// Touch fallback rotation
let lastX, lastY;
document.addEventListener('touchstart', e=>{
    lastX=e.touches[0].clientX;
    lastY=e.touches[0].clientY;
});
document.addEventListener('touchmove', e=>{
    let dx = e.touches[0].clientX - lastX;
    let dy = e.touches[0].clientY - lastY;
    lastX = e.touches[0].clientX;
    lastY = e.touches[0].clientY;
    camera.rotation.y -= dx*0.005;
    camera.rotation.x -= dy*0.005;
});

// Resize
window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>