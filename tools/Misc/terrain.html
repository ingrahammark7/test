<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Dogfight Visuals Upgrade</title>
<style>
  body { margin: 0; overflow: hidden; }
  canvas { display: block; }
  #hud {
    position: absolute; top: 10px; left: 10px; 
    color: #eee; font-family: monospace; 
    background: rgba(0,0,0,0.5); padding: 6px 10px; 
    border-radius: 6px; user-select:none; z-index: 10;
  }
</style>
</head>
<body>
<div id="hud">Camera: Overview<br>Missiles: 0</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
<script>
(() => {
  const scene = new THREE.Scene();

  // Skybox gradient - large sphere with gradient material
  const skyGeo = new THREE.SphereGeometry(500, 32, 15);
  const skyMat = new THREE.ShaderMaterial({
    side: THREE.BackSide,
    uniforms: {
      topColor: { value: new THREE.Color(0x87CEEB) },
      bottomColor: { value: new THREE.Color(0xffffff) }
    },
    vertexShader: `
      varying vec3 vWorldPosition;
      void main() {
        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
        vWorldPosition = worldPosition.xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
      }
    `,
    fragmentShader: `
      uniform vec3 topColor;
      uniform vec3 bottomColor;
      varying vec3 vWorldPosition;
      void main() {
        float h = normalize(vWorldPosition).y * 0.5 + 0.5;
        gl_FragColor = vec4(mix(bottomColor, topColor, h), 1.0);
      }
    `
  });
  const sky = new THREE.Mesh(skyGeo, skyMat);
  scene.add(sky);

  // Add a very subtle cloud layer - semi-transparent planes with white blurred circles
  const cloudTex = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/cloud.png');
  const clouds = [];
  for(let i=0; i<20; i++) {
    const cloudMat = new THREE.SpriteMaterial({ map: cloudTex, transparent: true, opacity: 0.15 });
    const cloud = new THREE.Sprite(cloudMat);
    cloud.position.set(
      (Math.random()-0.5)*200,
      40 + Math.random()*20,
      (Math.random()-0.5)*200
    );
    cloud.scale.set(20,20,1);
    scene.add(cloud);
    clouds.push(cloud);
  }

  // Camera setup
  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 40, 60);

  const renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lighting
  const dirLight = new THREE.DirectionalLight(0xffffff, 1);
  dirLight.position.set(30, 50, 30);
  scene.add(dirLight);
  scene.add(new THREE.AmbientLight(0x404040));

  const grid = new THREE.GridHelper(100, 20, 0x222222, 0x444444);
  scene.add(grid);

  // Jet builder with engine glow (emissive sphere)
  function createJet(color=0xff0000) {
    const jet = new THREE.Group();
    const material = new THREE.MeshStandardMaterial({color, roughness: 0.5, metalness: 0.7});

    const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.4,5,12), material);
    body.rotation.z = Math.PI/2;
    jet.add(body);

    const nose = new THREE.Mesh(new THREE.ConeGeometry(0.4,1,12), material);
    nose.rotation.z = Math.PI/2;
    nose.position.x = 2.5;
    jet.add(nose);

    const wingGeo = new THREE.BoxGeometry(3,0.1,0.6);
    const wingL = new THREE.Mesh(wingGeo, material);
    const wingR = new THREE.Mesh(wingGeo, material);
    wingL.position.set(0,0.2,-0.7);
    wingR.position.set(0,0.2,0.7);
    jet.add(wingL, wingR);

    const tail = new THREE.Mesh(new THREE.BoxGeometry(0.1,1,0.6), material);
    tail.position.set(-2.4,0.6,0);
    jet.add(tail);

    const tailWingL = new THREE.Mesh(wingGeo, material);
    const tailWingR = new THREE.Mesh(wingGeo, material);
    tailWingL.scale.set(0.5,1,0.5);
    tailWingR.scale.set(0.5,1,0.5);
    tailWingL.position.set(-2.5,0.1,-0.6);
    tailWingR.position.set(-2.5,0.1,0.6);
    jet.add(tailWingL, tailWingR);

    const engine = new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,0.5,8),
      new THREE.MeshStandardMaterial({color: 0xff6600, emissive: 0xff4400, emissiveIntensity: 3}));
    engine.rotation.z = Math.PI/2;
    engine.position.set(-2.8,0,0);
    jet.add(engine);

    // Engine glow light
    const glow = new THREE.PointLight(0xff6600, 1, 4);
    glow.position.copy(engine.position);
    jet.add(glow);

    return jet;
  }

  // Smoke trail particle system for missiles
  class SmokeParticle {
    constructor(position) {
      const geo = new THREE.SphereGeometry(0.07, 6, 6);
      const mat = new THREE.MeshBasicMaterial({color: 0xaaaaaa, transparent: true, opacity: 0.5});
      this.mesh = new THREE.Mesh(geo, mat);
      this.mesh.position.copy(position);
      this.life = 20;
      scene.add(this.mesh);
    }
    update() {
      this.life--;
      this.mesh.position.y += 0.01;
      this.mesh.material.opacity = this.life / 20 * 0.5;
      if(this.life <= 0) {
        scene.remove(this.mesh);
        return false;
      }
      return true;
    }
  }

  // Missile class with smoke trail
  class Missile {
    constructor(position, direction, owner) {
      this.speed = 0.6;
      this.owner = owner;
      this.life = 150;

      this.mesh = new THREE.Mesh(
        new THREE.CylinderGeometry(0.05, 0.05, 1, 6),
        new THREE.MeshBasicMaterial({color: 0xffff00})
      );
      this.mesh.rotation.z = Math.PI / 2;
      this.mesh.position.copy(position);
      scene.add(this.mesh);

      this.velocity = direction.clone().multiplyScalar(this.speed);
      this.isDestroyed = false;

      this.smokeParticles = [];
    }

    update() {
      this.mesh.position.add(this.velocity);
      this.life--;

      // Add smoke particle
      if(this.life % 2 === 0) {
        this.smokeParticles.push(new SmokeParticle(this.mesh.position.clone()));
      }
      this.smokeParticles = this.smokeParticles.filter(p => p.update());

      if (this.life <= 0) this.destroy();
    }

    destroy() {
      if(this.isDestroyed) return;
      this.isDestroyed = true;
      scene.remove(this.mesh);

      // Explosion particles
      const explosionCount = 20;
      for(let i=0; i<explosionCount; i++) {
        const spark = new THREE.Mesh(
          new THREE.SphereGeometry(0.1, 6, 6),
          new THREE.MeshBasicMaterial({color: 0xffaa00, transparent: true, opacity: 0.8})
        );
        spark.position.copy(this.mesh.position);
        spark.velocity = new THREE.Vector3(
          (Math.random()-0.5)*0.4,
          (Math.random()-0.5)*0.4,
          (Math.random()-0.5)*0.4
        );
        spark.life = 15 + Math.floor(Math.random()*15);
        scene.add(spark);
        explosions.push(spark);
      }
    }
  }

  const jets = [];
  const missiles = [];
  const explosions = [];

  const maxSpeed = 0.15;
  const maxForce = 0.02;

  for(let i=0; i<6; i++) {
    const color = i < 3 ? 0xff0000 : 0x0000ff;
    const jet = createJet(color);
    jet.position.set(i*5 - 10, 5, 0);
    jet.velocity = new THREE.Vector3(0, 0, 0.05);
    jet.isAlive = true;
    jet.cooldown = 0;
    scene.add(jet);
    jets.push(jet);
  }

  function updateJetAI(jet) {
    if (!jet.isAlive) return;

    // Find closest enemy
    let closestEnemy = null;
    let closestDist = Infinity;
    jets.forEach(other => {
      if (other !== jet && other.isAlive && ((jet.children[0].material.color.getHex() !== other.children[0].material.color.getHex()))) {
        const dist = jet.position.distanceTo(other.position);
        if (dist < closestDist) {
          closestDist = dist;
          closestEnemy = other;
        }
      }
    });
    if (!closestEnemy) return;

    // Avoid crowding - simple repulsion from other jets
    const avoidForce = new THREE.Vector3();
    jets.forEach(other => {
      if (other !== jet && other.isAlive) {
        const dist = jet.position.distanceTo(other.position);
        if(dist < 3) {
          let diff = jet.position.clone().sub(other.position);
          diff.divideScalar(dist*dist);
          avoidForce.add(diff);
        }
      }
    });

    // Steering toward enemy + avoid force
    const desired = closestEnemy.position.clone().sub(jet.position).normalize().multiplyScalar(maxSpeed);
    const steer = desired.sub(jet.velocity).add(avoidForce.multiplyScalar(0.5));
    steer.clampLength(0, maxForce);

    // Bank & roll based on steer
    const targetAngle = Math.atan2(steer.z, steer.x);
    jet.rotation.z = THREE.MathUtils.lerp(jet.rotation.z, -steer.z * 5, 0.1);
    jet.rotation.x = THREE.MathUtils.lerp(jet.rotation.x, steer.y * 5, 0.1);

    jet.velocity.add(steer);
    jet.velocity.clampLength(0, maxSpeed);

    jet.position.add(jet.velocity);

    if(jet.velocity.lengthSq() > 0.0001) {
      const lookPos = jet.position.clone().add(jet.velocity);
      jet.lookAt(lookPos);
    }

    // Fire missile if cooldown 0 and enemy close
    if(jet.cooldown <= 0 && closestDist < 25) {
      const missilePos = jet.position.clone().add(jet.velocity.clone().normalize().multiplyScalar(2));
      const missileDir = jet.velocity.clone().normalize();
      missiles.push(new Missile(missilePos, missileDir, jet));
      jet.cooldown = 50;
    } else {
      jet.cooldown--;
    }
  }

  function updateMissiles() {
    for(let i=missiles.length-1; i>=0; i--) {
      const missile = missiles[i];
      if(missile.isDestroyed) {
        missiles.splice(i, 1);
        continue;
      }
      missile.update();

      jets.forEach(jet => {
        if(jet !== missile.owner && jet.isAlive && missile.mesh.position.distanceTo(jet.position) < 1.5) {
          jet.isAlive = false;
          scene.remove(jet);
          missile.destroy();
        }
      });
    }
  }

  function updateExplosions() {
    for(let i=explosions.length-1; i>=0; i--) {
      const spark = explosions[i];
      spark.position.add(spark.velocity);
      spark.material.opacity -= 0.05;
      spark.life--;
      if(spark.life <= 0 || spark.material.opacity <= 0) {
        scene.remove(spark);
        explosions.splice(i, 1);
      }
    }
  }

  // Camera modes: 0 overview, 1 follow jet
  let camMode = 0;
  let camFocusIndex = 0;

  function updateCamera() {
    if(camMode === 0) {
      camera.position.set(0, 40, 60);
      camera.lookAt(0,0,0);
    } else {
      const jet = jets[camFocusIndex];
      if(jet && jet.isAlive) {
        const offset = new THREE.Vector3(-5, 3, 0);
        offset.applyQuaternion(jet.quaternion);
        camera.position.copy(jet.position).add(offset);
        camera.lookAt(jet.position);
      } else {
        camFocusIndex = (camFocusIndex + 1) % jets.length;
      }
    }
  }

  // HUD updates
  const hud = document.getElementById('hud');
  function updateHUD() {
    hud.innerHTML = `Camera: ${camMode === 0 ? 'Overview' : 'Follow Jet'}<br>Missiles: ${missiles.length}`;
  }

  window.addEventListener('click', () => {
    camMode = (camMode + 1) % 2;
  });

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  function animate() {
    requestAnimationFrame(animate);

    jets.forEach(jet => updateJetAI(jet));
    updateMissiles();
    updateExplosions();
    updateCamera();
    updateHUD();

    // Animate clouds slowly
    clouds.forEach(c => c.position.x += 0.005);

    renderer.render(scene, camera);
  }

  animate();

})();
</script>
</body>
</html>