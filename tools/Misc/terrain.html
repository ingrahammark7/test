<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Tank on Terrain — Smooth Movement</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html, body { height: 100%; margin: 0; }
  canvas { display: block; }
  #overlay {
    position: fixed; right: 8px; top: 8px;
    width: 320px; background: rgba(0,0,0,0.6);
    color: #fff; font-family: monospace;
    font-size: 12px; padding: 8px; border-radius: 6px;
  }
  #controls {
    position: fixed; left: 8px; top: 8px;
    background: rgba(0,0,0,0.6);
    color: #fff;
    padding: 6px;
    border-radius: 6px;
    font-family: monospace;
    font-size: 12px;
  }
  #controls input { vertical-align: middle; }
</style>
</head>
<body>
<div id="controls">
  Speed: <input type="range" id="speedSlider" min="0.1" max="10" step="0.1" value="1">
  <span id="speedVal">1</span>
</div>
<div id="overlay">Loading files…</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
<script>
(async function(){
  const overlay = document.getElementById('overlay');

  try {
    const [terrainResp, movesResp] = await Promise.all([
      fetch('f.json'),
      fetch('f2.json')
    ]);
    if(!terrainResp.ok) throw new Error('Failed loading f.json');
    if(!movesResp.ok) throw new Error('Failed loading f2.json');

    const terrainData = await terrainResp.json();
    const movesText = await movesResp.text();
    overlay.innerText = 'Files loaded — building scene...';
    buildScene(terrainData, movesText);
  } catch(err) {
    overlay.innerText = 'Error loading files: ' + err;
    console.error(err);
  }

  function buildScene(terrainData, movesText) {
    const xKeys = Object.keys(terrainData).map(Number).sort((a,b)=>a-b);
    const zSet = new Set();
    xKeys.forEach(x => {
      Object.keys(terrainData[String(x)]||{}).forEach(z => zSet.add(Number(z)));
    });
    const zKeys = Array.from(zSet).sort((a,b)=>a-b);
    const minX = xKeys[0], maxX = xKeys[xKeys.length-1];
    const minZ = zKeys[0], maxZ = zKeys[zKeys.length-1];
    const centerX = (minX+maxX)/2, centerZ = (minZ+maxZ)/2;
    const cols = xKeys.length, rows = zKeys.length;

    // Terrain geometry
    const geom = new THREE.BufferGeometry();
    const pos = new Float32Array(cols*rows*3);
    let pi=0;
    for(let i=0;i<rows;i++){
      for(let j=0;j<cols;j++){
        const worldX = xKeys[j], worldZ = zKeys[i];
        const h = terrainData[String(worldX)]?.[String(worldZ)]||0;
        pos[pi++] = worldX; pos[pi++] = h; pos[pi++] = worldZ;
      }
    }
    geom.setAttribute('position', new THREE.BufferAttribute(pos,3));
    const idxs = [];
    for(let i=0;i<rows-1;i++){
      for(let j=0;j<cols-1;j++){
        const a=i*cols+j, b=a+1, c=a+cols, d=c+1;
        idxs.push(a,c,b,b,c,d);
      }
    }
    geom.setIndex(idxs);
    geom.computeVertexNormals();

    const mat = new THREE.MeshStandardMaterial({color:0x228B22, flatShading:true});
    const terrainMesh = new THREE.Mesh(geom, mat);
    terrainMesh.position.set(-centerX,0,-centerZ);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);
    scene.add(terrainMesh);
    const dir = new THREE.DirectionalLight(0xffffff,1);
    dir.position.set(centerX+200,400,centerZ+200);
    scene.add(dir);
    scene.add(new THREE.AmbientLight(0x404040));

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio||1);
    renderer.setSize(window.innerWidth,window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,5000);

    // Parse tank moves
    const rawMoves = movesText.split('|').filter(s=>s.trim());
    const tanks = {};
    rawMoves.forEach(token=>{
      const m = token.trim();
      if(!m) return;
      const match = m.match(/(-?\d+)\s*,\s*(-?\d+)\s*$/);
      if(!match) return;
      const id = m.split(' ')[0], x=Number(match[1]), z=Number(match[2]);
      if(!tanks[id]) tanks[id]={path:[]};
      tanks[id].path.push([x,z]);
    });

    function findNearest(sorted,v){
      let lo=0,hi=sorted.length-1;
      if(v<=sorted[0]) return sorted[0];
      if(v>=sorted[hi]) return sorted[hi];
      while(lo<=hi){
        const mid=Math.floor((lo+hi)/2);
        if(sorted[mid]===v) return v;
        if(sorted[mid]<v) lo=mid+1; else hi=mid-1;
      }
      const a=sorted[Math.max(0,lo-1)], b=sorted[Math.min(sorted.length-1,lo)];
      return (Math.abs(a-v)<=Math.abs(b-v))?a:b;
    }

    // Tanks
    const colors=[0xff0000,0x0000ff,0xffff00,0xff00ff,0x00ffff,0xff8800];
    let colorIdx=0;
    for(const id in tanks){
      const t=tanks[id];
      const geo=new THREE.BoxGeometry(6,4,6);
      const matTank = new THREE.MeshStandardMaterial({color:colors[colorIdx++%colors.length]});
      const mesh = new THREE.Mesh(geo,matTank);
      mesh.position.set(0,2,0);
      scene.add(mesh);
      t.mesh=mesh;

      t.worldPath = t.path.map(([tx,tz])=>{
        const nx=findNearest(xKeys,tx), nz=findNearest(zKeys,tz);
        const h = terrainData[String(nx)]?.[String(nz)]||0;
        return {tx,nz,x:nx-centerX,y:h+2,z:nz-centerZ};
      });

      if(t.worldPath.length){
        const p0 = t.worldPath[0];
        mesh.position.set(p0.x,p0.y,p0.z);
      }
      t.currentIndex=0;
      t.progress=0;
    }

    // Camera initial
    const firstId = Object.keys(tanks)[0];
    if(firstId){
      const f = tanks[firstId].mesh;
      camera.position.set(f.position.x+60, f.position.y+80, f.position.z+120);
      camera.lookAt(f.position);
    }

    // Speed slider
    let speed = 1;
    const speedSlider = document.getElementById('speedSlider');
    const speedVal = document.getElementById('speedVal');
    speedSlider.addEventListener('input', ()=>{
      speed = parseFloat(speedSlider.value);
      speedVal.innerText = speed.toFixed(1);
    });

    // Frame-rate independent animation
    let lastTime = performance.now();
    function animate(){
      requestAnimationFrame(animate);
      const now = performance.now();
      const delta = (now - lastTime)/16.67; 
      lastTime = now;

      // >>>>>>> SMOOTH MOVEMENT SYSTEM <<<<<<<<
      for(const id in tanks){
        const t = tanks[id];
        const wp = t.worldPath;
        if(wp.length < 2) continue;

        // Precompute segment lengths
        if(!t._len){
          t._len = [];
          for(let i=0;i<wp.length-1;i++){
            const dx = wp[i+1].x - wp[i].x;
            const dy = wp[i+1].y - wp[i].y;
            const dz = wp[i+1].z - wp[i].z;
            t._len[i] = Math.sqrt(dx*dx + dy*dy + dz*dz);
          }
        }

        let remaining = speed * delta; // movement per frame

        while(remaining > 0 && t.currentIndex < wp.length-1){
          const segLen = t._len[t.currentIndex];
          const distLeft = segLen * (1 - t.progress);

          if(remaining >= distLeft){
            remaining -= distLeft;
            t.currentIndex++;
            t.progress = 0;
          } else {
            t.progress += remaining / segLen;
            remaining = 0;
          }
        }

        const cur = wp[t.currentIndex];
        const nxt = wp[Math.min(t.currentIndex+1, wp.length-1)];

        const px = THREE.MathUtils.lerp(cur.x, nxt.x, t.progress);
        const py = THREE.MathUtils.lerp(cur.y, nxt.y, t.progress);
        const pz = THREE.MathUtils.lerp(cur.z, nxt.z, t.progress);

        t.mesh.position.set(px,py,pz);
      }

      // Smooth camera follow
      if(firstId){
        const f = tanks[firstId].mesh;
        const desired = new THREE.Vector3(
          f.position.x+60,
          f.position.y+80,
          f.position.z+120
        );
        camera.position.lerp(desired,0.1);
        camera.lookAt(f.position);
      }

      renderer.render(scene,camera);
    }
    animate();

    window.addEventListener('resize', ()=>{
      renderer.setSize(window.innerWidth,window.innerHeight);
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
    });

    overlay.style.display='none';
  }
})();
</script>
</body>
</html>