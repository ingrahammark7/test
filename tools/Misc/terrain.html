<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Sun-like Dynamic Plasma Axions</title>
<style>
  body { margin:0; overflow:hidden; background:#000; color:#fff; }
  #debug {
    position: fixed; top: 5px; left: 5px;
    font-family: monospace;
    background: rgba(0,0,0,0.7);
    padding: 6px;
    border-radius: 4px;
    max-width: 350px;
    max-height: 180px;
    overflow: auto;
    z-index: 1000;
  }
</style>
</head>
<body>
<div id="debug">Debug:<br></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>
const debugDiv = document.getElementById('debug');
function log(msg) {
  console.log(msg);
  debugDiv.innerHTML += msg + '<br>';
}
log('Initializing Sun-like Plasma Axion Simulation...');

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.z = 25;

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  log(`Resize: ${window.innerWidth} x ${window.innerHeight}`);
});

const triSize = 0.1;
const triGeom = new THREE.BufferGeometry();
const vertices = new Float32Array([
  0, triSize / Math.sqrt(3), 0,
  -triSize / 2, -triSize / (2 * Math.sqrt(3)), 0,
  triSize / 2, -triSize / (2 * Math.sqrt(3)), 0
]);
triGeom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
triGeom.computeVertexNormals();

const AXION_COUNT = 1000;
const axions = [];

const wavelength = 1.1;
const angularFreq = 3.0;
const interactionRadius = 3.0;

// Simulate a rough magnetic dipole field (simplified)
function magneticField(pos) {
  // Simple dipole-like vector field around origin
  // B = (3r(mÂ·r)/r^5 - m/r^3), approximate with m along Y
  const m = new THREE.Vector3(0, 1, 0);
  const r = pos.clone();
  const rLen = r.length() + 0.001;
  const mr = m.dot(r);
  let B = r.clone().multiplyScalar(3 * mr / Math.pow(rLen,5));
  B.sub(m.clone().multiplyScalar(1 / Math.pow(rLen,3)));
  return B.normalize();
}

// Convection cell function - push up/down in latitudinal bands
function convectionVelocity(pos, time) {
  // Bands along Y axis, sinusoidal up/down flows
  const bandWidth = 2.0;
  let lat = pos.y;
  let cycle = Math.sin(time + lat * Math.PI) * 0.03;
  return new THREE.Vector3(0, cycle, 0);
}

// Color gradient from core (hot) to edge (cool)
function tempHue(distance) {
  // 0 at core => yellowish, 1 at edge => blueish
  return THREE.MathUtils.lerp(0.15, 0.6, THREE.MathUtils.clamp(distance / 7, 0, 1));
}

function randomInSphere(radius) {
  let u = Math.random();
  let v = Math.random();
  let theta = u * 2 * Math.PI;
  let phi = Math.acos(2 * v - 1);
  let r = Math.cbrt(Math.random()) * radius;
  let sinPhi = Math.sin(phi);
  return new THREE.Vector3(
    r * sinPhi * Math.cos(theta),
    r * sinPhi * Math.sin(theta),
    r * Math.cos(phi)
  );
}

for(let i=0; i<AXION_COUNT; i++) {
  const mesh = new THREE.Mesh(triGeom, new THREE.MeshBasicMaterial({
    color: new THREE.Color(),
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.75,
    blending: THREE.AdditiveBlending
  }));
  mesh.position.copy(randomInSphere(7));
  
  mesh.userData.phaseOffset = Math.random() * 2 * Math.PI;
  mesh.userData.wavelength = wavelength * (0.8 + 0.4 * Math.random());
  mesh.userData.rotAxis = new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize();
  mesh.userData.rotSpeed = 0.06 * (0.7 + Math.random());
  
  scene.add(mesh);
  axions.push(mesh);
}

let isDragging = false;
let prevMouse = {x:0,y:0};
let rotation = {x:0,y:0};
let zoom = 25;

function onPointerDown(e) {
  isDragging = true;
  prevMouse.x = e.clientX || e.touches[0].clientX;
  prevMouse.y = e.clientY || e.touches[0].clientY;
}
function onPointerMove(e) {
  if(!isDragging) return;
  const x = e.clientX || e.touches[0].clientX;
  const y = e.clientY || e.touches[0].clientY;
  const dx = x - prevMouse.x;
  const dy = y - prevMouse.y;
  rotation.y += dx * 0.02;
  rotation.x += dy * 0.02;
  rotation.x = Math.min(Math.max(rotation.x, -Math.PI/2), Math.PI/2);
  prevMouse.x = x;
  prevMouse.y = y;
}
function onPointerUp() {
  isDragging = false;
}
function onWheel(e) {
  zoom += e.deltaY * 0.03;
  zoom = Math.min(Math.max(zoom, 12), 45);
}
function onTouchPinch(e) {
  if(e.touches.length === 2) {
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if(typeof onTouchPinch.lastDist !== 'undefined') {
      const diff = onTouchPinch.lastDist - dist;
      zoom += diff * 0.05;
      zoom = Math.min(Math.max(zoom, 12), 45);
    }
    onTouchPinch.lastDist = dist;
  }
}

renderer.domElement.style.touchAction = 'none';
renderer.domElement.addEventListener('pointerdown', onPointerDown);
renderer.domElement.addEventListener('pointermove', onPointerMove);
renderer.domElement.addEventListener('pointerup', onPointerUp);
renderer.domElement.addEventListener('pointerleave', onPointerUp);
renderer.domElement.addEventListener('wheel', onWheel, {passive:false});
renderer.domElement.addEventListener('touchmove', onTouchPinch, {passive:false});

function distSq(a, b) {
  return (a.x-b.x)**2 + (a.y-b.y)**2 + (a.z-b.z)**2;
}

function animate(time=0) {
  requestAnimationFrame(animate);
  const t = time * 0.001;

  for(let i=0; i<AXION_COUNT; i++) {
    const ax = axions[i];
    
    const distToCenter = ax.position.length();

    // Rotate with speed influenced by local "temperature" (hotter near center)
    let tempFactor = THREE.MathUtils.clamp(1 - distToCenter / 7, 0, 1);
    ax.rotateOnAxis(ax.userData.rotAxis, ax.userData.rotSpeed * (1 + 3 * tempFactor));

    // Phase sync fast, weighted by proximity (stronger near core)
    let phaseSum = 0;
    let phaseCount = 0;
    for(let j=0; j<AXION_COUNT; j++) {
      if(j === i) continue;
      const dist = ax.position.distanceTo(axions[j].position);
      if(dist > interactionRadius) continue;
      const weight = 1 - dist / interactionRadius;
      phaseSum += axions[j].userData.phaseOffset * weight;
      phaseCount += weight;
    }
    if(phaseCount > 0) {
      const avgPhase = phaseSum / phaseCount;
      ax.userData.phaseOffset += 0.12 * (avgPhase - ax.userData.phaseOffset);
    }

    // Wave interference sum (same but smaller radius for better performance)
    let sumWave = 0;
    const posA = ax.position;
    const phaseOffset = ax.userData.phaseOffset;
    const k = 2*Math.PI / ax.userData.wavelength;
    const omega = angularFreq;
    for(let j=0; j<AXION_COUNT; j++) {
      if(j === i) continue;
      const posB = axions[j].position;
      const dSq = distSq(posA, posB);
      if(dSq > interactionRadius*interactionRadius) continue;
      const dist = Math.sqrt(dSq) + 0.0001;
      const phase = k*dist - omega*t + axions[j].userData.phaseOffset;
      sumWave += Math.cos(phase) / dist;
    }
    sumWave += Math.cos(- omega*t + phaseOffset);

    const intensity = THREE.MathUtils.clamp((sumWave + 3) / 6, 0, 1);

    // Magnetic field swirling force (curl around Y axis dipole)
    const B = magneticField(ax.position).multiplyScalar(0.03);
    ax.position.add(B);

    // Convection velocity pushes Y-axis cycling plasma flow
    const conv = convectionVelocity(ax.position, t);
    ax.position.add(conv);

    // Movement force from phase differences, stronger near center
    let force = new THREE.Vector3(0,0,0);
    for(let j=0; j<AXION_COUNT; j++) {
      if(j === i) continue;
      const other = axions[j];
      const dist = ax.position.distanceTo(other.position);
      if(dist > interactionRadius) continue;
      let diffPhaseCos = Math.cos(ax.userData.phaseOffset) - Math.cos(other.userData.phaseOffset);
      let dir = new THREE.Vector3().subVectors(other.position, ax.position).normalize();
      let distWeight = 1 - dist / interactionRadius;
      force.addScaledVector(dir, diffPhaseCos * distWeight / (dist * dist));
    }
    force.multiplyScalar(0.04 * tempFactor); // hotter core stronger force

    // Add some random noise bursts (flare-like events)
    if(Math.random() < 0.001 * tempFactor) {
      force.add(new THREE.Vector3(
        (Math.random()-0.5)*0.02,
        (Math.random()-0.5)*0.02,
        (Math.random()-0.5)*0.02
      ));
      // Also boost phase for flare
      ax.userData.phaseOffset += Math.random() * Math.PI * 0.5;
    }

    ax.position.add(force);

    // Boundary containment (radius ~7)
    if(ax.position.length() > 7) {
      ax.position.multiplyScalar(0.97);
    }

    // Scale pulsing bigger near core to simulate hotter brightness
    let scale = 0.4 + 1.4 * intensity * tempFactor;
    ax.scale.setScalar(scale);

    // Color gradient from yellow (core) to blue (edge), cycling hue and brightness with intensity
    let hueBase = tempHue(distToCenter);
    let hue = (hueBase + t * 0.6 + ax.userData.phaseOffset / (2*Math.PI)) % 1.0;
    let sat = 1.0;
    let light = 0.4 + 0.7 * intensity * tempFactor;
    ax.material.color.setHSL(hue, sat, light);
  }

  camera.position.x = zoom * Math.sin(rotation.y) * Math.cos(rotation.x);
  camera.position.y = zoom * Math.sin(rotation.x);
  camera.position.z = zoom * Math.cos(rotation.y) * Math.cos(rotation.x);
  camera.lookAt(0,0,0);

  renderer.render(scene, camera);
}

log('Starting Sun-like plasma animation...');
animate();
</script>
</body>
</html>