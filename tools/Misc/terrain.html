<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>APFSDS Slidey-Gooey 3D</title>
<style>
  body { margin: 0; overflow: hidden; background-color: #000; }
  #info { position: absolute; top: 10px; left: 10px; color: white; font-family: sans-serif; }
</style>
</head>
<body>
<div id="info">
  <div id="penetration">Cumulative Penetration: 0 cm</div>
  <div id="time">Time: 0 s</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

<script>
  // ---- Scene Setup ----
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
  camera.position.set(0, 50, 150);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // ---- Lighting ----
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);
  const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
  directionalLight.position.set(50, 100, 50);
  scene.add(directionalLight);

  // ---- Parameters ----
  const z_tip = 5;
  const z_contagion = 70;
  const z_residual = 2;
  const total_depth = z_tip + z_contagion + z_residual;
  const radius = 2;
  const frames = 200;
  let frame = 0;

  // ---- Cylinder Geometry ----
  const geometry = new THREE.CylinderGeometry(radius, radius, total_depth, 64, 1, true);
  geometry.rotateX(Math.PI / 2);

  const colors = [];
  for (let i = 0; i < geometry.attributes.position.count; i++) {
    colors.push(1, 1, 1);
  }
  geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

  const material = new THREE.MeshStandardMaterial({
    vertexColors: true,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.8
  });

  const cylinder = new THREE.Mesh(geometry, material);
  scene.add(cylinder);

  // ---- Custom Camera Controls ----
  let isMouseDown = false;
  let lastMouseX = 0;
  let lastMouseY = 0;
  let rotX = 0;
  let rotY = 0;
  let zoom = 1;

  window.addEventListener('mousedown', (e) => { isMouseDown = true; lastMouseX = e.clientX; lastMouseY = e.clientY; });
  window.addEventListener('mouseup', () => { isMouseDown = false; });
  window.addEventListener('mousemove', (e) => {
    if (!isMouseDown) return;
    const dx = e.clientX - lastMouseX;
    const dy = e.clientY - lastMouseY;
    rotY += dx * 0.01;
    rotX += dy * 0.01;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
  });
  window.addEventListener('wheel', (e) => { zoom *= 1 + e.deltaY * -0.001; });

  // ---- Animation ----
  function animate() {
    requestAnimationFrame(animate);

    // Slidey-gooey contagion effect
    const attr = geometry.attributes.color;
    for (let i = 0; i < attr.count; i++) {
      const zPos = geometry.attributes.position.getZ(i) + total_depth/2; // 0 at tip
      let tFrac = frame / frames;
      let colorVal = 1;
      if (zPos <= z_tip) colorVal = 0.3; // tip
      else if (zPos <= z_tip + z_contagion * tFrac) colorVal = 0.8; // contagion
      else colorVal = 1;
      attr.setXYZ(i, colorVal, colorVal*0.5, colorVal*0.5);
    }
    attr.needsUpdate = true;

    // Update info
    document.getElementById('penetration').innerText = `Cumulative Penetration: ${(z_tip + z_contagion * frame/frames).toFixed(2)} cm`;
    document.getElementById('time').innerText = `Time: ${(frame/60).toFixed(2)} s`;

    // Camera transform
    camera.position.x = 150 * Math.sin(rotY) * zoom;
    camera.position.y = 50 * zoom + 50 * Math.sin(rotX);
    camera.position.z = 150 * Math.cos(rotY) * zoom;
    camera.lookAt(0, 0, 0);

    frame = (frame + 1) % frames;

    renderer.render(scene, camera);
  }

  animate();
</script>
</body>
</html>