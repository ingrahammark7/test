<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Li Wei Interactive Walkthrough - Micro Animations</title>
<style>
body { margin:0; overflow:hidden; }
canvas { display:block; }
.popup {
  position: absolute;
  padding: 8px 12px;
  background: rgba(0,0,0,0.7);
  color: white;
  font-family: Arial;
  font-size: 16px;
  border-radius: 4px;
  pointer-events: none;
  display: none;
  white-space: pre-line;
}
.legend {
  position: absolute;
  left: 10px; top: 10px;
  padding: 8px;
  background: rgba(0,0,0,0.5);
  color:white;
  font-family: Arial;
  font-size: 14px;
  border-radius:4px;
}
</style>
</head>
<body>
<div id="popup" class="popup"></div>
<div class="legend">
<b>Legend</b><br>
Blue Box: Li Wei<br>
Gray Boxes/Spheres: Crowd/People<br>
Green/Yellow/Red: Safety markers<br>
POI Animations: Doors, Lights, Chairs, Dogs
</div>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js';

// Scene & camera
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xa0a0a0);
scene.fog = new THREE.Fog(0xa0a0a0, 10, 50);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,3,8);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// Lights
scene.add(new THREE.AmbientLight(0xffffff,0.6));
const dirLight = new THREE.DirectionalLight(0xffffff,0.8);
dirLight.position.set(5,10,5);
dirLight.castShadow = true;
scene.add(dirLight);

// Ground
const ground = new THREE.Mesh(new THREE.PlaneGeometry(50,50), new THREE.MeshPhongMaterial({color:0x808080}));
ground.rotation.x=-Math.PI/2; ground.receiveShadow=true; scene.add(ground);

// Popup
const popup = document.getElementById('popup');

// POIs
const places = [
  { pos:new THREE.Vector3(0,0,0), label:"Apartment", content:"Safe", risk:"Low", event:"lights" },
  { pos:new THREE.Vector3(-8,0,3), label:"Cafe", content:"Safe", risk:"Low", event:"cafe" },
  { pos:new THREE.Vector3(10,0,-5), label:"Office", content:"Limited", risk:"Low", event:"office" },
  { pos:new THREE.Vector3(5,0,8), label:"Park", content:"Safe", risk:"Medium", event:"park" }
];

// Create buildings
function createBuilding(x,z,label){
  const mesh = new THREE.Mesh(new THREE.BoxGeometry(2,4,2), new THREE.MeshPhongMaterial({color:0x00ff00}));
  mesh.position.set(x,2,z); mesh.castShadow=true; mesh.receiveShadow=true; scene.add(mesh);
  const canvas = document.createElement('canvas');
  canvas.width=256; canvas.height=64;
  const ctx=canvas.getContext('2d');
  ctx.fillStyle='white'; ctx.font='28px Arial'; ctx.fillText(label,10,40);
  const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(canvas)}));
  sprite.scale.set(4,1,1); sprite.position.set(x,5,z); scene.add(sprite);
  mesh.userData.label = label; mesh.userData.popupText = `Building: ${label}`;
  return mesh;
}

// Safety spheres
function createSafetySpheres(x,z,contentColor,riskColor){
  const content = new THREE.Mesh(new THREE.SphereGeometry(0.3,16,16), new THREE.MeshBasicMaterial({color:contentColor}));
  content.position.set(x,0.3,z); scene.add(content);
  const risk = new THREE.Mesh(new THREE.SphereGeometry(0.3,16,16), new THREE.MeshBasicMaterial({color:riskColor}));
  risk.position.set(x,0.6,z); scene.add(risk);
}

// Buildings & safety
places.forEach(p=>{
  createBuilding(p.pos.x,p.pos.z,p.label);
  const cColor = p.content==='Safe'?0x00ff00:(p.content==='Limited'?0xffff00:0xff0000);
  const rColor = p.risk==='Low'?0x00ff00:(p.risk==='Medium'?0xffff00:0xff0000);
  createSafetySpheres(p.pos.x,p.pos.z,cColor,rColor);
});

// Li Wei
const liWei = new THREE.Mesh(new THREE.BoxGeometry(0.5,1.5,0.5), new THREE.MeshPhongMaterial({color:0x0000ff}));
liWei.castShadow=true; scene.add(liWei);

// Crowd
const crowd=[];
for(let i=0;i<20;i++){
  const geom = Math.random()>0.5?new THREE.BoxGeometry(0.4,1,0.4):new THREE.SphereGeometry(0.25,8,8);
  const mesh = new THREE.Mesh(geom,new THREE.MeshPhongMaterial({color:0x808080}));
  mesh.position.set(Math.random()*20-10,0,Math.random()*20-10); mesh.castShadow=true; scene.add(mesh);
  crowd.push({mesh:mesh,dir:new THREE.Vector3(Math.random()-0.5,0,Math.random()-0.5).normalize(),speed:0.02+Math.random()*0.02});
}

// POI micro-objects
const cafeChairs=[], parkPeople=[], parkDogs=[], officeDoors=[], apartmentLights=[];
function initPOIObjects(){
  // Cafe chairs
  for(let i=0;i<4;i++){
    const chair = new THREE.Mesh(new THREE.BoxGeometry(0.3,0.3,0.3), new THREE.MeshPhongMaterial({color:0x654321}));
    chair.position.set(-8+Math.random(),0.15,3+Math.random()); scene.add(chair);
    cafeChairs.push(chair);
  }
  // Park people + dogs
  for(let i=0;i<3;i++){
    const person = new THREE.Mesh(new THREE.BoxGeometry(0.3,0.8,0.3), new THREE.MeshPhongMaterial({color:0x808080}));
    person.position.set(5+Math.random(),0.4,8+Math.random()); scene.add(person); parkPeople.push(person);
    const dog = new THREE.Mesh(new THREE.SphereGeometry(0.15,8,8), new THREE.MeshPhongMaterial({color:0x000000}));
    dog.position.set(5+Math.random(),0.15,8+Math.random()); scene.add(dog); parkDogs.push(dog);
  }
  // Office doors
  for(let i=0;i<2;i++){
    const door = new THREE.Mesh(new THREE.BoxGeometry(0.5,1,0.05), new THREE.MeshPhongMaterial({color:0x333333}));
    door.position.set(10,0.5,-5+i*0.6); scene.add(door); officeDoors.push(door);
  }
  // Apartment lights
  for(let i=0;i<2;i++){
    const light = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.2), new THREE.MeshPhongMaterial({color:0xffff00}));
    light.position.set(0,3.8,0.5+i*0.5); scene.add(light); apartmentLights.push(light);
  }
}
initPOIObjects();

// Path
const pathPoints = places.map(p=>p.pos).concat([places[0].pos]);

// Animation
let t=0; const totalTime=25; let lastPlaceIndex=-1;
const clock = new THREE.Clock();

function triggerEvent(eventName){
  switch(eventName){
    case "cafe":
      cafeChairs.forEach(c=>c.rotation.y += 0.5*Math.sin(t*5));
      break;
    case "park":
      parkPeople.forEach(p=>p.position.y=0.4+0.05*Math.sin(t*5));
      parkDogs.forEach(d=>d.position.x += 0.02*Math.sin(t*10));
      break;
    case "office":
      officeDoors.forEach(d=>d.rotation.y = 0.3*Math.sin(t*5));
      break;
    case "lights":
      apartmentLights.forEach(l=>l.material.color.setHex(Math.random()>0.5?0xffff00:0xffaa00));
      break;
  }
}

function animate(){
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  t+=delta;

  // Day/night cycle
  const timeOfDay=(t/totalTime)%1;
  scene.background = new THREE.Color(0xa0a0a0).lerp(new THREE.Color(0x101030),timeOfDay);

  // Li Wei movement
  const progress=(t/totalTime)%1;
  const segment = Math.floor(progress*(pathPoints.length-1));
  const localT = progress*(pathPoints.length-1)-segment;
  const p1 = pathPoints[segment], p2 = pathPoints[segment+1];
  const pos = new THREE.Vector3().lerpVectors(p1,p2,localT);
  liWei.position.copy(pos); liWei.position.y = 0.75;
  liWei.position.y += 0.05*Math.sin(t*5); // sway
  const dir = new THREE.Vector3().subVectors(p2,p1).setY(0).normalize();
  liWei.lookAt(pos.clone().add(dir));

  // Camera cinematic
  const offset = new THREE.Vector3(0,3+Math.sin(t*2)*0.1,6+Math.sin(t*1.5)*0.2);
  camera.position.lerp(pos.clone().add(offset),0.1);
  camera.lookAt(pos.clone().add(new THREE.Vector3(0,1.2,0)));

  // Event popups
  if(segment !== lastPlaceIndex){
    lastPlaceIndex=segment;
    if(segment<places.length){
      const place=places[segment];
      popup.style.display='block';
      popup.innerText=`${place.label}\nContent: ${place.content}\nRisk: ${place.risk}`;
      setTimeout(()=>{popup.style.display='none';},2000);
    }
  }
  if(popup.style.display==='block'){
    const vector=pos.clone(); vector.project(camera);
    const x=(vector.x*0.5+0.5)*window.innerWidth;
    const y=(-vector.y*0.5+0.5)*window.innerHeight;
    popup.style.left=x+'px'; popup.style.top=y+'px';
  }

  // Crowd movement + idle
  crowd.forEach(c=>{
    const dist = c.mesh.position.distanceTo(liWei.position);
    if(dist<1.2) c.dir.add(new THREE.Vector3(Math.random()-0.5,0,Math.random()-0.5).normalize());
    c.mesh.position.add(c.dir.clone().multiplyScalar(c.speed));
    if(Math.abs(c.mesh.position.x)>25 || Math.abs(c.mesh.position.z)>25) c.dir.multiplyScalar(-1);
    // idle bob
    c.mesh.position.y = 0.4 + 0.05*Math.sin(t*2 + c.mesh.position.x);
  });

  // Trigger micro-animations
  if(segment<places.length) triggerEvent(places[segment].event);

  renderer.render(scene,camera);
}

// Click interactivity
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
window.addEventListener('click',(event)=>{
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse,camera);
  const intersects = raycaster.intersectObjects(scene.children);
  intersects.forEach(i=>{
    if(i.object.userData.popupText){
      popup.style.display='block';
      popup.innerText=i.object.userData.popupText;
      setTimeout(()=>{popup.style.display='none';},3000);
    }
  });
});

// Resize handling
window.addEventListener('resize',()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

animate();
</script>
</body>
</html>