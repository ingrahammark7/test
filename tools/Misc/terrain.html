<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gödel Petition + Full Atomic Simulation</title>
<style>
body{margin:0; overflow:hidden; font-family:Arial,sans-serif; background:#111;}
#info{position:absolute; top:0; left:0; width:30%; height:100%; background:rgba(0,0,0,0.9); color:white; padding:15px; overflow:auto; z-index:10;}
canvas{display:block; position:absolute; top:0; left:30%;}
h2,h3{margin:5px 0;}
p,li{margin:5px 0; line-height:1.2em;}
button{margin:5px; padding:5px 10px; cursor:pointer;}
</style>
</head>
<body>
<div id="info">
<h2>Gödel Petition Context</h2>
<p><strong>Petitioner:</strong> Mark Ingraham</p>
<p><strong>Respondent:</strong> Superior Court of California, Los Angeles County</p>
<p><strong>Real Party in Interest:</strong> LAPD</p>
<p><strong>Case No:</strong> B348321 (Super. Ct. No. 25STCP00742)</p>
<p><strong>Date Filed:</strong> August 19, 2025</p>
<p><strong>Order Date:</strong> August 21, 2025</p>

<h3>Background</h3>
<p>The petition requested a writ of mandate to compel the trial court to issue a judgment. The appellate court issued a <strong>summary denial</strong> within two days, unusually fast.</p>

<h3>Analysis</h3>
<ul>
<li>LAPD gains nothing from the delay.</li>
<li>If LAPD were expected to win, the court would have ruled immediately.</li>
<li>Summary dismissal is a procedural delay, leaving the state unchanged.</li>
<li>Self-referential logic: petition requested judgment, appellate denial constitutes judgment indirectly.</li>
<li>Only a false filing could avoid this self-referential “win,” impossible orally.</li>
</ul>

<h3>Conclusion</h3>
<ul>
<li>Practical result: petitioner effectively wins (Gödelian self-resolution).</li>
<li>LAPD is the delay side and will not obtain favorable judgment.</li>
<li>Speed of denial confirms conceptual resolution in petitioner’s favor.</li>
</ul>

<h3>Controls</h3>
<button id="speedUp">Faster Simulation</button>
<button id="slowDown">Slower Simulation</button>
<p>Click Gödel nodes to highlight related atoms.</p>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';

// === Scene & Camera ===
const scene=new THREE.Scene();
scene.background=new THREE.Color(0x000000);
const camera=new THREE.PerspectiveCamera(60,window.innerWidth*0.7/window.innerHeight,0.1,2000);
camera.position.set(0,50,100);
let cameraTarget=new THREE.Vector3(0,0,0);

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth*0.7,window.innerHeight);
renderer.domElement.style.position="absolute";
renderer.domElement.style.left="30%";
document.body.appendChild(renderer.domElement);

scene.add(new THREE.DirectionalLight(0xffffff,1).position.set(50,50,50));
scene.add(new THREE.AmbientLight(0x555555));

// === Gödel Petition Nodes ===
const godelData=[
  {pos:[-15,25,0], color:0x0000ff, text:"Petition Filed"},
  {pos:[0,22,0], color:0x00ff00, text:"Self-Resolving"},
  {pos:[-15,10,-5], color:0xff0000, text:"Trial Court Escape"},
  {pos:[15,10,5], color:0xffa500, text:"Appellate Denial"},
  {pos:[0,0,0], color:0x8000ff, text:"Practical Win"}
];
const godelNodes=[];
godelData.forEach(n=>{
  const mesh=new THREE.Mesh(
    new THREE.SphereGeometry(1,12,12),
    new THREE.MeshStandardMaterial({color:n.color})
  );
  mesh.position.set(...n.pos);
  scene.add(mesh);

  const canvas=document.createElement('canvas');
  canvas.width=256; canvas.height=64;
  const ctx=canvas.getContext('2d');
  ctx.fillStyle="white"; ctx.font="24px Arial"; ctx.textAlign="center";
  ctx.fillText(n.text,128,48);
  const texture=new THREE.CanvasTexture(canvas);
  const sprite=new THREE.Sprite(new THREE.SpriteMaterial({map:texture,transparent:true}));
  sprite.scale.set(6,1.5,1); sprite.position.set(mesh.position.x,mesh.position.y+2,mesh.position.z);
  scene.add(sprite);

  mesh.userData.label=n.text;
  godelNodes.push(mesh);
});

// Connect nodes
[[0,1],[1,2],[1,3],[2,4],[3,4]].forEach(([a,b])=>{
  const geom=new THREE.BufferGeometry().setFromPoints([godelNodes[a].position,godelNodes[b].position]);
  scene.add(new THREE.Line(geom,new THREE.LineBasicMaterial({color:0xffffff})));
});

// === Atomic Simulation ===
class Nucleon{
  constructor(){
    const geom=new THREE.SphereGeometry(0.5,8,8);
    const mat=new THREE.MeshStandardMaterial({color:0xff4444});
    this.mesh=new THREE.Mesh(geom,mat);
    this.mesh.position.set((Math.random()-0.5)*50,(Math.random()-0.5)*50,(Math.random()-0.5)*50);
    this.velocity=new THREE.Vector3((Math.random()-0.5)*2,(Math.random()-0.5)*2,(Math.random()-0.5)*2);
    this.energy=Math.random(); this.cluster=null;
    const trailGeom=new THREE.BufferGeometry();
    const positions=new Float32Array(50*3);
    trailGeom.setAttribute('position',new THREE.BufferAttribute(positions,3));
    const trailMat=new THREE.LineBasicMaterial({color:0xffff44,transparent:true,opacity:0.6});
    this.trail=new THREE.Line(trailGeom,trailMat);
    scene.add(this.mesh); scene.add(this.trail);
  }
  update(delta,boxSize){
    if(!this.cluster){
      this.mesh.position.addScaledVector(this.velocity,delta*speedFactor);
      ['x','y','z'].forEach(a=>{
        if(this.mesh.position[a]>boxSize){ this.mesh.position[a]=boxSize; this.velocity[a]*=-0.8; }
        if(this.mesh.position[a]<-boxSize){ this.mesh.position[a]=-boxSize; this.velocity[a]*=-0.8; }
      });
    } else { this.mesh.position.copy(this.cluster.center); }
    const pos=this.trail.geometry.attributes.position.array;
    pos.copyWithin(0,3);
    pos[pos.length-3]=this.mesh.position.x;
    pos[pos.length-2]=this.mesh.position.y;
    pos[pos.length-1]=this.mesh.position.z;
    this.trail.geometry.attributes.position.needsUpdate=true;
    const angle=performance.now()*0.001*this.energy*5;
    this.mesh.rotation.x=angle; this.mesh.rotation.y=angle*0.7;
  }
}

class Atom{
  constructor(nucleons){
    this.nucleons=nucleons; this.center=new THREE.Vector3();
    nucleons.forEach(n=>n.cluster=this); this.updateCenter();
    this.mesh=new THREE.Mesh(
      new THREE.SphereGeometry(this.nucleons.length*0.6,16,16),
      new THREE.MeshBasicMaterial({color:0x44ff44,transparent:true,opacity:0.3})
    );
    scene.add(this.mesh);
    this.waveGeom=new THREE.SphereGeometry(this.nucleons.length*0.6,8,8);
    this.waveMat=new THREE.MeshBasicMaterial({color:0x00ffff,transparent:true,opacity:0.1});
    this.waveMesh=new THREE.Mesh(this.waveGeom,this.waveMat);
    this.waveScale=1; scene.add(this.waveMesh);
  }
  updateCenter(){ this.center.set(0,0,0); this.nucleons.forEach(n=>this.center.add(n.mesh.position)); this.center.divideScalar(this.nucleons.length);}
  update(){
    this.updateCenter(); this.mesh.position.copy(this.center);
    const avgEnergy=this.nucleons.reduce((a,b)=>a+b.energy,0)/this.nucleons.length;
    this.mesh.material.opacity=0.2+0.3*avgEnergy; this.mesh.scale.setScalar(1+0.3*avgEnergy);
    this.waveScale+=0.2; this.waveMesh.scale.setScalar(this.waveScale); this.waveMesh.position.copy(this.center);
    this.waveMat.opacity=Math.max(0,0.2-(this.waveScale-1)*0.05); if(this.waveMat.opacity<=0)this.waveScale=1;
  }
}

class Electron{
  constructor(){
    const geom=new THREE.SphereGeometry(0.2,6,6);
    const mat=new THREE.MeshBasicMaterial({color:0x4444ff});
    this.mesh=new THREE.Mesh(geom,mat);
    this.mesh.position.set((Math.random()-0.5)*50,(Math.random()-0.5)*50,(Math.random()-0.5)*50);
    this.velocity=new THREE.Vector3((Math.random()-0.5)*4,(Math.random()-0.5)*4,(Math.random()-0.5)*4);
    scene.add(this.mesh);
  }
  update(delta,boxSize){
    this.mesh.position.addScaledVector(this.velocity,delta*speedFactor);
    ['x','y','z'].forEach(a=>{
      if(this.mesh.position[a]>boxSize){ this.mesh.position[a]=boxSize; this.velocity[a]*=-1; }
      if(this.mesh.position[a]<-boxSize){ this.mesh.position[a]=-boxSize; this.velocity[a]*=-1; }
    });
  }
}

// --- Initialize particles ---
const nucleons=Array.from({length:100},()=>new Nucleon());
const electrons=Array.from({length:25},()=>new Electron());
const atoms=[];

// --- Atom Detection ---
function detectAtoms(){
  const threshold=2.0;
  nucleons.forEach(n1=>{
    if(n1.cluster) return;
    nucleons.forEach(n2=>{
      if(n1===n2 || n2.cluster) return;
      if(n1.mesh.position.distanceTo(n2.mesh.position)<threshold){
        atoms.push(new Atom([n1,n2]));
      }
    });
  });
}

// --- Electron Collisions ---
function electronCollisions(){
  const energyTransfer=2.0;
  electrons.forEach(e=>{
    nucleons.forEach(n=>{
      if(e.mesh.position.distanceTo(n.mesh.position)<0.5){
        const push=e.velocity.clone().multiplyScalar(energyTransfer);
        if(!n.cluster)n.velocity.add(push);
        nucleons.forEach(nn=>{
          if(nn!==n && nn.mesh.position.distanceTo(n.mesh.position)<1.5){
            nn.velocity.add(push.clone().multiplyScalar(0.5));
          }
        });
      }
    });
  });
}

// --- Camera ---
let targetX=0,targetZ=0,distance=100,rotationY=0,targetRotationY=0;
let prevX=0,isDragging=false;
window.addEventListener('mousedown',e=>{isDragging=true; prevX=e.clientX;});
window.addEventListener('mouseup',()=>isDragging=false);
window.addEventListener('mousemove',e=>{if(isDragging){targetRotationY+=(e.clientX-prevX)*0.005; prevX=e.clientX;}});
window.addEventListener('wheel', e=>{distance += e.deltaY*0.1; distance=Math.max(20,Math.min(200,distance));});

// --- Node Click Highlight ---
godelNodes.forEach(node=>{
  node.cursor='pointer';
  node.onClick=false;
});
renderer.domElement.addEventListener('click', event=>{
  const mouse=new THREE.Vector2(
    (event.clientX/renderer.domElement.clientWidth)*2-1,
    -(event.clientY/renderer.domElement.clientHeight)*2+1
  );
  const raycaster=new THREE.Raycaster();
  raycaster.setFromCamera(mouse,camera);
  const intersects=raycaster.intersectObjects(godelNodes);
  intersects.forEach(obj=>{
    const node=obj.object;
    // Highlight nearby atoms
    atoms.forEach(a=>{
      a.mesh.material.color.setHex(0xff00ff);
      a.waveMat.color.setHex(0xff00ff);
    });
  });
});

// --- Animate ---
let lastTime=performance.now();
let speedFactor=1;
function animate(){
  requestAnimationFrame(animate);
  const now=performance.now();
  const delta=(now-lastTime)/1000; lastTime=now;

  nucleons.forEach(n=>n.update(delta,50));
  electrons.forEach(e=>e.update(delta,50));
  atoms.forEach(a=>a.update());
  detectAtoms();
  electronCollisions();

  rotationY += (targetRotationY-rotationY)*0.05;
  camera.position.x = Math.sin(rotationY)*distance + targetX;
  camera.position.z = Math.cos(rotationY)*distance + targetZ;
  camera.position.y = 50;
  camera.lookAt(cameraTarget);

  renderer.render(scene,camera);
}
animate();

// --- Resize ---
window.addEventListener('resize',()=>{
  camera.aspect = window.innerWidth*0.7/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth*0.7, window.innerHeight);
});

// --- Speed Control ---
document.getElementById('speedUp').onclick=()=>{speedFactor*=1.5;};
document.getElementById('slowDown').onclick=()=>{speedFactor/=1.5;};
</script>
</body>
</html>