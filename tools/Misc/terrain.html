<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Tank Terrain — Babylon.js Simulation v7</title>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
<style>
  html, body { width: 100%; height: 100%; margin: 0; overflow: hidden; }
  #overlay, #controls {
    position: absolute; z-index: 20;
    font-family: monospace; color: #fff;
    background: rgba(0,0,0,0.6); padding: 6px; border-radius: 6px;
  }
  #overlay { right: 8px; top: 8px; width: 320px; }
  #controls { left: 8px; top: 8px; line-height: 1.8; }
</style>
</head>
<body>
<div id="controls">
  Speed:
  <input type="range" id="speedSlider" min="0.1" max="10" step="0.1" value="1">
  <span id="speedVal">1</span>
  <br>

  Rotation smooth:
  <input id="rotSmooth" type="range" min="0.01" max="1" step="0.01" value="0.12">
  <br>

  Tilt blend:
  <input id="tiltBlend" type="range" min="0" max="1" step="0.01" value="0.5">
  <span id="tiltVal">0.50</span>
</div>

<div id="overlay">Loading files…</div>
<canvas id="renderCanvas"></canvas>

<script>
(async function(){

  const version = "7";  // increments every build
  const overlay = document.getElementById('overlay');
  const canvas = document.getElementById('renderCanvas');
  const engine = new BABYLON.Engine(canvas, true);

  try {
    const [terrainResp, movesResp, shotsResp] = await Promise.all([
      fetch("f.json?v="+version),
      fetch("f2.json?v="+version),
      fetch("f3.json?v="+version)
    ]);

    if (!terrainResp.ok || !movesResp.ok || !shotsResp.ok)
      throw new Error("Web server returned non-200");

    const terrainData = await terrainResp.json();
    const movesText   = await movesResp.text();
    const shotsText   = await shotsResp.text();

    overlay.innerText = "Files loaded — building scene…";

    buildScene(terrainData, movesText, shotsText);

  } catch (err) {
    overlay.innerText = "Error loading files: " + err;
    console.error(err);
  }

  function buildScene(terrainData, movesText, shotsText) {

    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.55, 0.80, 0.92);

    // camera
    const camera = new BABYLON.ArcRotateCamera(
      "cam", -Math.PI/3, Math.PI/4.5, 220, BABYLON.Vector3.Zero(), scene
    );
    camera.attachControl(canvas, true);

    // lights
    new BABYLON.HemisphericLight("h", new BABYLON.Vector3(0,1,0), scene);
    const dir = new BABYLON.DirectionalLight("d", new BABYLON.Vector3(-1,-2,-1), scene);
    dir.intensity = 1.0;

    //--------------------------------------------------------------
    // TERRAIN GRID → MESH
    //--------------------------------------------------------------
    const xKeys = Object.keys(terrainData).map(Number).sort((a,b)=>a-b);
    const zSet = new Set();
    xKeys.forEach(x => Object.keys(terrainData[x]).forEach(z => zSet.add(Number(z))));
    const zKeys = Array.from(zSet).sort((a,b)=>a-b);

    const minX = xKeys[0], maxX = xKeys[xKeys.length-1];
    const minZ = zKeys[0], maxZ = zKeys[zKeys.length-1];
    const centerX = (minX + maxX) / 2;
    const centerZ = (minZ + maxZ) / 2;

    const positions = [];
    const indices = [];

    for (let zi = 0; zi < zKeys.length; zi++) {
      for (let xi = 0; xi < xKeys.length; xi++) {
        const x = xKeys[xi] - centerX;
        const z = zKeys[zi] - centerZ;
        const y = terrainData[xKeys[xi]][zKeys[zi]] || 0;
        positions.push(x, y, z);
      }
    }

    for (let zi = 0; zi < zKeys.length - 1; zi++) {
      for (let xi = 0; xi < xKeys.length - 1; xi++) {
        const a = zi * xKeys.length + xi;
        const b = a + 1;
        const c = a + xKeys.length;
        const d = c + 1;
        indices.push(a,c,b, b,c,d);
      }
    }

    const terrain = new BABYLON.Mesh("terrain", scene);
    const vd = new BABYLON.VertexData();
    vd.positions = positions;
    vd.indices = indices;
    vd.applyToMesh(terrain);

    const tmat = new BABYLON.StandardMaterial("tmat", scene);
    tmat.diffuseColor = new BABYLON.Color3(0.13, 0.55, 0.13);
    terrain.material = tmat;

    //--------------------------------------------------------------
    // SIMPLE HEIGHT FUNCTION
    //--------------------------------------------------------------
    function heightAt(x, z) {
      let bestX=0, bestZ=0, bestDist=Infinity;
      for (let i=0; i < xKeys.length; i++) {
        for (let j=0; j < zKeys.length; j++) {
          const dx = (xKeys[i] - centerX) - x;
          const dz = (zKeys[j] - centerZ) - z;
          const d = dx*dx + dz*dz;
          if (d < bestDist) { bestDist=d; bestX=i; bestZ=j; }
        }
      }
      return terrainData[xKeys[bestX]][zKeys[bestZ]] || 0;
    }

    //--------------------------------------------------------------
    // PARSE TANK PATHS FROM f2.json
    //--------------------------------------------------------------
    const tanks = {};
    movesText.split('|').filter(s => s.trim()).forEach(token => {
      const m = token.trim();
      const parts = m.split(' ');
      const mxy = m.match(/(-?\d+),(-?\d+)$/);
      if (!mxy) return;
      const id = parts[0];
      const x = Number(mxy[1]) - centerX;
      const z = Number(mxy[2]) - centerZ;
      if (!tanks[id]) tanks[id] = { path: [] };
      tanks[id].path.push(new BABYLON.Vector3(x, 0, z));
    });

    //--------------------------------------------------------------
    // FIXED COLOR SET
    //--------------------------------------------------------------
    const tankColors = [
      new BABYLON.Color3(1,0,0),
      new BABYLON.Color3(0,0,1),
      new BABYLON.Color3(1,1,0),
      new BABYLON.Color3(1,0,1),
      new BABYLON.Color3(0,1,1)
    ];

    //--------------------------------------------------------------
    // BUILD TANK MESHES
    //--------------------------------------------------------------
    let cIndex = 0;
    for (const id in tanks) {
      const tank = tanks[id];

      const box = BABYLON.MeshBuilder.CreateBox("tank"+id, {size:6}, scene);
      const mat = new BABYLON.StandardMaterial("mat"+id, scene);
      mat.diffuseColor = tankColors[cIndex++ % tankColors.length];
      box.material = mat;

      const first = tank.path[0];
      const y = heightAt(first.x, first.z) + 2;
      box.position.set(first.x, y, first.z);

      tank.mesh = box;
      tank.currentIndex = 0;
      tank.progress = 0;
      tank.cooldown = Math.random()*2 + 0.1;
    }

    //--------------------------------------------------------------
    // LOAD SHOTS FROM f3.json
    //--------------------------------------------------------------
    shotsText.split('|').filter(s => s.trim()).forEach(line => {
      const n = line.split(',').map(Number);
      if (n.length !== 4) return;

      const [x1,z1,x2,z2] = n;
      const p1 = new BABYLON.Vector3(x1-centerX, heightAt(x1-centerX,z1-centerZ)+1, z1-centerZ);
      const p2 = new BABYLON.Vector3(x2-centerX, heightAt(x2-centerX,z2-centerZ)+1, z2-centerZ);

      BABYLON.MeshBuilder.CreateLines("f3line", {
        points: [p1,p2]
      }, scene).color = new BABYLON.Color3(1,1,1);
    });

    //--------------------------------------------------------------
    // UI HOOKS
    //--------------------------------------------------------------
    let speed = 1;
    document.getElementById("speedSlider").oninput = e=>{
      speed = parseFloat(e.target.value);
      document.getElementById("speedVal").innerText = speed.toFixed(1);
    };
    document.getElementById("tiltBlend").oninput = e=>{
      document.getElementById("tiltVal").innerText = parseFloat(e.target.value).toFixed(2);
    };

    //--------------------------------------------------------------
    // MAIN UPDATE LOOP
    //--------------------------------------------------------------
    const dynamicShots = [];

    function fireShot(from, to) {
      const p1 = from.mesh.position.clone();
      const p2 = to.mesh.position.clone();

      const line = BABYLON.MeshBuilder.CreateLines("shot", {
        points: [p1,p2]
      }, scene);

      line.color = new BABYLON.Color3(1,1,1);
      dynamicShots.push({mesh: line, t: 0.12});
    }

    scene.onBeforeRenderObservable.add(()=>{

      const dt = engine.getDeltaTime()/1000;
      const delta60 = dt / (1/60);

      for (const id in tanks) {
        const t = tanks[id];

        if (t.path.length < 2) continue;

        // move along path
        let remain = speed * delta60;
        while (remain > 0 && t.currentIndex < t.path.length - 1) {
          const A = t.path[t.currentIndex];
          const B = t.path[t.currentIndex+1];

          const len = BABYLON.Vector3.Distance(A,B);
          const left = len*(1 - t.progress);

          if (remain >= left) {
            remain -= left;
            t.currentIndex++;
            t.progress = 0;
          } else {
            t.progress += remain / len;
            remain = 0;
          }
        }

        const A = t.path[t.currentIndex];
        const B = t.path[Math.min(t.currentIndex+1, t.path.length-1)];
        const pos = BABYLON.Vector3.Lerp(A,B,t.progress);
        const y = heightAt(pos.x,pos.z)+2;
        t.mesh.position.set(pos.x,y,pos.z);

        // shooting
        t.cooldown -= dt;
        if (t.cooldown <= 0) {
          let best=null, bestDist=Infinity;

          for (const other in tanks) {
            if (other === id) continue;
            const d = BABYLON.Vector3.Distance(
              t.mesh.position,
              tanks[other].mesh.position
            );
            if (d < 50 && d < bestDist) {
              bestDist = d; best = tanks[other];
            }
          }

          if (best) fireShot(t,best);
          t.cooldown = Math.random()*2 + 0.5;
        }
      }

      // fade dynamic shots
      for (let i = dynamicShots.length-1; i >= 0; i--) {
        dynamicShots[i].t -= dt;
        if (dynamicShots[i].t <= 0) {
          dynamicShots[i].mesh.dispose();
          dynamicShots.splice(i,1);
        }
      }
    });

    //--------------------------------------------------------------
    engine.runRenderLoop(()=>scene.render());
    window.addEventListener("resize",()=>engine.resize());
    overlay.style.display="none";
  }
})();
</script>
</body>
</html>