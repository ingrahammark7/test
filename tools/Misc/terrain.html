<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Tensile Test Simulation - Three.js</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; }
  canvas { display: block; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
  // ---------- Scene setup ----------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);

  const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth/window.innerHeight,
    0.1,
    1000
  );
  camera.position.set(0, 0, 20);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // ---------- Lights ----------
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);
  const dirLight = new THREE.DirectionalLight(0xffffff, 1);
  dirLight.position.set(10, 10, 10);
  scene.add(dirLight);

  // ---------- Parameters ----------
  const fiberCount = 10;
  const fiberLength = 10;
  const stressSpeed = 0.05; // movement along fibers
  const fibers = [];
  const cracks = [];

  // ---------- Fibers ----------
  const fiberMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
  for(let i=0; i<fiberCount; i++){
    const geometry = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-fiberLength/2, i - fiberCount/2, 0),
      new THREE.Vector3(fiberLength/2, i - fiberCount/2, 0)
    ]);
    const line = new THREE.Line(geometry, fiberMaterial);
    scene.add(line);
    fibers.push(line);
  }

  // ---------- Cracks (as small moving points along fibers) ----------
  const crackMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
  function createCrack(x, y){
    const geometry = new THREE.SphereGeometry(0.15, 8, 8);
    const mesh = new THREE.Mesh(geometry, crackMaterial);
    mesh.position.set(x, y, 0);
    scene.add(mesh);
    return mesh;
  }

  for(let i=0; i<fiberCount*2; i++){
    const y = Math.random() * fiberCount - fiberCount/2;
    const x = -fiberLength/2 - Math.random()*5;
    cracks.push(createCrack(x, y));
  }

  // ---------- Stress arrows ----------
  const arrowMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
  const arrows = [];
  for(let i=0; i<fiberCount; i++){
    const dir = new THREE.Vector3(1,0,0);
    const origin = new THREE.Vector3(-fiberLength/2, i - fiberCount/2, 0);
    const length = 1;
    const arrow = new THREE.ArrowHelper(dir, origin, length, 0xffff00);
    scene.add(arrow);
    arrows.push(arrow);
  }

  // ---------- Camera controls ----------
  const keys = {};
  window.addEventListener('keydown', e => keys[e.code] = true);
  window.addEventListener('keyup', e => keys[e.code] = false);

  function updateCamera(){
    const speed = 0.3;
    if(keys['ArrowUp']) camera.position.z -= speed;
    if(keys['ArrowDown']) camera.position.z += speed;
    if(keys['ArrowLeft']) camera.position.x -= speed;
    if(keys['ArrowRight']) camera.position.x += speed;
    if(keys['KeyW']) camera.position.y += speed;
    if(keys['KeyS']) camera.position.y -= speed;
  }

  // ---------- Animation loop ----------
  let paused = false;
  window.addEventListener('keydown', e => {
    if(e.code === 'Space') paused = !paused;
  });

  function animate(){
    requestAnimationFrame(animate);
    updateCamera();

    if(!paused){
      // Move cracks along fibers
      cracks.forEach(c => {
        c.position.x += stressSpeed;
        if(c.position.x > fiberLength/2){
          c.position.x = -fiberLength/2;
        }
      });

      // Move arrows to simulate stress
      arrows.forEach(a => {
        a.position.x += stressSpeed;
        if(a.position.x > fiberLength/2){
          a.position.x = -fiberLength/2;
        }
      });
    }

    renderer.render(scene, camera);
  }

  animate();

  // ---------- Responsive ----------
  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

</script>
</body>
</html>