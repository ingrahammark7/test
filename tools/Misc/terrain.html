<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Three.js Procedural Terrain</title>
<style>body{margin:0;overflow:hidden;}canvas{display:block;}</style>
</head>
<body>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';

// Scene
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x101010);
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 200);
camera.position.set(0,50,80);
camera.lookAt(0,0,0);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Plane
const size = 80, segments = 80;
const geometry = new THREE.PlaneGeometry(size,size,segments,segments);
geometry.rotateX(-Math.PI/2);
const material = new THREE.MeshStandardMaterial({color:0x44aa88, wireframe:true});
const plane = new THREE.Mesh(geometry, material);
scene.add(plane);

// Light
const light = new THREE.DirectionalLight(0xffffff,1);
light.position.set(50,50,50);
scene.add(light);

// Helper: pseudo-random offset per vertex for organic variation
const offsets = [];
for(let i=0; i<geometry.attributes.position.count; i++){
    offsets.push(Math.random()*2*Math.PI);
}

// Animate waves with multiple frequencies
let time = 0;
function animate(){
    requestAnimationFrame(animate);
    time += 0.02;
    const pos = geometry.attributes.position.array;
    for(let i=0;i<pos.length;i+=3){
        const x = pos[i], z = pos[i+2];
        const o = offsets[i/3];
        // Combine multiple sine + cos for "noise-like" terrain
        pos[i+1] = Math.sin(x*0.2 + time + o) * 2 
                 + Math.cos(z*0.15 + time*1.3 + o) * 1.5
                 + Math.sin((x+z)*0.1 + time*0.7 + o) * 1;
    }
    geometry.attributes.position.needsUpdate = true;
    renderer.render(scene,camera);
}
animate();

// Resize
window.addEventListener('resize',()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>