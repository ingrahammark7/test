<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Progressive Terrain Loader - File Input</title>
<style>
  body { margin: 0; overflow: hidden; font-family: sans-serif; }
  #ui { position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.5); padding: 10px; color: white; z-index: 100; }
  #log { position: fixed; bottom: 0; left: 0; width: 100%; max-height: 150px; overflow-y: scroll; background: rgba(0,0,0,0.7); color: white; font-family: monospace; font-size: 12px; padding: 4px; z-index: 101; }
  canvas { display: block; }
</style>
</head>
<body>
<div id="ui">
  <label>Select f.json:</label><br>
  <input type="file" id="fileInput"><br><br>
  <label>Sample Step: <span id="sampleValue">8</span></label><br>
  <input type="range" id="sampleSlider" min="1" max="32" value="8">
</div>
<div id="log"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
<script>
const logDiv = document.getElementById('log');
function log(msg) {
    console.log(msg);
    logDiv.innerHTML += msg + "<br>";
    logDiv.scrollTop = logDiv.scrollHeight;
}

const sampleSlider = document.getElementById('sampleSlider');
const sampleValue = document.getElementById('sampleValue');

let terrainData;
let scene, camera, renderer;
let terrainMeshes = [];
let SAMPLE_STEP = parseInt(sampleSlider.value);
let panX = 0, panZ = 0;
let panSpeedX = 0.3, panSpeedZ = 0.2;
const CHUNK_SIZE = 64;

sampleSlider.addEventListener('input', () => {
    SAMPLE_STEP = parseInt(sampleSlider.value);
    sampleValue.textContent = SAMPLE_STEP;
    log("Slider changed. SAMPLE_STEP=" + SAMPLE_STEP);
    rebuildTerrain();
});

// ========== FILE INPUT ==========
document.getElementById('fileInput').addEventListener('change', e => {
    const file = e.target.files[0];
    if(!file) return;
    log("Loading terrain file: " + file.name);

    const reader = new FileReader();
    reader.onload = evt => {
        try {
            terrainData = JSON.parse(evt.target.result);
            log("Terrain loaded. Columns: " + Object.keys(terrainData).length);
            rebuildTerrain();
        } catch(err) {
            log("ERROR parsing JSON: " + err.message);
            console.error(err);
        }
    };
    reader.readAsText(file);
});

// ========== INIT ==========
init();
animate();

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 5000);
    camera.position.set(0, 50, 0);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(200, 400, 200);
    scene.add(dirLight);
    scene.add(new THREE.AmbientLight(0x404040));

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
}

// ========== TERRAIN ==========
function rebuildTerrain() {
    if(!terrainData) {
        log("No terrain data. Aborting rebuild.");
        return;
    }

    // Remove previous meshes
    terrainMeshes.forEach(m => {
        scene.remove(m);
        m.geometry.dispose();
        m.material.dispose();
    });
    terrainMeshes = [];
    panX = 0;
    panZ = 0;

    const xKeys = Object.keys(terrainData).map(k => parseInt(k)).filter(k => k % SAMPLE_STEP === 0).sort((a,b)=>a-b);
    const yKeysSet = new Set();
    xKeys.forEach(x => {
        Object.keys(terrainData[x]).map(k => parseInt(k)).filter(k => k % SAMPLE_STEP === 0).forEach(y => yKeysSet.add(y));
    });
    const yKeys = Array.from(yKeysSet).sort((a,b)=>a-b);

    const cols = xKeys.length;
    const rows = yKeys.length;
    if(cols < 2 || rows < 2) {
        log("Too few points to build terrain. cols=" + cols + ", rows=" + rows);
        return;
    }

    log(`Starting chunked terrain build. cols=${cols}, rows=${rows}, CHUNK_SIZE=${CHUNK_SIZE}`);

    let chunkStartX = 0;
    function buildChunk() {
        if(chunkStartX >= cols) {
            log("All chunks built.");
            return;
        }

        const endX = Math.min(chunkStartX + CHUNK_SIZE, cols);
        const chunkCols = endX - chunkStartX;
        const chunkRows = rows;

        log(`Building chunk: startX=${chunkStartX}, endX=${endX}, chunkCols=${chunkCols}, rows=${chunkRows}`);

        const geometry = new THREE.PlaneGeometry(chunkCols*8, chunkRows*8, chunkCols-1, chunkRows-1);
        const verts = geometry.attributes.position.array;

        for(let i=0; i<chunkRows; i++){
            for(let j=0; j<chunkCols; j++){
                const xKey = xKeys[chunkStartX + j];
                const yKey = yKeys[i];
                let h = terrainData[xKey] && terrainData[xKey][yKey] !== undefined ? terrainData[xKey][yKey] : 0;
                const idx = 3*(i*chunkCols + j);
                verts[idx+2] = h;
            }
        }
        geometry.computeVertexNormals();
        const material = new THREE.MeshStandardMaterial({color:0x228B22, flatShading:true});
        const mesh = new THREE.Mesh(geometry, material);
        mesh.rotation.x = -Math.PI/2;
        mesh.position.x = chunkStartX*8;
        terrainMeshes.push(mesh);
        scene.add(mesh);

        log(`Chunk added: startX=${chunkStartX}`);

        chunkStartX += CHUNK_SIZE;
        setTimeout(buildChunk, 10); // schedule next chunk
    }

    buildChunk();
}

// ========== ANIMATION ==========
function animate() {
    requestAnimationFrame(animate);

    if(terrainMeshes.length === 0 || !terrainData) return;

    const totalCols = Object.keys(terrainData).length;
    const yKeysSet = new Set();
    Object.values(terrainData).forEach(col => Object.keys(col).forEach(y => yKeysSet.add(parseInt(y))));
    const totalRows = yKeysSet.size;

    const boundsX = totalCols * 8;
    const boundsZ = totalRows * 8;

    panX += panSpeedX;
    panZ += panSpeedZ;
    if(panX > boundsX) panX = 0;
    if(panZ > boundsZ) panZ = 0;

    camera.position.x = panX;
    camera.position.z = panZ + 50;
    camera.position.y = 50;
    camera.lookAt(boundsX/2, 0, boundsZ/2);

    renderer.render(scene, camera);
}
</script>
</body>
</html>