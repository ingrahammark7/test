<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Nucleus Simulation</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #health {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 6px 10px;
      background: rgba(0,0,0,0.5);
      color: white;
      font-family: sans-serif;
      font-size: 14px;
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <div id="health">Stability: 100</div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    camera.position.set(0,0,10);

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
    dirLight.position.set(5,5,5);
    scene.add(dirLight);

    // Proton and Neutron Materials
    const protonMat = new THREE.MeshPhongMaterial({color:0xff3333});
    const neutronMat = new THREE.MeshPhongMaterial({color:0x3333ff});

    // Make nucleus
    const nucleons = [];
    const radius = 0.3;
    for (let i=0; i<6; i++) { // 3 protons, 3 neutrons
      const mat = (i % 2 === 0) ? protonMat : neutronMat;
      const sphere = new THREE.Mesh(new THREE.SphereGeometry(radius, 16, 16), mat);
      sphere.position.set(
        (Math.random()-0.5)*2,
        (Math.random()-0.5)*2,
        (Math.random()-0.5)*2
      );
      scene.add(sphere);
      nucleons.push({mesh:sphere, isProton:(i%2===0)});
    }

    // Stability
    let stability = 100;
    const healthDiv = document.getElementById("health");

    function computeForces() {
      let totalForce = 0;
      for (let i=0; i<nucleons.length; i++) {
        let n1 = nucleons[i];
        for (let j=i+1; j<nucleons.length; j++) {
          let n2 = nucleons[j];
          let dx = n1.mesh.position.x - n2.mesh.position.x;
          let dy = n1.mesh.position.y - n2.mesh.position.y;
          let dz = n1.mesh.position.z - n2.mesh.position.z;
          let dist = Math.sqrt(dx*dx + dy*dy + dz*dz) + 0.001;

          // Strong force: attractive if close (<2 units)
          let strong = 0;
          if (dist < 2.0) {
            strong = -5.0 / (dist*dist); 
          }

          // EM force: only between protons
          let em = 0;
          if (n1.isProton && n2.isProton) {
            em = 2.0 / (dist*dist);
          }

          let f = em + strong;
          totalForce += f;

          // Push them slightly
          let fx = (dx/dist) * f * 0.02;
          let fy = (dy/dist) * f * 0.02;
          let fz = (dz/dist) * f * 0.02;
          n1.mesh.position.x += fx;
          n1.mesh.position.y += fy;
          n1.mesh.position.z += fz;
          n2.mesh.position.x -= fx;
          n2.mesh.position.y -= fy;
          n2.mesh.position.z -= fz;
        }
      }
      return totalForce;
    }

    function animate() {
      requestAnimationFrame(animate);

      // Jiggle nucleons
      nucleons.forEach(n => {
        n.mesh.position.x += (Math.random()-0.5)*0.02;
        n.mesh.position.y += (Math.random()-0.5)*0.02;
        n.mesh.position.z += (Math.random()-0.5)*0.02;
      });

      let netForce = computeForces();

      // Adjust stability
      stability -= Math.abs(netForce)*0.001;
      stability = Math.max(0, stability);
      healthDiv.innerText = "Stability: " + stability.toFixed(1);

      if (stability <= 0) {
        healthDiv.innerText = "ðŸ’¥ Nucleus Breaks!";
      }

      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>