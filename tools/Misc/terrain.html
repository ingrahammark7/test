<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Advanced Nuclear Physics Simulator</title>
  <style>
    body {
      font-family: sans-serif;
      background: #0a0a0a;
      color: #eee;
      padding: 1em;
    }
    button {
      padding: 1em;
      font-size: 1.1em;
      margin: 1em 0;
      background-color: #00c853;
      color: white;
      border: none;
      border-radius: 6px;
    }
    pre {
      white-space: pre-wrap;
      background: #1e1e1e;
      padding: 1em;
      border-radius: 5px;
      overflow-x: auto;
    }
  </style>
</head>
<body>
  <h1>Maximal Nuclear Physics Engine</h1>
  <button onclick="runSimulation()">Run Simulation</button>
  <pre id="output">Results will appear here...</pre>  <script>
    function runSimulation() {
      const output = document.getElementById("output");
      output.textContent = "Running advanced simulation...\n";

      try {
        const Z = 92; // Uranium
        const N = 146; // Neutrons

        function bindingEnergy(Z, N) {
          const A = Z + N;
          const volumeTerm = 15.8 * A;
          const surfaceTerm = -18.3 * Math.pow(A, 2/3);
          const coulombTerm = -0.714 * Z * (Z - 1) / Math.pow(A, 1/3);
          const asymmetryTerm = -23.2 * Math.pow(N - Z, 2) / A;
          const pairingTerm = (Z % 2 === 0 && N % 2 === 0) ? 12 / Math.sqrt(A) : (Z % 2 === 1 && N % 2 === 1) ? -12 / Math.sqrt(A) : 0;
          return volumeTerm + surfaceTerm + coulombTerm + asymmetryTerm + pairingTerm;
        }

        function shellCorrection(Z, N) {
          return 5 * Math.sin(0.1 * Z) + 5 * Math.sin(0.1 * N);
        }

        function pairingBCS(N, Z) {
          const delta = 12 / Math.sqrt(N + Z);
          return delta * Math.cos((N - Z) * 0.1);
        }

        function betaDecayHalfLife(Z, N) {
          const Q = 0.782 - (Z - N) * 0.01;
          return Q > 0 ? Math.exp(5 / Q) : Infinity;
        }

        function rmfPotential(Z, N) {
          return 40 + 10 * Math.sin(Z * 0.2) - 5 * Math.cos(N * 0.15);
        }

        function skyrmeEnergyDensity(Z, N) {
          const A = Z + N;
          return (Z * N) / A * (1 - Math.exp(-A / 100));
        }

        function simulateDecayChain(Z, N, steps) {
          let result = [];
          for (let i = 0; i < steps; i++) {
            const be = bindingEnergy(Z, N).toFixed(2);
            const beta = betaDecayHalfLife(Z, N).toFixed(2);
            result.push(`Z=${Z} N=${N} BE=${be} BetaHalfLife=${beta}s`);
            if (Z > 1) Z--;
            N++;
          }
          return result;
        }

        const be = bindingEnergy(Z, N);
        const shell = shellCorrection(Z, N);
        const pairing = pairingBCS(N, Z);
        const halfLife = betaDecayHalfLife(Z, N);
        const rmf = rmfPotential(Z, N);
        const skyrme = skyrmeEnergyDensity(Z, N);
        const decayChain = simulateDecayChain(Z, N, 5);

        output.textContent += `Z=${Z} N=${N}\n`;
        output.textContent += `Binding Energy: ${be.toFixed(2)} MeV\n`;
        output.textContent += `Shell Correction: ${shell.toFixed(2)} MeV\n`;
        output.textContent += `Pairing (BCS): ${pairing.toFixed(2)} MeV\n`;
        output.textContent += `Beta Decay Half-Life: ${halfLife.toFixed(2)} s\n`;
        output.textContent += `RMF Potential: ${rmf.toFixed(2)} MeV\n`;
        output.textContent += `Skyrme Energy Density: ${skyrme.toFixed(2)} MeV\n\n`;
        output.textContent += `Decay Chain Simulation:\n${decayChain.join("\n")}\n`;
      } catch (err) {
        output.textContent += `Error: ${err.message}`;
      }
    }

    window.onload = runSimulation;
  </script></body>
</html>