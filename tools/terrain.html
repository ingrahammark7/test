<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Infinite Dogfight with Jet Details & Engine Glow Flicker</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; }
  canvas { display: block; }
  #hud {
    position: absolute; top: 10px; left: 10px; 
    color: #eee; font-family: monospace; 
    background: rgba(0,0,0,0.5); padding: 6px 10px; 
    border-radius: 6px; user-select:none; z-index: 10;
  }
</style>
</head>
<body>
<div id="hud">Camera: Overview<br>Missiles: 0</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
<script>
(() => {
  const scene = new THREE.Scene();

  // Skybox gradient sphere
  const skyGeo = new THREE.SphereGeometry(500, 32, 15);
  const skyMat = new THREE.ShaderMaterial({
    side: THREE.BackSide,
    uniforms: {
      topColor: { value: new THREE.Color(0x87CEEB) },
      bottomColor: { value: new THREE.Color(0xffffff) }
    },
    vertexShader: `
      varying vec3 vWorldPosition;
      void main() {
        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
        vWorldPosition = worldPosition.xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
      }
    `,
    fragmentShader: `
      uniform vec3 topColor;
      uniform vec3 bottomColor;
      varying vec3 vWorldPosition;
      void main() {
        float h = normalize(vWorldPosition).y * 0.5 + 0.5;
        gl_FragColor = vec4(mix(bottomColor, topColor, h), 1.0);
      }
    `
  });
  const sky = new THREE.Mesh(skyGeo, skyMat);
  scene.add(sky);

  // Clouds layer
  const cloudTex = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/cloud.png');
  const clouds = [];
  for(let i=0; i<20; i++) {
    const cloudMat = new THREE.SpriteMaterial({ map: cloudTex, transparent: true, opacity: 0.15 });
    const cloud = new THREE.Sprite(cloudMat);
    cloud.position.set(
      (Math.random()-0.5)*200,
      40 + Math.random()*20,
      (Math.random()-0.5)*200
    );
    cloud.scale.set(20,20,1);
    scene.add(cloud);
    clouds.push(cloud);
  }

  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 40, 60);

  const renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const dirLight = new THREE.DirectionalLight(0xffffff, 1);
  dirLight.position.set(30, 50, 30);
  scene.add(dirLight);
  scene.add(new THREE.AmbientLight(0x404040));

  const grid = new THREE.GridHelper(100, 20, 0x222222, 0x444444);
  scene.add(grid);

  function createJet(color=0xff0000) {
    const jet = new THREE.Group();
    const material = new THREE.MeshStandardMaterial({color, roughness: 0.4, metalness: 0.8});

    // Fuselage - Cylinder for body
    const body = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.45, 5, 16), material);
    body.rotation.z = Math.PI/2;
    jet.add(body);

    // Nose cone - smaller and smoother cone
    const nose = new THREE.Mesh(new THREE.ConeGeometry(0.35, 1.2, 16), material);
    nose.rotation.z = Math.PI/2;
    nose.position.x = 2.6;
    jet.add(nose);

    // Wings with tapering
    const wingShape = new THREE.Shape();
    wingShape.moveTo(0,0);
    wingShape.lineTo(2,0.6);
    wingShape.lineTo(2,-0.6);
    wingShape.lineTo(0,0);
    const wingGeo = new THREE.ExtrudeGeometry(wingShape, {depth: 0.1, bevelEnabled: false});
    const wingL = new THREE.Mesh(wingGeo, material);
    const wingR = new THREE.Mesh(wingGeo, material);
    wingL.position.set(0, 0.15, -0.7);
    wingR.position.set(0, 0.15, 0.7);
    jet.add(wingL, wingR);

    // Tail fin - vertical stabilizer
    const tailFinGeo = new THREE.ConeGeometry(0.3, 1, 12);
    const tailFin = new THREE.Mesh(tailFinGeo, material);
    tailFin.position.set(-2.3, 0.7, 0);
    tailFin.rotation.z = Math.PI / 2;
    tailFin.rotation.x = Math.PI / 10;
    jet.add(tailFin);

    // Tail wings
    const tailWingL = new THREE.Mesh(wingGeo, material);
    const tailWingR = new THREE.Mesh(wingGeo, material);
    tailWingL.scale.set(0.6,1,0.5);
    tailWingR.scale.set(0.6,1,0.5);
    tailWingL.position.set(-2.3, 0.1, -0.6);
    tailWingR.position.set(-2.3, 0.1, 0.6);
    jet.add(tailWingL, tailWingR);

    // Engine - emissive material and glow flicker
    const engineMat = new THREE.MeshStandardMaterial({
      color: 0xff4400,
      emissive: 0xff3300,
      emissiveIntensity: 2,
      roughness: 0.2,
      metalness: 0.8
    });
    const engine = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.22, 0.6, 12), engineMat);
    engine.rotation.z = Math.PI/2;
    engine.position.set(-2.8, 0, 0);
    jet.add(engine);

    // Flickering point light simulating afterburner flame
    const flameLight = new THREE.PointLight(0xff6600, 1.5, 6);
    flameLight.position.copy(engine.position);
    jet.add(flameLight);

    // Store ref for animation
    jet.engineLight = flameLight;
    jet.engineMaterial = engineMat;

    return jet;
  }

  class SmokeParticle {
    constructor(position) {
      const geo = new THREE.SphereGeometry(0.07, 6, 6);
      const mat = new THREE.MeshBasicMaterial({color: 0xaaaaaa, transparent: true, opacity: 0.5});
      this.mesh = new THREE.Mesh(geo, mat);
      this.mesh.position.copy(position);
      this.life = 20;
      scene.add(this.mesh);
    }
    update() {
      this.life--;
      this.mesh.position.y += 0.01;
      this.mesh.material.opacity = this.life / 20 * 0.5;
      if(this.life <= 0) {
        scene.remove(this.mesh);
        return false;
      }
      return true;
    }
  }

  class Missile {
    constructor(position, direction, owner) {
      this.speed = 0.6;
      this.owner = owner;
      this.life = 150;

      this.mesh = new THREE.Mesh(
        new THREE.CylinderGeometry(0.05, 0.05, 1, 6),
        new THREE.MeshBasicMaterial({color: 0xffff00})
      );
      this.mesh.rotation.z = Math.PI / 2;
      this.mesh.position.copy(position);
      scene.add(this.mesh);

      this.velocity = direction.clone().multiplyScalar(this.speed);
      this.isDestroyed = false;

      this.smokeParticles = [];
    }

    update() {
      this.mesh.position.add(this.velocity);
      this.life--;

      if(this.life % 2 === 0) {
        this.smokeParticles.push(new SmokeParticle(this.mesh.position.clone()));
      }
      this.smokeParticles = this.smokeParticles.filter(p => p.update());

      if (this.life <= 0) this.destroy();
    }

    destroy() {
      if(this.isDestroyed) return;
      this.isDestroyed = true;
      scene.remove(this.mesh);

      const explosionCount = 20;
      for(let i=0; i<explosionCount; i++) {
        const spark = new THREE.Mesh(
          new THREE.SphereGeometry(0.1, 6, 6),
          new THREE.MeshBasicMaterial({color: 0xffaa00, transparent: true, opacity: 0.8})
        );
        spark.position.copy(this.mesh.position);
        spark.velocity = new THREE.Vector3(
          (Math.random()-0.5)*0.4,
          (Math.random()-0.5)*0.4,
          (Math.random()-0.5)*0.4
        );
        spark.life = 15 + Math.floor(Math.random()*15);
        scene.add(spark);
        explosions.push(spark);
      }
    }
  }

  const jets = [];
  const missiles = [];
  const explosions = [];
  const respawnQueue = [];

  const maxSpeed = 0.15;
  const maxForce = 0.02;

  // Respawn jets on their team side with initial velocity pushing toward the enemy side
  function spawnJet(id, teamColor, isRespawn = false) {
    const jet = createJet(teamColor);
    // If red, spawn left side; if blue, spawn right side
    const sideX = (teamColor === 0xff0000) 
                    ? -30 + Math.random() * 10 
                    : 30 - Math.random() * 10;
    jet.position.set(
      sideX,
      5 + Math.random() * 5,
      (Math.random() - 0.5) * 40
    );

    // Velocity: red jets move toward +X, blue jets toward -X
    jet.velocity = new THREE.Vector3(
      (teamColor === 0xff0000 ? 0.05 : -0.05) + (Math.random() - 0.5) * 0.02,
      0,
      (Math.random() - 0.5) * 0.1
    );

    jet.isAlive = true;
    jet.cooldown = 0;
    jet.id = id;
    jet.teamColor = teamColor;

    scene.add(jet);
    jets[id] = jet;
  }

  // Spawn initial jets with explicit team color:
  for (let i = 0; i < 6; i++) {
    const color = i < 3 ? 0xff0000 : 0x0000ff;
    spawnJet(i, color);
  }

  function updateJetAI(jet) {
    if (!jet.isAlive) return;

    let closestEnemy = null;
    let closestDist = Infinity;
    jets.forEach(other => {
      if (other !== jet && other.isAlive && (jet.teamColor !== other.teamColor)) {
        const dist = jet.position.distanceTo(other.position);
        if (dist < closestDist) {
          closestDist = dist;
          closestEnemy = other;
        }
      }
    });
    if (!closestEnemy) return;

    const avoidForce = new THREE.Vector3();
    jets.forEach(other => {
      if (other !== jet && other.isAlive) {
        const dist = jet.position.distanceTo(other.position);
        if(dist < 3) {
          let diff = jet.position.clone().sub(other.position);
          diff.divideScalar(dist*dist);
          avoidForce.add(diff);
        }
      }
    });

    const desired = closestEnemy.position.clone().sub(jet.position).normalize().multiplyScalar(maxSpeed);
    const steer = desired.sub(jet.velocity).add(avoidForce.multiplyScalar(0.5));
    steer.clampLength(0, maxForce);

    jet.rotation.z = THREE.MathUtils.lerp(jet.rotation.z, -steer.z * 5, 0.1);
    jet.rotation.x = THREE.MathUtils.lerp(jet.rotation.x, steer.y * 5, 0.1);

    jet.velocity.add(steer);
    jet.velocity.clampLength(0, maxSpeed);

    jet.position.add(jet.velocity);

    // Simple boundary check - keep inside some box
    if(jet.position.x > 45) jet.position.x = 45;
    if(jet.position.x < -45) jet.position.x = -45;
    if(jet.position.y > 20) jet.position.y = 20;
    if(jet.position.y < 2) jet.position.y = 2;
    if(jet.position.z > 45) jet.position.z = 45;
    if(jet.position.z < -45) jet.position.z = -45;

    // Fire missile cooldown and logic
    jet.cooldown--;
    if(jet.cooldown <= 0 && closestEnemy && closestDist < 20) {
      fireMissile(jet, closestEnemy);
      jet.cooldown = 100 + Math.floor(Math.random()*50);
    }
  }

  function fireMissile(jet, target) {
    const dir = target.position.clone().sub(jet.position).normalize();
    const missile = new Missile(jet.position.clone().add(dir.clone().multiplyScalar(1.5)), dir, jet);
    missiles.push(missile);
  }

  function updateMissiles() {
    for(let i = missiles.length - 1; i >= 0; i--) {
      const m = missiles[i];
      m.update();

      // Simple collision detection with enemy jets
      jets.forEach(jet => {
        if(jet.isAlive && jet !== m.owner) {
          const dist = m.mesh.position.distanceTo(jet.position);
          if(dist < 1) {
            jet.isAlive = false;
            scene.remove(jet);
            missiles.splice(i, 1);
            m.destroy();

            // Queue respawn
            respawnQueue.push({id: jet.id, teamColor: jet.teamColor, timer: 200});
          }
        }
      });

      if(m.isDestroyed) missiles.splice(i, 1);
    }
  }

  function updateExplosions() {
    for(let i = explosions.length - 1; i >= 0; i--) {
      const spark = explosions[i];
      spark.position.add(spark.velocity);
      spark.life--;
      spark.material.opacity = (spark.life / 30);
      if(spark.life <= 0) {
        scene.remove(spark);
        explosions.splice(i, 1);
      }
    }
  }

  function updateCamera() {
    // Simple static overview for now
    camera.position.set(0, 40, 60);
    camera.lookAt(0, 5, 0);
  }

  function updateHUD() {
    const hud = document.getElementById('hud');
    hud.innerHTML = `Camera: Overview<br>Missiles: ${missiles.length}`;
  }

  function animate() {
    requestAnimationFrame(animate);

    // Animate engine glow flicker for each jet
    jets.forEach(jet => {
      if(jet && jet.isAlive && jet.engineLight) {
        const intensity = 1.0 + Math.sin(Date.now() * 0.01 + jet.id) * 0.5;
        jet.engineLight.intensity = THREE.MathUtils.clamp(intensity, 0.7, 2.5);
        jet.engineMaterial.emissiveIntensity = jet.engineLight.intensity;
      }
    });

    jets.forEach(jet => updateJetAI(jet));
    updateMissiles();
    updateExplosions();
    updateCamera();
    updateHUD();

    // Handle respawn queue timers
    for(let i=respawnQueue.length-1; i>=0; i--) {
      const item = respawnQueue[i];
      item.timer--;
      if(item.timer <= 0) {
        spawnJet(item.id, item.teamColor, true);
        respawnQueue.splice(i, 1);
      }
    }

    // Move clouds slowly
    clouds.forEach(c => {
      c.position.x += 0.005;
      if(c.position.x > 100) c.position.x = -100;
    });

    renderer.render(scene, camera);
  }

  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

})();
</script>
</body>
</html>